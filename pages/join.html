<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Join Game - Secret Hitler</title>
    <meta name="description" content="Join an existing Secret Hitler game">
    <link rel="stylesheet" href="../styles/app.css">
    <link rel="manifest" href="../manifest.json">
    <meta name="theme-color" content="#101820">
    <link rel="apple-touch-icon" sizes="180x180" href="../icons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../icons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../icons/favicon-16x16.png">
    <link rel="icon" href="../icons/favicon.ico">
    <script src="../js/theme.js"></script>
    <script src="https://www.google.com/recaptcha/api.js?render=6Lf5TrUrAAAAAGYRvnOM3iYMhMSABS1ndvIb5CGO" async defer></script>
    <style>
        #player-pin {
            font-family: 'Courier New', monospace;
            letter-spacing: 0.5em;
            text-align: center;
            font-size: 1.2em;
        }
        
        #player-pin::placeholder {
            letter-spacing: 0.2em;
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <!-- Header -->
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <div class="logo" onclick="window.location.href='../index.html'">
                        <span class="logo-icon">ðŸŽ­</span>
                        <div class="logo-text">
                            <h1>Secret Hitler</h1>
                            <p class="subtitle">Join Game</p>
                        </div>
                    </div>
                    <div class="header-actions">
                        <!-- Theme toggle removed -->
                    </div>
                </div>
            </div>
        </header>
        
        <!-- Main Content -->
        <main>
            <div class="container">
                <div class="card mb-4">
                    <div class="card-header">
                        <span class="card-icon">ðŸ”—</span>
                        <div>
                            <h2 class="card-title">Join Game</h2>
                            <p class="section-description">Enter your name to join the lobby</p>
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="form-group">
                            <label class="form-label" for="game-id">Game Code</label>
                            <input id="game-id" class="form-control code-input" type="text" placeholder="e.g. 7K3MZ" maxlength="10" autocomplete="off" autocorrect="off" spellcheck="false" inputmode="text" autocapitalize="characters">
                            <small class="form-help">Paste or type the game code</small>
                        </div>

                        <div id="game-status" class="mt-2 mb-4"></div>

                        <div id="player-name-group" class="form-group" style="display: none;">
                            <label class="form-label" for="player-name">Player Name</label>
                            <input id="player-name" class="form-control" type="text" placeholder="Your name" maxlength="24" autocomplete="name" list="existing-names">
                            <datalist id="existing-names"></datalist>
                            <select id="player-name-select" class="form-control hidden"></select>
                            <small class="form-help">Choose your name from the roster when a valid Game ID is entered</small>
                        </div>

                        <div id="player-pin-group" class="form-group" style="display: none;">
                            <label class="form-label" for="player-pin">Reconnection PIN <span id="pin-status">(required)</span></label>
                            <input id="player-pin" class="form-control" type="password" placeholder="Enter 4-digit PIN" maxlength="4" pattern="[0-9]{4}" inputmode="numeric" autocomplete="new-password" required disabled>
                            <small class="form-help" id="pin-help">Set a 4-digit PIN to reconnect if you get disconnected. You can use this PIN to rejoin with the same name later.</small>
                        </div>
                        <div class="btn-group">
                            <button id="join-btn" class="btn btn-primary">Join Lobby</button>
                            <button class="btn btn-outline" onclick="window.location.href='../index.html'">Back to Home</button>
                        </div>
                        <div id="join-status" class="mt-3"></div>
                        
                        <!-- reCAPTCHA Status -->
                        <div id="recaptcha-status" class="mt-3 text-center text-sm text-gray-600" style="display: none;">
                            <div id="cooldown-info"></div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer class="main-footer">
            <div class="container">
                <div class="footer-content">
                    <p class="footer-text">Connect and play with friends anywhere</p>
                    <div class="footer-links">
                        <a href="../pages/rules.html" class="footer-link">ðŸ“– Rules</a>
                        <span class="footer-separator">â€¢</span>
                        <a href="../index.html" class="footer-link">ðŸŽ® Play</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script type="module">
        import { app } from '../js/firebase.js';
        import SessionManager from '../js/session-manager.js';
        import { getFirestore, doc, collection, serverTimestamp, getDoc, setDoc, query, getDocs, where, updateDoc, orderBy, onSnapshot } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
        import recaptchaManager from '../js/recaptcha.js';

        const db = getFirestore(app);
        const sessionManager = new SessionManager(app);
        let playersUnsubscribe = null; // Track the listener so we can unsubscribe when game changes

        function getGameIdFromUrl() {
            const params = new URLSearchParams(window.location.search);
            return params.get('game') || '';
        }

        function normalizeGameId(id) {
            // Accept only A-Z and 2-9, excluding I/O/1/0; limit to 5 chars
            const raw = (id || '').toString();
            const upper = raw.toUpperCase();
            const cleaned = upper
                .replace(/[IO10]/g, '') // remove ambiguous chars entirely
                .replace(/[^A-Z2-9]/g, '');
            return cleaned.slice(0, 5);
        }

        function formatGameIdForDisplay(normalized) {
            // Keep as-is; no dashes
            return String(normalized || '');
        }

        async function ensureAuth() {
            const auth = getAuth(app);
            if (!auth.currentUser) await signInAnonymously(auth);
            return auth.currentUser;
        }

        async function checkPlayerReconnection(gameId, name, pin) {
            const gameRef = doc(db, 'games', gameId);
            const playersCol = collection(gameRef, 'players');
            
            // Check if this player name exists and has a PIN set
            const q = query(playersCol, where('name', '==', name.trim()));
            const snap = await getDocs(q);
            
            if (!snap.empty) {
                for (const d of snap.docs) {
                    const data = d.data() || {};
                    if (data.pin && data.pin === pin) {
                        // PIN matches, allow reconnection
                        return { playerId: d.id, playerData: data };
                    }
                }
            }
            return null;
        }

        async function claimOrAddPlayer(gameId, name, uid, pin) {
            const gameRef = doc(db, 'games', gameId);
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists()) throw new Error('Game not found');
            const playersCol = collection(gameRef, 'players');

            // Only allow joining with an existing player name; do not auto-create
            const q = query(playersCol, where('name', '==', name.trim()));
            const snap = await getDocs(q);
            if (snap.empty) {
                throw new Error('Player name not found in this game');
            }

            let claimedPlayerId = null;
            for (const d of snap.docs) {
                const data = d.data() || {};
                if (data.uid === uid) {
                    // Update existing claim with new PIN and timestamp
                    await updateDoc(d.ref, {
                        lastSeen: serverTimestamp(),
                        pin: pin || null,
                        sessionId: sessionManager.sessionId
                    });
                    claimedPlayerId = d.id;
                    break;
                }
                if (!data.uid) {
                    // Claim unclaimed player with PIN
                    await updateDoc(d.ref, {
                        uid,
                        lastSeen: serverTimestamp(),
                        pin: pin || null,
                        sessionId: sessionManager.sessionId
                    });
                    claimedPlayerId = d.id;
                    break;
                }
            }

            if (!claimedPlayerId) {
                throw new Error('That name is already taken. Are you sure? (Yes)');
            }

            // Extend TTL by 15 minutes when a player joins/claims
            await setDoc(gameRef, { updatedAt: serverTimestamp(), expireAt: new Date(Date.now() + 15 * 60 * 1000) }, { merge: true });

            // Persist for lobby heartbeat (per-tab)
            try { sessionStorage.setItem(`sh_playerId_${gameId}`, claimedPlayerId); } catch (_) {}
            return claimedPlayerId;
        }

        let currentGameData = null; // Store current game data

        async function loadGameMeta(gameId) {
            const statusEl = document.getElementById('game-status');
            const datalist = document.getElementById('existing-names');
            const nameInput = document.getElementById('player-name');
            const nameSelect = document.getElementById('player-name-select');
            const nameGroup = document.getElementById('player-name-group');
            const pinGroup = document.getElementById('player-pin-group');

            // Unsubscribe from previous game's player updates
            if (playersUnsubscribe) {
                playersUnsubscribe();
                playersUnsubscribe = null;
            }

            datalist.innerHTML = '';
            if (!gameId) {
                statusEl.textContent = '';
                currentGameData = null;
                // Hide name and pin fields when no game
                if (nameGroup) nameGroup.style.display = 'none';
                if (pinGroup) pinGroup.style.display = 'none';
                // Revert to free text when no game
                if (nameSelect) { nameSelect.style.display = 'none'; nameSelect.classList.add('hidden'); nameSelect.innerHTML = ''; }
                if (nameInput) { nameInput.style.display = ''; nameInput.value = ''; }
                const btn = document.getElementById('join-btn');
                if (btn) btn.textContent = 'Join Lobby';
                return null;
            }
            const gameRef = doc(db, 'games', gameId);
            const snap = await getDoc(gameRef);
            if (!snap.exists()) {
                statusEl.textContent = 'Game not found.';
                currentGameData = null;
                // Hide name and pin fields when game not found
                if (nameGroup) nameGroup.style.display = 'none';
                if (pinGroup) pinGroup.style.display = 'none';
                if (nameSelect) { nameSelect.style.display = 'none'; nameSelect.classList.add('hidden'); nameSelect.innerHTML = ''; }
                if (nameInput) { nameInput.style.display = ''; }
                const btn = document.getElementById('join-btn');
                if (btn) btn.textContent = 'Join Lobby';
                return null;
            }
            const game = snap.data();
            statusEl.textContent = '';

            // Show name and pin fields when game is found
            if (nameGroup) nameGroup.style.display = 'block';
            if (pinGroup) pinGroup.style.display = 'block';

            // Update join button label depending on game state
            try {
                const state = (game && game.state) ? String(game.state) : 'lobby';
                const btn = document.getElementById('join-btn');
                if (btn) btn.textContent = (state === 'reveal' || state === 'playing') ? 'Join Game' : 'Join Lobby';
            } catch (_) {}

            // CRITICAL: Set currentGameData BEFORE setting up the listener
            // because onSnapshot fires immediately and needs access to game data
            currentGameData = game;

            // Set up real-time listener for player changes
            const playersQuery = query(collection(gameRef, 'players'), orderBy('createdAt', 'asc'));
            playersUnsubscribe = onSnapshot(playersQuery, (playersSnap) => {
                updatePlayerDropdown(playersSnap, gameId);
            });

            try { localStorage.setItem('sh_currentGameId', gameId); } catch (_) {}
            return game;
        }

        async function updatePlayerDropdown(playersSnap, gameId) {
            const datalist = document.getElementById('existing-names');
            const nameInput = document.getElementById('player-name');
            const nameSelect = document.getElementById('player-name-select');

            // Get host name from current game data
            const hostName = currentGameData ? (currentGameData.hostName || '').trim() : '';

            // Read host pass requirement from game
            const PRESENT_WINDOW_MS = 90 * 1000; // 90s: faster reclaim from a new device
            let currentUser = null;
            try { currentUser = await ensureAuth(); } catch (_) { currentUser = null; }
            const currentUid = currentUser ? currentUser.uid : null;
            const now = Date.now();
            const idToName = new Map();
            const nameInfo = new Map();

            playersSnap.docs.forEach(d => {
                const data = d.data() || {};
                const n = (data.name || '').toString().trim();
                if (!n) return;
                idToName.set(d.id, n);
                const uid = data.uid || null;
                const isHost = hostName && n === hostName;
                let info = nameInfo.get(n);
                if (!info) {
                    info = { name: n, unclaimed: 0, hasActive: false, staleClaimed: false, youMatches: 0, hasClaimed: false, isHost: isHost };
                    nameInfo.set(n, info);
                }
                if (!uid) {
                    info.unclaimed += 1;
                } else {
                    // Mark that this name has been claimed by someone
                    info.hasClaimed = true;
                    // Count if this name currently belongs to your UID
                    if (currentUid && uid === currentUid) info.youMatches += 1;
                    // Presence check for active session
                    try {
                        const ms = data.lastSeen && data.lastSeen.toDate ? data.lastSeen.toDate().getTime() : 0;
                        if (uid && ms > 0 && (now - ms) <= PRESENT_WINDOW_MS) {
                            info.hasActive = true;
                        } else if (uid && ms > 0 && (now - ms) > PRESENT_WINDOW_MS) {
                            info.staleClaimed = true;
                        }
                    } catch (_) {}
                }
            });

            // Decide a single seat to label as "Your seat": prefer saved playerId; else unique uid match
            let savedPlayerId = null;
            try { savedPlayerId = sessionStorage.getItem(`sh_playerId_${gameId}`) || null; } catch (_) { savedPlayerId = null; }
            let youSeatName = null;
            if (savedPlayerId && idToName.has(savedPlayerId)) {
                youSeatName = idToName.get(savedPlayerId);
            } else {
                const youNames = Array.from(nameInfo.values()).filter(i => i.youMatches > 0).map(i => i.name);
                if (youNames.length === 1) youSeatName = youNames[0];
            }

            // Save current selection before updating dropdown
            const currentSelection = nameSelect ? nameSelect.value : '';

            // Populate dropdown and datalist with optgroups
            if (nameSelect) { nameSelect.innerHTML = ''; }
            datalist.innerHTML = '';

            const allNames = Array.from(nameInfo.values()).map(i => i.name).sort((a,b) => a.localeCompare(b));
            allNames.forEach(n => {
                const opt = document.createElement('option');
                opt.value = n;
                datalist.appendChild(opt);
            });

            if (nameSelect) {
                const placeholder = document.createElement('option');
                placeholder.value = '';
                placeholder.textContent = 'Select your name';
                placeholder.disabled = true;
                placeholder.selected = true;
                nameSelect.appendChild(placeholder);

                const availableGroup = document.createElement('optgroup');
                availableGroup.label = 'Available';
                const unavailableGroup = document.createElement('optgroup');
                unavailableGroup.label = 'Taken';

                const availableNames = [];
                const unavailableNames = [];
                nameInfo.forEach(info => {
                    const isYourSeat = Boolean(youSeatName && info.name === youSeatName);

                    // Simplified availability logic:
                    // 1. Your seat is ALWAYS available (you can reclaim your own seat)
                    // 2. Host is ALWAYS unavailable (unless it's your seat) - even if unclaimed
                    //    This prevents others from taking the host seat before the host joins
                    // 3. Other players: available if unclaimed OR claimed but stale (not active)

                    let available;
                    if (isYourSeat) {
                        // Your own seat is always available
                        available = true;
                    } else if (info.isHost) {
                        // Host is ALWAYS unavailable unless it's your seat
                        // This prevents others from joining as host even if host hasn't claimed seat yet
                        available = false;
                    } else if (info.hasActive) {
                        // Someone else is actively present -> UNAVAILABLE
                        available = false;
                    } else {
                        // Either unclaimed or stale (not actively present) -> AVAILABLE
                        available = true;
                    }

                    (available ? availableNames : unavailableNames).push(info);
                });
                availableNames.sort((a,b) => a.name.localeCompare(b.name));
                unavailableNames.sort((a,b) => a.name.localeCompare(b.name));

                availableNames.forEach(info => {
                    const o = document.createElement('option');
                    o.value = info.name;
                    // Show "Available" for stale/unclaimed seats, no label for unclaimed
                    const label = (info.staleClaimed && info.unclaimed === 0) ? ' - Available' : '';
                    o.textContent = info.name + label;
                    availableGroup.appendChild(o);
                });
                unavailableNames.forEach(info => {
                    const o = document.createElement('option');
                    o.value = info.name;
                    // Show "Host" label if this is the host (regardless of active status)
                    const label = info.isHost ? ' - Host (PIN required)' : ' - Taken (PIN required)';
                    o.textContent = info.name + label;
                    // DO NOT disable - allow selection but require correct PIN
                    unavailableGroup.appendChild(o);
                });

                if (availableNames.length) nameSelect.appendChild(availableGroup);
                if (unavailableNames.length) nameSelect.appendChild(unavailableGroup);

                // Auto-select logic: prioritize available players (excluding host if active)
                const stillExists = allNames.includes(currentSelection);
                const currentlyAvailable = availableNames.some(info => info.name === currentSelection);

                // Keep selection if it still exists AND is available, otherwise auto-select an available player
                if (stillExists && currentSelection && currentlyAvailable) {
                    nameSelect.value = currentSelection;
                } else {
                    // Priority: 1) Your seat, 2) First available non-host player, 3) First available player, 4) Keep current if unavailable but exists
                    const yours = youSeatName ? availableNames.find(i => i.name === youSeatName) : null;
                    if (yours) {
                        nameSelect.value = yours.name;
                        try { nameSelect.dispatchEvent(new Event('change')); } catch (_) {}
                    } else if (availableNames.length > 0) {
                        // Prioritize non-host players for default selection
                        const nonHostAvailable = availableNames.find(i => !i.isHost);
                        if (nonHostAvailable) {
                            nameSelect.value = nonHostAvailable.name;
                        } else {
                            // If only host is available (rare case), select them
                            nameSelect.value = availableNames[0].name;
                        }
                        try { nameSelect.dispatchEvent(new Event('change')); } catch (_) {}
                    } else if (stillExists && currentSelection) {
                        // No available players, but keep current selection if it exists
                        nameSelect.value = currentSelection;
                    }
                }
            }

            // Switch to dropdown mode
            if (nameInput) nameInput.style.display = 'none';
            if (nameSelect) { nameSelect.classList.remove('hidden'); nameSelect.style.display = 'block'; }

            // Ensure Join button state reflects current selection
            const joinBtnEl = document.getElementById('join-btn');
            if (joinBtnEl) {
                const usingSelect = nameSelect && nameSelect.style.display !== 'none';
                const selectedValid = usingSelect
                    ? (nameSelect.value && nameSelect.selectedOptions.length)
                    : Boolean(nameInput && (nameInput.value || '').trim());
                joinBtnEl.disabled = !(selectedValid && !!gameId);
            }

            // Update PIN field based on selected player
            updatePinFieldForPlayer(playersSnap, gameId);
        }

        async function updatePinFieldForPlayer(playersSnap, gameId) {
            const nameInput = document.getElementById('player-name');
            const nameSelect = document.getElementById('player-name-select');
            const pinInput = document.getElementById('player-pin');
            const pinStatus = document.getElementById('pin-status');
            const pinHelp = document.getElementById('pin-help');

            // Get selected name
            const selectedName = (nameSelect && nameSelect.style.display !== 'none')
                ? nameSelect.value
                : nameInput.value;

            if (!selectedName || !playersSnap) {
                // No player selected - show "setting the code" state
                pinInput.disabled = true;
                pinInput.value = '';
                pinInput.placeholder = 'Setting the code...';
                if (pinStatus) pinStatus.textContent = '(required)';
                if (pinHelp) pinHelp.textContent = 'Select a player name first.';
                return;
            }

            // Check if selected player has a PIN
            let playerHasPin = false;
            playersSnap.docs.forEach(d => {
                const data = d.data() || {};
                if (data.name === selectedName.trim() && data.pin) {
                    playerHasPin = true;
                }
            });

            // PIN is always required
            pinInput.disabled = false;
            pinInput.value = '';
            pinInput.placeholder = 'Enter 4-digit PIN';
            pinInput.required = true;
            if (pinStatus) pinStatus.textContent = '(required)';

            if (playerHasPin) {
                // Player has a PIN - need to enter it to reconnect
                if (pinHelp) pinHelp.textContent = 'This player has a PIN set. Enter it to reconnect.';
            } else {
                // Player doesn't have a PIN - need to set one
                if (pinHelp) pinHelp.textContent = 'Set a 4-digit PIN to reconnect if you get disconnected.';
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            const joinBtn = document.getElementById('join-btn');
            const nameInput = document.getElementById('player-name');
            const nameSelect = document.getElementById('player-name-select');
            const status = document.getElementById('join-status');
            const gameIdInput = document.getElementById('game-id');
            const playerPinInput = document.getElementById('player-pin');

            // PIN input validation - only allow numbers and limit to 4 digits
            playerPinInput.addEventListener('input', function(e) {
                let value = e.target.value.replace(/\D/g, ''); // Remove non-digits
                value = value.slice(0, 4); // Limit to 4 digits
                e.target.value = value;
                updateJoinEnabled();
            });

            // Prevent non-numeric input
            playerPinInput.addEventListener('keypress', function(e) {
                if (!/\d/.test(e.key)) {
                    e.preventDefault();
                }
            });

            let currentGameId = normalizeGameId(getGameIdFromUrl());
            if (currentGameId) {
                // Populate the input field with the game ID from the URL
                gameIdInput.value = currentGameId;
                // Do not mutate the field; only use normalized copy for lookups
                if (currentGameId.length === 5) loadGameMeta(currentGameId);
            }

            function getSelectedName() {
                if (nameSelect && nameSelect.style.display !== 'none') {
                    const val = (nameSelect.value || '').trim();
                    if (val === '' || nameSelect.selectedOptions.length === 0) return '';
                    return val;
                }
                return (nameInput.value || '').trim();
            }

            function updateJoinEnabled() {
                const name = getSelectedName();
                const gid = normalizeGameId(gameIdInput.value);
                const pin = playerPinInput.value;
                const validPin = pin && pin.length === 4 && /^\d{4}$/.test(pin);

                // PIN is always required
                const canJoin = name && gid && gid.length === 5 && validPin;
                joinBtn.disabled = !canJoin;
            }

            let debounceTimer = null;
            gameIdInput.addEventListener('input', function() {
                const gid = normalizeGameId(gameIdInput.value);
                clearTimeout(debounceTimer);
                if (gid.length === 5) {
                    debounceTimer = setTimeout(() => { loadGameMeta(gid); }, 150);
                } else {
                    debounceTimer = setTimeout(() => { loadGameMeta(''); }, 150);
                }
                updateJoinEnabled();
            });

            gameIdInput.addEventListener('paste', function() {
                // Allow paste unmodified; lookup happens via normalized copy on input
                setTimeout(() => {
                    const gid = normalizeGameId(gameIdInput.value);
                    clearTimeout(debounceTimer);
                    if (gid.length === 5) {
                        debounceTimer = setTimeout(() => { loadGameMeta(gid); }, 100);
                    } else {
                        debounceTimer = setTimeout(() => { loadGameMeta(''); }, 100);
                    }
                    updateJoinEnabled();
                }, 0);
            });

            nameInput.addEventListener('input', updateJoinEnabled);
            if (nameSelect) {
                nameSelect.addEventListener('change', function() {
                    updateJoinEnabled();
                    // Trigger PIN field update when player changes
                    if (playersUnsubscribe) {
                        const gid = normalizeGameId(gameIdInput.value);
                        if (gid) {
                            const gameRef = doc(db, 'games', gid);
                            const playersQuery = query(collection(gameRef, 'players'), orderBy('createdAt', 'asc'));
                            getDocs(playersQuery).then(snap => {
                                updatePinFieldForPlayer(snap, gid);
                            });
                        }
                    }
                });
                nameSelect.addEventListener('input', updateJoinEnabled);
            }
            playerPinInput.addEventListener('input', updateJoinEnabled);
            updateJoinEnabled();
            
            // Update reCAPTCHA status display
            function updateRecaptchaStatus() {
                const statusEl = document.getElementById('recaptcha-status');
                const cooldownEl = document.getElementById('cooldown-info');

                if (!statusEl || !cooldownEl) return;

                const remainingCooldown = recaptchaManager.getRemainingCooldown();

                if (remainingCooldown > 0) {
                    statusEl.style.display = 'block';
                    
                    if (remainingCooldown > 0) {
                        cooldownEl.textContent = `Cooldown: ${Math.ceil(remainingCooldown / 1000)}s remaining`;
                    } else {
                        cooldownEl.textContent = '';
                    }
                } else {
                    statusEl.style.display = 'none';
                }
            }
            
            // Update status every second
            setInterval(updateRecaptchaStatus, 1000);
            updateRecaptchaStatus();

            joinBtn.addEventListener('click', async function() {
                const name = getSelectedName();
                const gid = normalizeGameId(gameIdInput.value);
                const pin = playerPinInput.value;

                if (!name || !gid || gid.length !== 5) return;

                // PIN is always required and must be 4 digits
                if (!pin || pin.length !== 4 || !/^\d{4}$/.test(pin)) {
                    status.textContent = 'PIN is required and must be 4 digits.';
                    return;
                }

                joinBtn.disabled = true;
                status.textContent = 'Verifying...';
                
                try {
                    // Execute reCAPTCHA verification
                    const token = await recaptchaManager.execute('join_game');
                    
                    // Verify the token
                    const verification = await recaptchaManager.verifyToken(token, 'join_game');
                    
                    if (!verification.success) {
                        throw new Error('Verification failed. Please try again.');
                    }

                    status.textContent = 'Joining...';
                    const user = await ensureAuth();
                    
                    // Check if this name is already taken (has a PIN set)
                    const gameRef = doc(db, 'games', gid);
                    const playersCol = collection(gameRef, 'players');
                    const q = query(playersCol, where('name', '==', name.trim()));
                    const snap = await getDocs(q);

                    let playerHasPin = false;
                    let existingPin = null;
                    let playerId = null;

                    if (!snap.empty) {
                        for (const d of snap.docs) {
                            const data = d.data() || {};
                            if (data.pin) {
                                playerHasPin = true;
                                existingPin = data.pin;
                                playerId = d.id;
                                break;
                            }
                        }
                    }

                    // If name is taken and has a PIN, validate it
                    if (playerHasPin) {
                        if (pin !== existingPin) {
                            throw new Error('Incorrect PIN for this name. Please enter the correct PIN.');
                        }

                        // PIN matches - allow reconnection
                        await updateDoc(doc(db, 'games', gid, 'players', playerId), {
                            uid: user.uid,
                            lastSeen: serverTimestamp(),
                            sessionId: sessionManager.sessionId
                        });

                        // Extend TTL by 15 minutes
                        await setDoc(gameRef, {
                            updatedAt: serverTimestamp(),
                            expireAt: new Date(Date.now() + 15 * 60 * 1000)
                        }, { merge: true });

                        // Persist for lobby heartbeat
                        try { sessionStorage.setItem(`sh_playerId_${gid}`, playerId); } catch (_) {}

                        status.textContent = 'Joined! Redirecting to lobby...';
                        setTimeout(() => { window.location.href = `./lobby.html?game=${encodeURIComponent(gid)}`; }, 600);
                        return;
                    }

                    // PIN validation already handled above; just claim the player
                    await claimOrAddPlayer(gid, name, user.uid, pin);
                    status.textContent = 'Joined! Redirecting to lobby...';
                    setTimeout(() => { window.location.href = `./lobby.html?game=${encodeURIComponent(gid)}`; }, 600);
                } catch (e) {
                    console.error(e);
                    const errorMessage = (e && e.message) ? e.message : 'Failed to join. Check the Game ID and try again.';
                    
                    // Check if this is the "name already taken" error and create a clickable link
                    if (errorMessage.includes('That name is already taken. Are you sure? (Yes)')) {
                        status.innerHTML = 'That name is already taken. Are you sure? <a href="#" id="continue-anyway">(Yes)</a>';
                        
                        // Add click handler for the continue link
                        document.getElementById('continue-anyway').addEventListener('click', async function(e) {
                            e.preventDefault();
                            try {
                                // Force join with the same name by bypassing the check
                                const user = await ensureAuth();
                                const gameRef = doc(db, 'games', gid);
                                
                                // Find the player document and force claim it
                                const playersCol = collection(gameRef, 'players');
                                const q = query(playersCol, where('name', '==', name.trim()));
                                const snap = await getDocs(q);
                                
                                if (!snap.empty) {
                                    // Force claim the first available player slot
                                    const playerDoc = snap.docs[0];
                                    await updateDoc(playerDoc.ref, {
                                        uid: user.uid,
                                        lastSeen: serverTimestamp(),
                                        pin: pin || null,
                                        sessionId: sessionManager.sessionId
                                    });
                                    
                                    // Extend TTL by 15 minutes
                                    await setDoc(gameRef, { updatedAt: serverTimestamp(), expireAt: new Date(Date.now() + 15 * 60 * 1000) }, { merge: true });
                                    
                                    // Persist for lobby heartbeat
                                    try { sessionStorage.setItem(`sh_playerId_${gid}`, playerDoc.id); } catch (_) {}
                                    
                                    status.textContent = 'Joined! Redirecting to lobby...';
                                    setTimeout(() => { window.location.href = `./lobby.html?game=${encodeURIComponent(gid)}`; }, 600);
                                    return;
                                }
                            } catch (forceError) {
                                console.error(forceError);
                                status.textContent = 'Failed to force join. Please try again.';
                                joinBtn.disabled = false;
                            }
                        });
                    } else {
                        status.textContent = errorMessage;
                    }
                    joinBtn.disabled = false;
                }
            });
        });
    </script>
</body>
</html>
