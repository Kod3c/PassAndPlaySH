<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Play - Secret Hitler</title>
    <link rel="stylesheet" href="../styles/app.css">
    <link rel="stylesheet" href="parts/play-styles.css">
    <meta name="theme-color" content="#101820">
    <style>
        :root {
            --liberal-blue: #00AEEF;
            --fascist-red: #DA291C;
            --propaganda-black: #101820;
            --neutral-beige: #D6C6A9;
            --highlight-cream: #F1E6B2;
        }
        .play-wrapper { display:flex; flex-direction:column; min-height:100vh; background: var(--neutral-beige); }
        .play-main { flex:1; display:flex; flex-direction: column; align-items: stretch; justify-content:flex-start; padding: 0 12px 96px; }
        .board-shell { width: 100%; max-width: 1040px; margin: 0 auto; display:flex; flex-direction:column; align-items:center; gap: 12px; }
        .players-strip { display:flex; flex-wrap:wrap; gap:8px; justify-content:center; margin-top: 8px; }
        /* When role banner is visible, push players down a bit more */
        body.role-banner-visible .players-strip { margin-top: 8px; }
        .player-chip { padding: 4px 10px; border: 2px solid var(--propaganda-black); background:#fff; font-weight:700; }
        .player-chip.is-president { background: #fef3c7; }
        .player-chip.is-chancellor { background: #e0f2fe; }
        .board-area { width:100%; display:flex; flex-direction:column; gap:12px; }
        .board-frame { width:100%; border: 6px solid var(--propaganda-black); border-radius: 12px; background: #f6f0df; box-shadow: 0 10px 30px rgba(0,0,0,0.25), inset 0 0 0 4px var(--highlight-cream); padding: 16px; }
        .tracks { display:grid; grid-template-columns: 1fr; gap: 16px; }
        .track { display:flex; align-items:center; justify-content:space-between; gap:12px; padding:10px; border: 3px solid var(--propaganda-black); background: var(--neutral-beige); box-shadow: inset 0 0 0 3px rgba(0,0,0,0.15); border-radius: 8px; min-height: 88px; }
        .track.liberal { background: var(--liberal-blue); color: #fff; }
        .track.fascist { background: var(--fascist-red); color: #fff; }
        .track-title { font-weight:900; letter-spacing:0.04em; }
        .slots { display:flex; gap:8px; align-items:center; justify-content:center; }
        /* Liberal track: 5 slots, more spacing between cards */
        .track.liberal .slots { gap: 16px; }
        /* Fascist track: 6 slots, less spacing between cards to match liberal track width */
        .track.fascist .slots { gap: 4px; }
        .slot { width: 50px; height: 68px; border: 3px solid #000; background: rgba(255,255,255,0.18); box-shadow: inset 0 0 0 3px rgba(241,230,178,0.9); border-radius: 4px; position: relative; overflow: hidden; }
        /* ========================================
           POLICY CARD STYLING - BOARD TRACK SLOTS
           ========================================
           
           These styles control the appearance of policy cards that are placed
           into the board tracks (Liberal and Fascist policy slots).
           
           Key Features:
           - Percentage-based sizing for responsive scaling
           - Centered positioning with slight rotation
           - Background images (liberal bird, fascist skull)
           - Override conflicting styles from app.css
           
           QUICK SIZE ADJUSTMENT:
           To change card sizes, modify the 'width' percentage values below:
           
           CURRENT SETTINGS:
           - Base size: 110% (10% larger than slot width)
           - Mobile (480px): 110% (same as base)
           - Small mobile (360px): 102% (slightly smaller)
           - Ultra narrow (320px): 95% (smaller)
           - Very narrow (280px): 87% (smallest)
           
           EXAMPLES:
           - For 50% larger cards: change 110% to 165%
           - For 25% smaller cards: change 110% to 82.5%
           - For consistent sizing: use same percentage across all breakpoints
        */
        .slot .policy-card {
            /* POSITIONING & LAYOUT */
            position: absolute !important;
            top: 50% !important; 
            left: 50% !important; 
            right: auto !important; 
            bottom: auto !important;
            z-index: 2 !important;
            
            /* SIZING - Percentage-based for responsive scaling */
            width: 110% !important;  /* 110% of slot width - easily adjustable */
            height: auto !important;
            aspect-ratio: 92 / 132 !important;  /* Maintains card proportions */
            
            /* TRANSFORM - Centering and rotation */
            transform-origin: center center !important;
            transform: translate(-50%, -50%) rotate(-5deg) !important;  /* Center + slight tilt */
            
            /* BACKGROUND IMAGE - Set by JavaScript */
            background-size: contain !important;      /* Scale to fit card */
            background-repeat: no-repeat !important;  /* No tiling */
            background-position: center !important;   /* Center the image */
            
            /* VISUAL STYLING */
            border: 3px solid var(--propaganda-black) !important;
            border-radius: 4px !important;
            box-shadow: 0 2px 6px rgba(0,0,0,0.25) !important;
            
            /* INTERACTION */
            pointer-events: none !important;  /* Cards don't interfere with clicks */
            
            /* OVERRIDE CONFLICTING STYLES FROM app.css */
            padding: 0 !important;
            min-width: unset !important;
            text-align: unset !important;
        }
        /* When a policy is placed, let it overflow slightly for rotation */
        .slot.filled { overflow: visible; border-color: transparent; box-shadow: none; }
        .track.liberal .slot:empty::after { content: ""; position: absolute; inset: 0; background-image: url('../images/bird.png'); background-repeat: no-repeat; background-position: center; background-size: 46% auto; opacity: 0.6; filter: brightness(0) invert(1); pointer-events: none; }
        .track.fascist .slot:empty::after { content: ""; position: absolute; inset: 0; background-image: url('../images/skull.png'); background-repeat: no-repeat; background-position: center; background-size: 46% auto; opacity: 0.55; filter: brightness(0) invert(1); pointer-events: none; }
        /* Increase opacity for the last three fascist slots */
        .track.fascist .slot:nth-last-child(-n+3):empty::after { opacity: 0.85; }
        /* Decrease opacity for the first three fascist slots */
        .track.fascist .slot:nth-child(-n+3):empty::after { opacity: 0.25; }
        .tracker { display:flex; align-items:center; gap:10px; justify-content:center; padding-top: 4px; }
        .tracker-row { display:flex; align-items:center; justify-content:center; gap:10px; padding-top: 4px; }
        .tracker-label { font-weight:900; letter-spacing: 0.02em; }
        .tracker .bubble { width:26px; height:26px; border-radius:50%; background:#fff; border:3px solid var(--propaganda-black); }
        .tracker .square { width:26px; height:26px; border-radius:4px; background:#fff; border:3px solid var(--propaganda-black); display:inline-flex; align-items:center; justify-content:center; font-weight:900; }
        .tracker .square.active { background: var(--highlight-cream); }
        .policy-summary { display:flex; align-items:stretch; justify-content:center; gap:10px; margin-top: 8px; }
        .policy-card-wrap { display:flex; flex-direction:column; align-items:center; }
        .policy-card-title { display:none; font-weight:900; margin-bottom: 4px; letter-spacing:0.02em; }
        .policy-chip { padding: 6px 10px; border: 3px solid var(--propaganda-black); background:#fff; font-weight:800; box-shadow: inset 0 0 0 3px rgba(241,230,178,0.6); }
        .policy-chip.liberal { background: var(--liberal-blue); color:#fff; }
        .policy-chip.fascist { background: var(--fascist-red); color:#fff; }
        .policy-chip .count { margin-left: 6px; font-weight: 900; }
        @media (max-width: 640px) {
            /* Show policy counters side-by-side on mobile */
            .policy-summary { flex-direction: row; align-items: center; justify-content: center; gap: 8px; flex-wrap: nowrap; }
            .policy-card-title { display:none; }
            .policy-chip { padding: 6px 10px; white-space: nowrap; display: inline-flex; align-items: center; gap: 6px; }
            .policy-chip .policy-label { display: inline; }
            /* Reduce empty space below header by top-aligning content */
            .play-main { align-items: stretch; justify-content: flex-start; }
        }
        
        /* ========================================
           RESPONSIVE POLICY CARD SIZING
           ========================================
           
           These media queries ensure policy cards scale appropriately on narrow devices.
           The percentage values are easily adjustable for fine-tuning card sizes.
           
           BREAKPOINT GUIDE:
           - 480px and below: Mobile phones (landscape)
           - 360px and below: Small mobile phones
           - 320px and below: Ultra-narrow devices
           - 280px and below: Very narrow devices
           
           SIZE ADJUSTMENT:
           To make cards larger: increase the percentage values
           To make cards smaller: decrease the percentage values
           Current base size: 110% (10% larger than slot width)
        */
        
        /* Mobile phones and small tablets */
        @media (max-width: 480px) {
            html body .slot .policy-card,
            .slot .policy-card { 
                width: 110% !important;  /* Same as base size for consistency */
                border-width: 2px !important;  /* Thinner border for mobile */
            }
        }
        
        /* Small mobile phones */
        @media (max-width: 360px) {
            html body .slot .slot .policy-card,
            .slot .policy-card { 
                width: 102% !important;  /* Slightly smaller to fit narrow screens */
                border-width: 1.5px !important;  /* Even thinner border */
            }
        }
        
        /* Ultra-narrow devices */
        @media (max-width: 320px) {
            html body .slot .policy-card,
            .slot .policy-card { 
                width: 95% !important;  /* Smaller percentage for very narrow screens */
                border-width: 1px !important;  /* Minimal border */
            }
        }
        
        /* Very narrow devices (edge cases) */
        @media (max-width: 280px) {
            html body .slot .policy-card,
            .slot .policy-card { 
                width: 87% !important;  /* Smallest size for extremely narrow screens */
                border-width: 1px !important;  /* Minimal border */
            }
        }
        /* Compact layout for narrow phones */
        @media (max-width: 480px) {
            .play-main { padding: 0 8px calc(88px + env(safe-area-inset-bottom)); }
            /* Role banner: keep standard width on small screens */
            .role-bar { width: 100%; margin: 0; border-radius: 12px; }
            .board-frame { padding: 12px; }
            .track { flex-direction: column; align-items: center; gap: 8px; }
            .track-title { font-size: 0.95rem; text-align: center; }
            .slots { gap: 6px; }
            /* Liberal track: 5 slots, more spacing between cards on mobile */
            .track.liberal .slots { gap: 12px; }
            /* Fascist track: 6 slots, less spacing between cards on mobile to match liberal track width */
            .track.fascist .slots { gap: 4px; }
            .slot { width: 44px; height: 60px; }
            /* Player strip: larger chips and horizontal scroll */
            .players-strip { gap: 6px; flex-wrap: nowrap; overflow-x: auto; -webkit-overflow-scrolling: touch; padding-bottom: 2px; }
            body.role-banner-visible .players-strip { margin-top: 8px; }
            .players-strip::-webkit-scrollbar { display: none; }
            .player-chip { padding: 6px 10px; font-size: 1rem; white-space: nowrap; }
            /* Floating action bar adjustments for narrow screens */
            .floating-footer { padding: 0 8px; bottom: calc(8px + env(safe-area-inset-bottom)); }
            .actions-bar { padding: 8px; gap: 6px; flex-wrap: wrap; justify-content: space-between; }
            /* First row: center; Second row: left + right */
            .actions-center { order: 1; flex: 1 1 100%; display: flex; justify-content: center; }
            .actions-left { order: 2; flex: 1 1 0; display: flex; justify-content: flex-start; }
            .actions-right { order: 2; flex: 1 1 0; display: flex; justify-content: flex-end; }
            .actions-bar .btn { min-width: 0; padding: 8px 10px; font-size: 0.95rem; }
        }
        @media (max-width: 360px) {
            .slot { width: 40px; height: 54px; }
            /* Liberal track: 5 slots, more spacing between cards on very small screens */
            .track.liberal .slots { gap: 10px; }
            /* Fascist track: 6 slots, less spacing between cards on very small screens to match liberal track width */
            .track.fascist .slots { gap: 3px; }
            .status-banner { font-size: 1rem; padding: 10px 12px; }
            .player-chip { font-size: 1.05rem; }
            .actions-bar .btn { padding: 6px 8px; font-size: 0.9rem; }
        }
        .floating-footer { position: fixed; left: 0; right: 0; bottom: calc(12px + env(safe-area-inset-bottom)); padding: 0 12px; z-index: 50; pointer-events: none; }
        .actions-bar { pointer-events: auto; max-width: 960px; margin: 0 auto; display:flex; align-items:center; justify-content:space-between; gap:8px; padding: 10px 12px; background: rgba(255,255,255,0.95); border: 3px solid var(--propaganda-black); border-radius: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.25); }
        .actions-left, .actions-center, .actions-right { display:flex; gap:8px; align-items:center; }
        /* Ensure bottom action buttons don't become full-width on mobile */
        .actions-bar .btn { width: auto; flex: 0 0 auto; }
        .btn { cursor:pointer; border: 3px solid var(--propaganda-black); background:#fff; padding: 8px 12px; font-weight:800; letter-spacing: 0.02em; }
        .btn-primary { background: var(--highlight-cream); color: var(--propaganda-black); }
        .btn-secondary { background: var(--highlight-cream); color: var(--propaganda-black); }
        .btn-stuck { background: var(--fascist-red); color: #fff; border-color: var(--propaganda-black); }
        .status-banner { 
            display:flex; align-items:center; justify-content:center; gap:10px;
            padding: 12px 16px; background: var(--off-white); border: 4px solid var(--propaganda-black);
            border-radius: 12px; box-shadow: var(--shadow-lg); font-weight: 900; 
            font-family: var(--font-propaganda); text-transform: uppercase; letter-spacing: 0.05em; 
            text-align:center; animation: dropIn 180ms ease-out; font-size: 1.125rem; line-height: 1;
            color: #000;
        }
        .status-text { color: #000; }
        .status-banner.status-updated { animation: dropIn 180ms ease-out; }
        .status-banner.stuck-warning { 
            background: var(--fascist-red); 
            color: #fff; 
            border-color: var(--propaganda-black);
            animation: dropIn 180ms ease-out;
            margin: 8px 0;
            font-size: 1rem;
            padding: 10px 12px;
        }
        .debug-info { 
            color: var(--propaganda-black); 
            font-size: 0.9rem; 
            opacity: 0.7; 
            text-align: center; 
            margin-top: 8px; 
            font-family: var(--font-propaganda);
            letter-spacing: 0.02em;
        }
        /* Floating role banner */
        /* Role banner now inline (not fixed) */
        .floating-role { position: static; padding: 0; margin: 8px 0; z-index: auto; pointer-events: auto; display:none; width: 100%; align-self: stretch; }
        .role-bar { width: 100%; margin: 0; display:flex; align-items:center; justify-content:center; gap:10px; padding: 10px 12px; background: var(--off-white); border: 4px solid var(--propaganda-black); border-radius: 12px; box-shadow: var(--shadow-lg); font-weight: 900; font-family: var(--font-propaganda); text-transform: uppercase; letter-spacing: 0.05em; animation: dropIn 180ms ease-out; font-size: 1.25rem; line-height: 1; }
        .role-tag { padding: 0; border: 0; background: transparent; box-shadow: none; }
        .role-tag.pres { background: #fef3c7; }
        .role-tag.chanc { background: #e0f2fe; }
        @keyframes dropIn { from { transform: translateY(-8px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
        /* Modal */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.5); display:none; align-items: center; justify-content:center; z-index: 5000; }
        .modal-card { width: min(720px, 92vw); background: #fff; border: 4px solid var(--propaganda-black); border-radius: 12px; box-shadow: 0 12px 32px rgba(0,0,0,0.35); position: relative; }
        .modal-header { display:flex; align-items:center; justify-content:space-between; padding: 10px 12px; border-bottom: 3px solid var(--propaganda-black); }
        .modal-title { font-weight: 900; }
        .modal-body { padding: 12px; }
        .modal-close { position:absolute; top:8px; right:8px; width:32px; height:32px; padding:0; display:inline-flex; align-items:center; justify-content:center; border:3px solid var(--propaganda-black); background: var(--off-white); font-weight:900; box-shadow: var(--shadow-sm); cursor:pointer; }
        .modal-close:hover { box-shadow: var(--shadow-md); }
        /* Role overlay specific */
        .role-content { text-align: center; }
        .role-display { 
            margin: 20px 0; 
            padding: 20px; 
            border: 4px solid var(--propaganda-black); 
            border-radius: 12px; 
            background: rgba(255,255,255,0.1); 
            min-height: 120px; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
        }
        .role-label { 
            font-weight: 900; 
            letter-spacing: 0.03em; 
            font-size: 2rem; 
            color: #000; 
            text-align: center; 
        }
        .role-actions { 
            display: flex; 
            flex-direction: column; 
            gap: 12px; 
            align-items: center; 
        }
        .role-actions .btn { 
            min-width: 200px; 
            min-height: 48px; 
            font-size: 1.1rem; 
            transition: all 0.2s ease;
        }
        
        .role-actions .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        .role-actions .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #ccc !important;
            color: #666 !important;
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Special styling for the role button to make it stand out */
        .role-actions .btn[id="role-btn"] {
            background: var(--highlight-cream) !important;
            color: var(--propaganda-black) !important;
            border-width: 4px !important;
            font-weight: 900 !important;
        }
        
        /* Subtle styling for membership and comrades buttons */
        .role-actions .btn[id="membership-btn"],
        .role-actions .btn[id="compatriots-btn"] {
            background: rgba(241, 230, 178, 0.8) !important;
            color: var(--propaganda-black) !important;
            border-width: 3px !important;
        }
        
        /* Button hover effects for enabled buttons */
        .role-actions .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        /* Ensure buttons are always clickable and properly styled */
        .role-actions .btn {
            cursor: pointer !important;
            pointer-events: auto !important;
        }
        
        /* Adjust grid layout when comrades button is hidden */
        .role-actions-main:has(#compatriots-btn[style*="display: none"]) {
            grid-template-columns: 1fr 1fr;
        }
        
        /* Ensure proper spacing when only 2 buttons are visible */
        .role-actions-main:has(#compatriots-btn[style*="display: none"]) .btn {
            min-width: 220px;
        }
        
        /* Fallback for browsers without :has() support */
        .role-actions-main.comrades-hidden {
            grid-template-columns: 1fr 1fr;
        }
        
        .role-actions-main.comrades-hidden .btn {
            min-width: 220px;
        }
        /* Rules modal specific */
        .rules-modal .modal-card { max-height: 86vh; display:flex; flex-direction:column; }
        .rules-modal .modal-body { overflow:auto; }
        .rules-modal .modal-header { background: var(--off-white); }
        .rules-modal .modal-title { font-family: var(--font-fraktur); letter-spacing: 0.02em; font-size: var(--font-2xl); }
        .rules-modal .modal-subtitle { font-family: var(--font-propaganda); font-size: var(--font-lg); color: var(--dark-beige); }
        .rules-quicknav { display:flex; gap:8px; flex-wrap:nowrap; padding: 10px 12px; border-bottom: 3px solid var(--propaganda-black); background: var(--bg-card); position: sticky; top: 0; z-index: 1; overflow-x:auto; overflow-y:hidden; -webkit-overflow-scrolling: touch; }
        .rules-quicknav .rule-nav-btn { padding: 6px 10px; flex: 0 0 auto; display:flex; align-items:center; justify-content:center; gap:6px; }
        /* Bottom nav for rules (mobile) */
        .rules-bottomnav { display:none; position: sticky; bottom: 0; left: 0; right: 0; padding: 8px; background: var(--bg-card); border-top: 3px solid var(--propaganda-black); z-index: 1; }
        .rules-bottomnav-inner { display:flex; align-items:center; justify-content:space-between; gap:8px; }
        .rules-bottomnav .indicator { font-weight: 900; letter-spacing: 0.03em; }
        @media (max-width: 768px) {
            /* Medium screens - start transitioning to mobile layout */
            .role-actions-main {
                grid-template-columns: 1fr 1fr;
                gap: 10px;
            }
            
            .role-actions .btn {
                min-width: 160px;
                min-height: 46px;
            }
        }
        
        @media (max-width: 640px) {
            .rules-modal .modal-card { width: 96vw; max-height: 92vh; }
            .rules-modal .modal-body { padding: 8px; padding-bottom: 64px; }
            .rules-quicknav { gap:6px; padding: 8px; display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); overflow-x: hidden; overflow-y: visible; }
            .rules-quicknav .rule-nav-btn { padding: 10px; min-width: 0; width: 100%; }
            .rules-quicknav .nav-text { display:none; }
            .rules-quicknav .nav-icon { font-size: 1.125rem; }
            .rules-bottomnav { display:block; }
            .rules-bottomnav .btn { min-height: 44px; flex: 1; }
            .rules-bottomnav .indicator { flex: 0 0 auto; min-width: 64px; text-align:center; }
            
            /* Role actions responsive styling */
            .role-actions .btn { 
                min-width: 100%; 
                min-height: 44px; 
                font-size: 1rem; 
            }
            
            /* Stack buttons vertically on mobile */
            .role-actions-main {
                grid-template-columns: 1fr !important;
                gap: 8px !important;
            }
            
            /* Ensure buttons take full width on mobile */
            .role-actions .btn {
                width: 100% !important;
                min-width: 100% !important;
            }
        }
        @media (max-width: 360px) {
            .rules-quicknav { grid-template-columns: repeat(3, minmax(0, 1fr)); }
            
            /* Extra small screen role actions */
            .role-actions .btn { 
                min-height: 40px; 
                font-size: 0.9rem; 
                padding: 8px 12px;
            }
            
            .role-actions-main {
                gap: 6px !important;
            }
        }
        .order-list { display:flex; flex-direction:column; gap:8px; }
        .order-item { display:flex; align-items:center; justify-content:space-between; gap:8px; padding: 8px 10px; border: 2px dashed var(--propaganda-black); background:#fff; }
        .order-left { display:flex; align-items:center; gap:10px; }
        /* Space between badges/tags on the right side of player order rows */
        .order-right { display:flex; align-items:center; gap:6px; }
        .order-right > * + * { margin-left: 6px; }
        .order-num { width: 28px; height: 28px; border-radius: 50%; display:inline-flex; align-items:center; justify-content:center; border: 3px solid var(--propaganda-black); font-weight:900; background: var(--highlight-cream); }
        .badge-pres { padding: 2px 8px; background:#fef3c7; border:2px solid var(--propaganda-black); font-weight:800; }
        .badge-chanc { padding: 2px 8px; background:#e0f2fe; border:2px solid var(--propaganda-black); font-weight:800; }
        @media (min-width: 720px) {
            .tracks { grid-template-columns: 1fr; }
        }
        /* Voting popover */
        .vote-pop-wrap { position: relative; display: inline-block; }
        .vote-popover { position: absolute; bottom: 56px; left: 50%; transform: translateX(-50%); background: #fff; border: 3px solid var(--propaganda-black); border-radius: 10px; box-shadow: 0 10px 24px rgba(0,0,0,0.28); padding: 14px 16px; display: none; z-index: 10; }
        .vote-popover .btn { min-width: 120px; min-height: 48px; padding: 12px 18px; font-size: 1.125rem; }
        .vote-popover::after { content: ""; position: absolute; bottom: -10px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 10px solid transparent; border-right: 10px solid transparent; border-top: 10px solid var(--propaganda-black); }
        .btn-black { background: #101820; color: #fff; }
        /* Table-spread policy cards (design only) */
        .table-spread { 
            width: 100%; 
            display: flex; 
            flex-direction: row-reverse; 
            align-items: center; 
            justify-content: center; 
            gap: 0; 
            padding: 12px 0 0; 
            margin: 16px 0 0; 
            transition: transform 0.2s ease;
        }
        .table-spread:hover {
            transform: scale(1.02);
        }
        .table-spread .table-card { width: var(--play-card-w, 64px); height: var(--play-card-h, 92px); background-image: url('../images/policy-back.png'); background-size: cover; background-position: center; border: 3px solid var(--propaganda-black); border-radius: 6px; box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset 0 0 0 3px rgba(241,230,178,0.6); margin: 0 -18px; transform-origin: 50% 100%; }
        /* Ensure cards can host positioned tooltips */
        .table-spread .table-card { position: relative; }
        /* Glow/highlight for actionable table cards (no transform to preserve layout alignment) */
        .table-spread .table-card.glow { 
            box-shadow: 0 0 0 3px var(--highlight-cream), 0 0 0 6px var(--propaganda-black), 0 8px 16px rgba(0,0,0,0.35), inset 0 0 0 3px rgba(241,230,178,0.6) !important; 
            animation: pulseGlowSpread 1.2s ease-in-out infinite alternate !important; 
            will-change: filter, box-shadow; 
            transition: box-shadow 200ms ease-out, transform 200ms ease-out;
        }
        
        /* Group hover effect for the three glowing cards */
        .table-spread:hover .table-card.glow {
            box-shadow: 0 0 0 4px var(--highlight-cream), 0 0 0 8px var(--propaganda-black), 0 12px 28px rgba(0,0,0,0.4), inset 0 0 0 3px rgba(241,230,178,0.6) !important;
            transform: translateY(-8px) scale(1.05) !important;
            z-index: 15;
            filter: brightness(1.1) saturate(1.15) !important;
        }
        
        /* Ensure non-glowing cards don't get hover effects */
        .table-spread .table-card:not(.glow):hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset 0 0 0 3px rgba(241,230,178,0.6);
        }
        
        /* Make glowing cards more interactive */
        .table-spread .table-card.glow {
            cursor: pointer;
            pointer-events: auto;
        }
        
        /* Ensure non-glowing cards have default cursor */
        .table-spread .table-card:not(.glow) {
            cursor: default;
        }
        @keyframes pulseGlowSpread { from { filter: brightness(1) saturate(1); } to { filter: brightness(1.06) saturate(1.12); } }
        /* Single tooltip above the spread */
        .table-spread { position: relative; }
        .spread-tooltip { position: absolute; left: 0; top: 0; transform: translate(-50%, -100%); background: rgba(255,255,255,0.98); color: #000; padding: 8px 12px; border: 3px solid var(--propaganda-black); border-radius: 10px; box-shadow: 0 6px 14px rgba(0,0,0,0.25); font-weight: 900; font-family: var(--font-propaganda); text-transform: uppercase; letter-spacing: 0.04em; font-size: 0.9rem; white-space: nowrap; pointer-events: none; z-index: 3; }
        .spread-tooltip::after { content: ""; position: absolute; bottom: -8px; left: 50%; transform: translateX(-50%); width: 0; height: 0; border-left: 8px solid transparent; border-right: 8px solid transparent; border-top: 8px solid var(--propaganda-black); }
        /* Revealed fronts for table cards */
        .table-spread .table-card.is-front.liberal { background-image: url('../images/liberal.png'); }
        .table-spread .table-card.is-front.facist { background-image: url('../images/facist.png'); }
        .table-spread .table-card.lifting { transition: transform 140ms ease-out; }
        .table-spread .table-card.is-front { transform-origin: 50% 50%; z-index: 10; }
        .table-spread .table-card.revealed { transition: transform 220ms ease-out; }
        /* Overlay for centered reveal */
        .reveal-overlay { position: fixed; inset: 0; z-index: 6000; pointer-events: auto; }
        .reveal-overlay::before { content: ""; position: absolute; inset: 0; background: rgba(0,0,0,0.6); backdrop-filter: blur(2px); }
        .reveal-card { position: absolute; width: var(--play-card-w, 92px); height: var(--play-card-h, 132px); background-size: cover; background-position: center; border: 3px solid var(--propaganda-black); border-radius: 6px; box-shadow: 0 8px 16px rgba(0,0,0,0.35), inset 0 0 0 3px rgba(241,230,178,0.6); transform-origin: 50% 50%; transition: transform 240ms ease-out, left 240ms ease-out, top 240ms ease-out; }
        .reveal-instruction { position: absolute; top: 10%; left: 50%; transform: translateX(-50%); pointer-events: none; background: rgba(255,255,255,0.97); color: #000; padding: 14px 18px; border: 4px solid var(--propaganda-black); border-radius: 12px; box-shadow: 0 10px 28px rgba(0,0,0,0.4); font-weight: 900; font-family: var(--font-propaganda); text-transform: uppercase; letter-spacing: 0.05em; font-size: 1.15rem; text-align: center; min-width: min(560px, 86vw); }
        .reveal-actions { position: absolute; bottom: calc(10% + env(safe-area-inset-bottom)); left: 50%; transform: translateX(-50%); display: flex; align-items: center; justify-content: center; gap: 10px; }
        .reveal-btn { cursor: pointer; border: 4px solid var(--propaganda-black); background: var(--highlight-cream); color: var(--propaganda-black); padding: 12px 18px; font-weight: 900; letter-spacing: 0.03em; border-radius: 12px; box-shadow: 0 8px 20px rgba(0,0,0,0.35); text-transform: uppercase; font-family: var(--font-propaganda); font-size: 1.05rem; }
        .reveal-btn[disabled] { opacity: 0.6; cursor: not-allowed; filter: grayscale(0.3); }
        .reveal-card.selected { box-shadow: 0 0 0 4px var(--highlight-cream), 0 0 0 8px var(--propaganda-black), 0 10px 24px rgba(0,0,0,0.4), inset 0 0 0 3px rgba(241,230,178,0.6); }
        .reveal-card.selected::after { content: "âœ“"; position: absolute; top: -12px; right: -12px; width: 36px; height: 36px; border-radius: 50%; background: var(--highlight-cream); color: #000; display: inline-flex; align-items: center; justify-content: center; border: 3px solid var(--propaganda-black); font-weight: 900; box-shadow: 0 6px 14px rgba(0,0,0,0.35); }
        
        /* Chancellor choice overlay specific styles */
        #chancellor-choice-overlay .reveal-card {
            transition: box-shadow 200ms ease-out;
        }
        
        #chancellor-choice-overlay .reveal-card:hover {
            box-shadow: 0 0 0 4px var(--highlight-cream), 0 0 0 8px var(--propaganda-black), 0 12px 28px rgba(0,0,0,0.4), inset 0 0 0 3px rgba(241,230,178,0.6);
        }
        
        #chancellor-choice-overlay .reveal-card.selected {
            box-shadow: 0 0 0 4px var(--highlight-cream), 0 0 0 8px var(--propaganda-black), 0 12px 28px rgba(0,0,0,0.4), inset 0 0 0 3px rgba(241,230,178,0.6);
            z-index: 10;
        }
        
        /* Hover effect for face-down cards - both light up together */
        #chancellor-choice-overlay .reveal-card:not(.flipped):hover {
            box-shadow: 0 0 0 4px var(--highlight-cream), 0 0 0 8px var(--propaganda-black), 0 12px 24px rgba(0,0,0,0.4), inset 0 0 0 3px rgba(241,230,178,0.6);
            transition: box-shadow 200ms ease-out;
        }
        
        /* When any face-down card is hovered, both get enhanced glow */
        #chancellor-choice-overlay:hover .reveal-card:not(.flipped) {
            box-shadow: 0 0 0 3px var(--highlight-cream), 0 0 0 6px var(--propaganda-black), 0 8px 16px rgba(0,0,0,0.3), inset 0 0 0 3px rgba(241,230,178,0.6);
            transition: box-shadow 200ms ease-out;
        }
        /* Subtle varied angles to simulate a real table spread */
        .table-spread .table-card:nth-child(1) { transform: rotate(18deg); }
        .table-spread .table-card:nth-child(2) { transform: rotate(14deg); }
        .table-spread .table-card:nth-child(3) { transform: rotate(10deg); }
        .table-spread .table-card:nth-child(4) { transform: rotate(6deg); }
        .table-spread .table-card:nth-child(5) { transform: rotate(3deg); }
        .table-spread .table-card:nth-child(6) { transform: rotate(1deg); }
        .table-spread .table-card:nth-child(7) { transform: rotate(-1deg); }
        .table-spread .table-card:nth-child(8) { transform: rotate(-3deg); }
        .table-spread .table-card:nth-child(9) { transform: rotate(-6deg); }
        .table-spread .table-card:nth-child(10) { transform: rotate(-10deg); }
        .table-spread .table-card:nth-child(11) { transform: rotate(-14deg); }
        .table-spread .table-card:nth-child(12) { transform: rotate(-18deg); }
        /* Deck + Discard stacks flanking the spread */
        .cards-area { 
            width: 100%; 
            display: flex; 
            justify-content: center; 
            margin: 20px 0 0; 
            padding: 16px;
            background: rgba(246, 240, 223, 0.3);
            border-radius: 12px;
            border: 2px solid rgba(16, 24, 32, 0.1);
        }
        .cards-row { 
            display: flex; 
            align-items: center; 
            justify-content: center;
            gap: 80px; 
            /* Remove margin since cards-area handles spacing */
        }
        /* Role envelope styling - mirrored discard pile */
        .role-envelope {
            cursor: pointer;
            transition: transform 0.2s ease, filter 0.2s ease;
            position: relative;
            z-index: 5;
            width: calc(var(--play-card-w, 64px) + 8px);
            height: calc(var(--play-card-h, 92px) + 8px);
            transform-origin: 50% 100%;
            transform: translate(8px, 8px) scale(1.3) rotate(-2deg); /* Size similar to discard, moved right */
        }
        .role-envelope:hover {
            transform: translate(8px, 8px) scale(1.365) rotate(-2deg);
            filter: brightness(1.1);
        }
        .role-envelope:active {
            transform: translate(8px, 8px) scale(1.274) rotate(-2deg);
        }
        .envelope-image {
            width: 100%;
            height: 100%;
            object-fit: cover;
            pointer-events: none;
            background-size: cover;
            background-position: center;
            border-radius: 6px;
        }
        .card-stack.discard { }
        .card-stack { 
            position: relative; 
            width: calc(var(--play-card-w, 64px) + 8px); 
            height: calc(var(--play-card-h, 92px) + 8px); 
            flex: 0 0 auto; 
            transition: transform 0.2s ease;
        }
        .card-stack:hover {
            transform: scale(1.05);
        }
        .stack-card { position: absolute; left: 0; bottom: 0; width: var(--play-card-w, 64px); height: var(--play-card-h, 92px); background-size: cover; background-position: center; border: 3px solid var(--propaganda-black); border-radius: 6px; box-shadow: 0 4px 8px rgba(0,0,0,0.2), inset 0 0 0 3px rgba(241,230,178,0.6); }
        .stack-card.is-back { background-image: url('../images/policy-back.png'); }
        .stack-card.is-discard { background-image: url('../images/discard.png'); }
        .card-stack.discard .stack-card.policy-on-discard { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-5px) rotate(-15deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 2; 
        }
        .card-stack.discard .stack-card.policy-on-discard-top { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-8px) rotate(12deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 3; 
        }
        .card-stack.discard .stack-card.policy-on-discard-2 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-11px) rotate(-8deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 4; 
        }
        .card-stack.discard .stack-card.policy-on-discard-3 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-14px) rotate(18deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 5; 
        }
        .card-stack.discard .stack-card.policy-on-discard-4 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-17px) rotate(-22deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 6; 
        }
        .card-stack.discard .stack-card.policy-on-discard-5 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-20px) rotate(6deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 7; 
        }
        .card-stack.discard .stack-card.policy-on-discard-6 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-23px) rotate(-14deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 8; 
        }
        .card-stack.discard .stack-card.policy-on-discard-7 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-26px) rotate(20deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 9; 
        }
        .card-stack.discard .stack-card.policy-on-discard-8 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-29px) rotate(-10deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 10; 
        }
        .card-stack.discard .stack-card.policy-on-discard-9 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-32px) rotate(16deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 11; 
        }
        .card-stack.discard .stack-card.policy-on-discard-10 { 
            background-image: url('../images/policy-back.png'); 
            transform: translateY(-35px) rotate(-25deg) scale(1.0) !important; 
            transform-origin: 50% 50%; 
            z-index: 12; 
        }
        .card-stack.deck .stack-card:nth-child(1) { transform: translate(0, 0) rotate(-2deg); }
        .card-stack.deck .stack-card:nth-child(2) { transform: translate(4px, -4px) rotate(1deg); }
        .card-stack.deck .stack-card:nth-child(3) { transform: translate(8px, -8px) rotate(-0.5deg); }
        .card-stack.discard .stack-card:nth-child(1) { transform: translate(0, 8px) rotate(2deg) scale(1.3); }
        .card-stack.discard .stack-card:nth-child(2) { transform: translate(2px, 12px) rotate(-1deg) scale(1.3); }
        .card-stack.discard .stack-card:nth-child(3) { transform: translate(-1px, 16px) rotate(3deg) scale(1.3); }
        /* Single, larger discard card */
        .card-stack.discard .stack-card { transform: translateY(8px) scale(1.3); transform-origin: 50% 100%; }

        /* Responsive sizing for small screens */
        @media (max-width: 640px) {
            .table-spread { padding-top: 10px; margin-top: 14px; }
            .cards-area { margin: 16px 0 0; }
            .cards-row { gap: 60px; }
            .table-spread .table-card { width: var(--play-card-w, 56px); height: var(--play-card-h, 82px); margin: 0 -18px; }
            .card-stack { width: calc(var(--play-card-w, 56px) + 8px); height: calc(var(--play-card-h, 82px) + 8px); }
            .stack-card { width: var(--play-card-w, 56px); height: var(--play-card-h, 82px); }
            .envelope-image { width: calc(var(--play-card-w, 56px) + 8px); height: calc(var(--play-card-h, 82px) + 8px); }
            .card-stack.discard .stack-card.policy-on-discard { transform: translateY(-5px) rotate(-15deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-top { transform: translateY(-8px) rotate(12deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-2 { transform: translateY(-11px) rotate(-8deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-3 { transform: translateY(-14px) rotate(18deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-4 { transform: translateY(-17px) rotate(-22deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-5 { transform: translateY(-20px) rotate(6deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-6 { transform: translateY(-23px) rotate(-14deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-7 { transform: translateY(-26px) rotate(20deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-8 { transform: translateY(-29px) rotate(-10deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-9 { transform: translateY(-32px) rotate(16deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-10 { transform: translateY(-35px) rotate(-25deg) scale(1.0) !important; }
        }
        @media (max-width: 360px) {
            .table-spread { padding-top: 8px; margin-top: 12px; }
            .cards-area { margin: 14px 0 0; }
            .cards-row { gap: 48px; }
            .table-spread .table-card { width: var(--play-card-w, 50px); height: var(--play-card-h, 74px); margin: 0 -20px; }
            .card-stack { width: calc(var(--play-card-w, 50px) + 8px); height: calc(var(--play-card-h, 74px) + 8px); }
            .stack-card { width: var(--play-card-w, 50px); height: var(--play-card-h, 74px); }
            .envelope-image { width: calc(var(--play-card-w, 50px) + 8px); height: calc(var(--play-card-h, 74px) + 8px); }
            .card-stack.discard .stack-card.policy-on-discard { transform: translateY(-10px) rotate(-15deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-top { transform: translateY(-15px) rotate(12deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-2 { transform: translateY(-20px) rotate(-8deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-3 { transform: translateY(-25px) rotate(18deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-4 { transform: translateY(-30px) rotate(-22deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-5 { transform: translateY(-35px) rotate(6deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-6 { transform: translateY(-40px) rotate(-14deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-7 { transform: translateY(-45px) rotate(20deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-8 { transform: translateY(-50px) rotate(-10deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-9 { transform: translateY(-55px) rotate(16deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-10 { transform: translateY(-60px) rotate(-25deg) scale(1.0) !important; }
        }
        /* Larger screens: increase discard pile size */
        @media (min-width: 768px) {
            .cards-area { margin: 24px 0 0; }
            .cards-row { gap: 100px; }
            .envelope-image { width: calc(var(--play-card-w, 64px) + 8px); height: calc(var(--play-card-h, 92px) + 8px); }
            .card-stack.discard .stack-card { transform: translateY(16px) scale(1.6); transform-origin: 50% 100%; }
            .card-stack.discard .stack-card:nth-child(1) { transform: translate(0, 16px) rotate(2deg) scale(1.6); }
            .card-stack.discard .stack-card:nth-child(2) { transform: translate(3px, 20px) rotate(-1deg) scale(1.6); }
            .card-stack.discard .stack-card:nth-child(3) { transform: translate(-2px, 24px) rotate(3deg) scale(1.6); }
            .role-envelope { transform: translate(16px, 16px) scale(1.6) rotate(-2deg); }
            .role-envelope:hover { transform: translate(16px, 16px) scale(1.68) rotate(-2deg); }
            .role-envelope:active { transform: translate(16px, 16px) scale(1.568) rotate(-2deg); }
            .card-stack.discard .stack-card.policy-on-discard { transform: translateY(-16px) rotate(-15deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-top { transform: translateY(-24px) rotate(12deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-2 { transform: translateY(-32px) rotate(-8deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-3 { transform: translateY(-40px) rotate(18deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-4 { transform: translateY(-48px) rotate(-22deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-5 { transform: translateY(-56px) rotate(6deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-6 { transform: translateY(-64px) rotate(-14deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-7 { transform: translateY(-72px) rotate(20deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-8 { transform: translateY(-80px) rotate(-10deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-9 { transform: translateY(-88px) rotate(16deg) scale(1.0) !important; }
            .card-stack.discard .stack-card.policy-on-discard-10 { transform: translateY(-96px) rotate(-25deg) scale(1.0) !important; }
        }
        /* Preloader overlay */
        .preloader-overlay { position: fixed; inset: 0; z-index: 10000; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.5); backdrop-filter: blur(6px); }
        .preloader-overlay .loader { display: flex; flex-direction: column; align-items: center; gap: 12px; }
        .preloader-overlay .spinner { width: 56px; height: 56px; border: 6px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite; }
        .preloader-overlay .loader-text { color: #fff; font-weight: 800; letter-spacing: 0.03em; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
    <link rel="manifest" href="../manifest.json">
    <meta name="theme-color" content="#101820">
</head>
<body>
    <div class="play-wrapper">
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <div class="logo" onclick="window.location.href='../index.html'">
                        <span class="logo-icon">ðŸŽ­</span>
                        <div class="logo-text">
                            <h1>Secret Hitler</h1>
                            <p class="subtitle">Mobile Edition</p>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <main class="play-main">
            <div class="board-shell">
                <div id="role-banner" class="floating-role">
                    <div class="role-bar"><span id="role-badge" class="role-tag"></span></div>
                </div>
                <div id="players-strip" class="players-strip"></div>
                <div class="board-area">
                    <div class="board-frame">
                        <div class="tracks">
                            <section class="track liberal">
                                <div class="track-title">Liberal Policies</div>
                                <div class="slots" id="liberal-slots"></div>
                            </section>
                            <div id="status" class="status-banner">Loadingâ€¦</div>
                            <section class="track fascist">
                                <div class="track-title">Fascist Policies</div>
                                <div class="slots" id="fascist-slots"></div>
                            </section>
                        </div>
                        <div class="policy-summary">
                            <div class="policy-card-wrap">
                                <div class="policy-card-title">Liberal Policies</div>
                                <div class="policy-chip liberal"><span class="policy-label">Liberal</span> <span class="count" id="liberal-count">0/5</span></div>
                            </div>
                            <div class="policy-card-wrap">
                                <div class="policy-card-title">Fascist Policies</div>
                                <div class="policy-chip fascist"><span class="policy-label">Fascist</span> <span class="count" id="fascist-count">0/6</span></div>
                            </div>
                        </div>
                        <div class="tracker-row">
                            <div class="tracker-label">Failed Elections</div>
                            <div class="tracker" id="election-tracker"></div>
                        </div>
                    </div>
                    <!-- Cards area - centered under play field -->
                    <div class="cards-area" aria-hidden="false">
                        <div class="cards-row">
                            <div class="role-envelope" id="role-envelope" title="Click to view your secret role">
                                <img src="../images/my-role.png" alt="My Secret Role" class="envelope-image">
                            </div>
                            <div class="table-spread">
                                <!-- Table cards will be dynamically generated here -->
                            </div>
                            <div class="card-stack discard" aria-label="Discard Pile">
                                <div class="stack-card is-discard"></div>
                                <!-- Policy cards will be dynamically generated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        

        <footer class="floating-footer">
            <div class="actions-bar">
                <div class="actions-left">
                    <button id="menu-btn" class="btn">â˜° Menu</button>
                    <button id="help-btn" class="btn">ðŸ“– Rules</button>
                </div>
                <div class="actions-center">
                    <button id="view-cards-btn" class="btn btn-primary" style="display: none;">ðŸƒ View Cards</button>
                    <button id="repair-game-main-btn" class="btn" style="display: none;" title="Repair game state issues">ðŸ”§ Repair</button>
                </div>
                <div class="actions-right">
                    <button id="history-btn" class="btn">ðŸ•’ History</button>
                    <button id="order-btn" class="btn">ðŸ‘¥ Order</button>
                </div>
            </div>
        </footer>
        <div id="order-modal" class="modal-overlay">
            <div class="modal-card">
                <div class="modal-header">
                    <div class="modal-title">Player Order</div>
                    <button id="order-close" class="modal-close" aria-label="Close">Ã—</button>
                </div>
                <div id="order-body" class="modal-body"></div>
            </div>
        </div>
        <div id="history-modal" class="modal-overlay">
            <div class="modal-card">
                <div class="modal-header">
                    <div class="modal-title">History</div>
                    <button id="history-close" class="modal-close" aria-label="Close">Ã—</button>
                </div>
                <div id="history-body" class="modal-body"></div>
            </div>
        </div>
        <div id="nomination-modal" class="modal-overlay">
            <div class="modal-card">
                <div class="modal-header">
                    <div class="modal-title">Choose Chancellor</div>
                    <button id="nomination-close" class="modal-close" aria-label="Close">Ã—</button>
                </div>
                <div id="nomination-body" class="modal-body"></div>
            </div>
        </div>
        <div id="rules-modal" class="modal-overlay rules-modal">
            <div class="modal-card">
                <div class="modal-header">
                    <div>
                        <div class="modal-title">Game Rules</div>
                        <div class="modal-subtitle">Quick reference for in-game use</div>
                    </div>
                    <button id="rules-close" class="modal-close" aria-label="Close">Ã—</button>
                </div>
                <div id="rules-body" class="modal-body">
                    <div class="rules-quicknav">
                        <button class="rule-nav-btn active" data-section="ov" aria-label="Overview">
                            <span class="nav-icon" aria-hidden="true">ðŸŽ¯</span>
                            <span class="nav-text">Overview</span>
                        </button>
                        <button class="rule-nav-btn" data-section="setup" aria-label="Setup">
                            <span class="nav-icon" aria-hidden="true">âš™ï¸</span>
                            <span class="nav-text">Setup</span>
                        </button>
                        <button class="rule-nav-btn" data-section="roles" aria-label="Roles">
                            <span class="nav-icon" aria-hidden="true">ðŸŽ­</span>
                            <span class="nav-text">Roles</span>
                        </button>
                        <button class="rule-nav-btn" data-section="flow" aria-label="Turn Order">
                            <span class="nav-icon" aria-hidden="true">ðŸ”„</span>
                            <span class="nav-text">Turn Order</span>
                        </button>
                        <button class="rule-nav-btn" data-section="powers" aria-label="Powers">
                            <span class="nav-icon" aria-hidden="true">âš¡</span>
                            <span class="nav-text">Powers</span>
                        </button>
                        <button class="rule-nav-btn" data-section="legislative" aria-label="Legislative">
                            <span class="nav-icon" aria-hidden="true">ðŸ“œ</span>
                            <span class="nav-text">Legislative</span>
                        </button>
                        <button class="rule-nav-btn" data-section="win" aria-label="Victory">
                            <span class="nav-icon" aria-hidden="true">ðŸ†</span>
                            <span class="nav-text">Victory</span>
                        </button>
                        <button class="rule-nav-btn" data-section="ref" aria-label="Reference">
                            <span class="nav-icon" aria-hidden="true">ðŸ“‘</span>
                            <span class="nav-text">Reference</span>
                        </button>
                    </div>
                    <div class="rules-content">
                        <section id="ov-section" class="rule-section active">
                            <div class="section-header">
                                <div class="section-icon">ðŸŽ¯</div>
                                <h3>Game Overview</h3>
                            </div>
                            <div class="overview-grid">
                                <div class="overview-card">
                                    <div class="card-icon">ðŸ‘¥</div>
                                    <h4>Teams</h4>
                                    <p>Liberals vs Fascists</p>
                                    <span class="card-detail">Hidden roles</span>
                                </div>
                                <div class="overview-card">
                                    <div class="card-icon">ðŸŽ´</div>
                                    <h4>Policies</h4>
                                    <p>6 Fascist / 5 Liberal to win</p>
                                    <span class="card-detail">See Victory</span>
                                </div>
                                <div class="overview-card">
                                    <div class="card-icon">ðŸ”¨</div>
                                    <h4>Offices</h4>
                                    <p>President & Chancellor</p>
                                    <span class="card-detail">Rotate order</span>
                                </div>
                            </div>
                        </section>

                        <section id="setup-section" class="rule-section">
                            <div class="section-header">
                                <div class="section-icon">âš™ï¸</div>
                                <h3>Setup</h3>
                            </div>
                            <div class="setup-steps">
                                <div class="setup-step">
                                    <div class="step-number">1</div>
                                    <div class="step-content">
                                        <h4>Choose Roles by Player Count</h4>
                                        <div class="role-distribution-visual">
                                            <div class="role-example"><div class="role-badge liberal"><span class="role-icon">ðŸŸ¦</span>Liberals</div><span class="role-count">5 players: 3L, 1F, 1H</span></div>
                                            <div class="role-example"><div class="role-badge liberal"><span class="role-icon">ðŸŸ¦</span>Liberals</div><span class="role-count">6 players: 4L, 1F, 1H</span></div>
                                            <div class="role-example"><div class="role-badge liberal"><span class="role-icon">ðŸŸ¦</span>Liberals</div><span class="role-count">7 players: 4L, 2F, 1H</span></div>
                                            <div class="role-example"><div class="role-badge liberal"><span class="role-icon">ðŸŸ¦</span>Liberals</div><span class="role-count">8 players: 5L, 2F, 1H</span></div>
                                            <div class="role-example"><div class="role-badge liberal"><span class="role-icon">ðŸŸ¦</span>Liberals</div><span class="role-count">9 players: 5L, 3F, 1H</span></div>
                                            <div class="role-example"><div class="role-badge liberal"><span class="role-icon">ðŸŸ¦</span>Liberals</div><span class="role-count">10 players: 6L, 3F, 1H</span></div>
                                        </div>
                                    </div>
                                </div>
                                <div class="setup-step">
                                    <div class="step-number">2</div>
                                    <div class="step-content">
                                        <h4>Prepare Decks</h4>
                                        <p>Policy deck: 11 Fascist, 6 Liberal. Shuffle and place face down; discards face down. When fewer than 3 remain, reshuffle discards into a new deck.</p>
                                    </div>
                                </div>
                                <div class="setup-step">
                                    <div class="step-number">3</div>
                                    <div class="step-content">
                                        <h4>Seat & Select First President</h4>
                                        <p>Sit randomly around the table; assign player order clockwise. Randomly choose the first Presidential candidate.</p>
                                    </div>
                                </div>
                                <div class="setup-step">
                                    <div class="step-number">4</div>
                                    <div class="step-content">
                                        <h4>Secret Information (Night Phase)</h4>
                                        <ul>
                                            <li>5â€“6 players: Hitler learns the identity of the single Fascist. The Fascist does not learn Hitler.</li>
                                            <li>7â€“10 players: Fascists learn one another. Hitler does not know the Fascists and the Fascists do not know Hitler.</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="roles-section" class="rule-section">
                            <div class="section-header">
                                <div class="section-icon">ðŸŽ­</div>
                                <h3>Roles & Knowledge</h3>
                            </div>
                            <div class="roles-grid">
                                <div class="role-card liberal"><div class="role-header"><div class="role-icon">ðŸŸ¦</div><h4>Liberal</h4></div><div class="role-info"><p class="role-description">Work together to enact 5 Liberal policies or execute Hitler.</p><div class="role-abilities"><h5>You know:</h5><ul><li>Only that you are Liberal.</li></ul></div></div></div>
                                <div class="role-card fascist"><div class="role-header"><div class="role-icon">ðŸŸ¥</div><h4>Fascist</h4></div><div class="role-info"><p class="role-description">Coordinate covertly to enact 6 Fascist policies or elect Hitler after 3 Fascist policies.</p><div class="role-abilities"><h5>You know:</h5><ul><li>Other Fascists (7â€“10 players).</li><li>Hitler's identity is unknown to you.</li></ul></div></div></div>
                                <div class="role-card hitler"><div class="role-header"><div class="role-icon">ðŸ‘‘</div><h4>Hitler</h4></div><div class="role-info"><p class="role-description">Deceive the Liberals and avoid detection.</p><div class="role-abilities"><h5>You know:</h5><ul><li>At 5â€“6 players: the single Fascist.</li><li>At 7â€“10 players: no one.</li></ul></div></div></div>
                            </div>
                        </section>

                        <section id="flow-section" class="rule-section">
                            <div class="section-header">
                                <div class="section-icon">ðŸ”„</div>
                                <h3>Turn Order</h3>
                            </div>
                            <div class="gameplay-flow">
                                <div class="flow-step">
                                    <div class="flow-icon">ðŸ‘‘</div>
                                    <h4>Nominate</h4>
                                    <p>President nominates a Chancellor.</p>
                                </div>
                                <div class="flow-arrow">â†’</div>
                                <div class="flow-step">
                                    <div class="flow-icon">ðŸ—³ï¸</div>
                                    <h4>Vote</h4>
                                    <p>All players vote Ja/Nein. Majority passes.</p>
                                </div>
                                <div class="flow-arrow">â†’</div>
                                <div class="flow-step">
                                    <div class="flow-icon">ðŸŽ´</div>
                                    <h4>Legislate</h4>
                                    <p>Pres draws 3, discards 1; Chanc enacts 1 of 2.</p>
                                </div>
                                <div class="flow-arrow">â†’</div>
                                <div class="flow-step">
                                    <div class="flow-icon">âš¡</div>
                                    <h4>Powers</h4>
                                    <p>Some Fascist policies trigger powers.</p>
                                </div>
                            </div>
                        </section>

                        <section id="powers-section" class="rule-section">
                            <div class="section-header">
                                <div class="section-icon">âš¡</div>
                                <h3>Executive Powers</h3>
                            </div>
                            <div class="powers-grid">
                                <div class="power-card">
                                    <div class="power-header">
                                        <span class="power-number">3</span>
                                        <h4>Policy Peek</h4>
                                    </div>
                                    <p>President looks at top 3 policy cards.</p>
                                </div>
                                <div class="power-card">
                                    <div class="power-header">
                                        <span class="power-number">4</span>
                                        <h4>Investigation</h4>
                                    </div>
                                    <p>President checks a player's loyalty.</p>
                                </div>
                                <div class="power-card">
                                    <div class="power-header">
                                        <span class="power-number">5</span>
                                        <h4>Special Election</h4>
                                    </div>
                                    <p>President picks the next Presidential candidate.</p>
                                </div>
                            </div>
                            <div class="power-notes">
                                <div class="notes-header"><div class="notes-icon">ðŸ“</div><h4>Power Timing by Player Count</h4></div>
                                <ul>
                                    <li><strong>5â€“6 players</strong>: 3 Policy Peek, 4 Execution, 5 Execution.</li>
                                    <li><strong>7â€“8 players</strong>: 2 Investigation, 3 Special Election, 4 Execution, 5 Execution.</li>
                                    <li><strong>9â€“10 players</strong>: 1 Investigation, 2 Investigation, 3 Special Election, 4 Execution, 5 Execution.</li>
                                </ul>
                            </div>
                        </section>

                        <section id="legislative-section" class="rule-section">
                            <div class="section-header">
                                <div class="section-icon">ðŸ“œ</div>
                                <h3>Legislative Session & Veto</h3>
                            </div>
                            <div class="powers-intro"><div class="powers-header"><div class="powers-icon">ðŸŽ´</div><p>President draws 3 policies, discards 1 face down, passes 2 to Chancellor. Chancellor discards 1 and enacts 1 face down.</p></div></div>
                            <ul>
                                <li>All discards and enacted cards are secret (face down).</li>
                                <li>If fewer than 3 remain in deck, reshuffle the discard pile to form a new deck.</li>
                                <li><strong>Veto Power</strong> unlocks after 5 Fascist policies are enacted. Chancellor may propose a veto; if the President agrees, discard both cards and advance the Election Tracker by 1 (no policy is enacted).</li>
                                <li>Top-deck policies (after 3 failed elections) do not trigger Executive Powers.</li>
                            </ul>
                            <div class="powers-intro"><div class="powers-header"><div class="powers-icon">ðŸš«</div><p><strong>Eligibility & Term Limits:</strong> The last elected President and last elected Chancellor are ineligible to be nominated as Chancellor in the next government. No player can be Chancellor in two consecutive governments.</p></div></div>
                        </section>

                        <section id="win-section" class="rule-section">
                            <div class="section-header">
                                <div class="section-icon">ðŸ†</div>
                                <h3>Victory Conditions</h3>
                            </div>
                            <div class="winning-conditions">
                                <div class="win-condition liberal-win">
                                    <div class="win-header">
                                        <div class="win-icon">ðŸŸ¦</div>
                                        <h4>Liberals</h4>
                                    </div>
                                    <div class="win-ways">
                                        <div class="win-way"><span class="way-icon">âœ…</span><span class="way-text">Pass 5 Liberal policies</span></div>
                                        <div class="win-way"><span class="way-icon">ðŸŽ¯</span><span class="way-text">Execute Hitler</span></div>
                                    </div>
                                </div>
                                <div class="win-condition fascist-win">
                                    <div class="win-header">
                                        <div class="win-icon">ðŸŸ¥</div>
                                        <h4>Fascists</h4>
                                    </div>
                                    <div class="win-ways">
                                        <div class="win-way"><span class="way-icon">âœ…</span><span class="way-text">Pass 6 Fascist policies</span></div>
                                        <div class="win-way"><span class="way-icon">ðŸ‘‘</span><span class="way-text">Elect Hitler Chancellor after 3 Fascist policies</span></div>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <section id="ref-section" class="rule-section">
                            <div class="section-header">
                                <div class="section-icon">ðŸ“‘</div>
                                <h3>Reference</h3>
                            </div>
                            <div class="pdf-actions">
                                <a class="btn btn-outline" href="../Secret_Hitler_Rules.pdf" target="_blank" rel="noopener">Open Official Rules (PDF)</a>
                                <a class="btn" href="../Secret_Hitler_Rules.pdf" download>Download PDF</a>
                            </div>
                            <p class="mt-3" style="text-align:center;color:var(--dark-beige);">This in-game summary covers all core rules. Use the PDF for full artwork and extended clarifications.</p>
                        </section>
                    </div>
                    <div class="rules-bottomnav" aria-hidden="false">
                        <div class="rules-bottomnav-inner">
                            <button id="rules-prev" class="btn" aria-label="Previous section">â† Prev</button>
                            <div id="rules-indicator" class="indicator">1/7</div>
                            <button id="rules-next" class="btn btn-primary" aria-label="Next section">Next â†’</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div id="menu-modal" class="modal-overlay">
                <div class="modal-card">
                    <div class="modal-header">
                        <div class="modal-title">Menu</div>
                        <button id="menu-close" class="modal-close" aria-label="Close">Ã—</button>
                    </div>
                    <div id="menu-body" class="modal-body"></div>
                </div>
        </div>
        <!-- Role overlay modal -->
        <div id="role-overlay" class="modal-overlay">
            <div class="modal-card">
                <div class="modal-header">
                    <div class="modal-title">Your Secret Role</div>
                    <button id="role-close" class="modal-close" aria-label="Close">Ã—</button>
                </div>
                <div class="modal-body">
                    <div class="role-content">
                        <div class="role-display">
                            <div class="role-label" id="role-text">Hidden</div>
                        </div>
                                            <div class="role-actions">
                        <div class="role-actions-main">
                            <button id="membership-btn" class="btn btn-secondary">ðŸ›ï¸ View Membership</button>
                            <button id="role-btn" class="btn btn-primary">ðŸ‘ï¸ View Role</button>
                            <button id="compatriots-btn" class="btn btn-secondary" style="display: none;">ðŸ‘¥ View Comrades</button>
                        </div>
                        <button id="role-done-btn" class="btn">âœ… Close</button>
                    </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="preloader-overlay" class="preloader-overlay" aria-hidden="false">
        <div class="loader">
            <div class="spinner"></div>
            <div id="preloader-text" class="loader-text">Loading boardâ€¦</div>
        </div>
    </div>

    <script type="module">
        import { app } from '../js/firebase.js';
        import { onHistory, logPublic } from '../js/db.js?v=2';
        import { getFirestore, doc, getDoc, onSnapshot, collection, query, orderBy, updateDoc, serverTimestamp, runTransaction, increment } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";

        const db = getFirestore(app);
        let latestGame = null;
        let latestPlayers = [];
        let historyUnsub = null;
        let historyItems = [];
        let localPaused = false;
        let lastStatusMessage = null;
        const HEARTBEAT_INTERVAL_MS = 25 * 1000; // 25s
        let heartbeatTimer = null;
        let afkUnsub = null; let lastAfkSeenOrder = 0;
        let isNominating = false; // Flag to prevent modal re-opening during nomination

        function getGameId() {
            const p = new URLSearchParams(window.location.search);
            return p.get('game') || localStorage.getItem('sh_currentGameId') || '';
        }
        function hidePreloader() {
            const o = document.getElementById('preloader-overlay');
            if (o) o.style.display = 'none';
        }
        function setPreloader(text) {
            const t = document.getElementById('preloader-text');
            if (t && text) t.textContent = text;
        }

        function getYouPlayerId(gameId) {
            try { return sessionStorage.getItem(`sh_playerId_${gameId}`) || null; } catch (_) { return null; }
        }

        async function ensureAuth() {
            const auth = getAuth(app);
            if (!auth.currentUser) {
                try { await signInAnonymously(auth); } catch (_) {}
            }
            return auth.currentUser;
        }

        function computeYouId(gameId) {
            const fromSession = getYouPlayerId(gameId);
            if (fromSession) return fromSession;
            const auth = getAuth(app);
            const uid = auth && auth.currentUser ? auth.currentUser.uid : null;
            if (!uid) return null;
            const m = (latestPlayers || []).find(p => p && p.uid === uid);
            return m ? m.id : null;
        }

        function heartbeatOnce(gameId) {
            try {
                const youId = computeYouId(gameId);
                if (!youId) return;
                const playerRef = doc(db, 'games', gameId, 'players', youId);
                updateDoc(playerRef, { lastSeen: serverTimestamp() }).catch(() => {});
            } catch (_) { /* no-op */ }
        }

        function renderSlots(el, count) {
            el.innerHTML = '';
            for (let i = 0; i < count; i++) {
                const s = document.createElement('div');
                s.className = 'slot';
                el.appendChild(s);
            }
        }

        function renderTracker(el) {
            el.innerHTML = '';
            for (let i = 0; i < 3; i++) {
                const b = document.createElement('div');
                b.className = 'square';
                b.textContent = String(i + 1);
                b.dataset.index = String(i);
                el.appendChild(b);
            }
        }

        // Render policy cards into the first N slots of a track
        function renderPoliciesToSlots(containerEl, filledCount, type) {
            if (!containerEl) return;
            const total = containerEl.children.length;
            for (let i = 0; i < total; i++) {
                const slot = containerEl.children[i];
                if (!slot) continue;
                // Ensure only one policy card element inside slot when filled
                const existing = slot.querySelector('.policy-card');
                if (i < filledCount) {
                    if (!existing) {
                        const card = document.createElement('div');
                        card.className = 'policy-card ' + (type === 'liberal' ? 'liberal' : 'fascist');
                        // Use image backgrounds for authenticity
                        card.style.backgroundImage = type === 'liberal' ? "url('../images/liberal.png')" : "url('../images/facist.png')";
                        // Let CSS handle the transform for responsive sizing
                        card.style.zIndex = '3';
                        card.style.zIndex = '3';
                        slot.appendChild(card);
                        slot.classList.add('filled');
                    } else {
                        existing.style.backgroundImage = type === 'liberal' ? "url('../images/liberal.png')" : "url('../images/facist.png')";
                        // Let CSS handle the transform for responsive sizing
                        existing.style.zIndex = '3';
                        slot.classList.add('filled');
                    }
                } else {
                    if (existing) existing.remove();
                    slot.classList.remove('filled');
                }
            }
            
            /* ========================================
               CSS OVERRIDE BACKUP - JAVASCRIPT FALLBACK
               ========================================
               
               This function ensures policy cards display correctly even if there are
               conflicting inline styles or CSS loading issues.
               
               What it does:
               1. Removes any inline 'scale' transforms that might override CSS
               2. Ensures proper positioning (absolute, centered)
               3. Runs after a 10ms delay to catch any late-applied styles
               
               This is a safety net to prevent policy cards from being enlarged
               or positioned incorrectly on narrow devices.
            */
            setTimeout(() => {
                const cards = containerEl.querySelectorAll('.policy-card');
                cards.forEach(card => {
                    // Remove any inline transform styles that might override CSS
                    if (card.style.transform && card.style.transform.includes('scale')) {
                        card.style.removeProperty('transform');
                    }
                    // Ensure proper positioning
                    card.style.position = 'absolute';
                    card.style.top = '50%';
                    card.style.left = '50%';
                });
            }, 10);
        }

        function updateFromGame(game) {
            if (!game) return;
            const lib = Number(game.liberalPolicies || 0);
            const fas = Number(game.fascistPolicies || 0);
            const et = Number(game.electionTracker || 0);

            const libEl = document.getElementById('liberal-count');
            const fasEl = document.getElementById('fascist-count');
            if (libEl) libEl.textContent = `${lib}/5`;
            if (fasEl) fasEl.textContent = `${fas}/6`;

            // Place enacted policy cards into the board tracks
            const liberalSlotsEl = document.getElementById('liberal-slots');
            const fascistSlotsEl = document.getElementById('fascist-slots');
            if (liberalSlotsEl) renderPoliciesToSlots(liberalSlotsEl, Math.min(lib, 5), 'liberal');
            if (fascistSlotsEl) renderPoliciesToSlots(fascistSlotsEl, Math.min(fas, 6), 'fascist');

            const squares = document.querySelectorAll('#election-tracker .square');
            squares.forEach((sq, idx) => {
                if (et > idx) sq.classList.add('active');
                else sq.classList.remove('active');
            });
        }

        function updateRoleBanner(game, gameId) {
            const banner = document.getElementById('role-banner');
            const badge = document.getElementById('role-badge');
            const youId = computeYouId(gameId);
            if (!banner || !badge || !game || !youId) {
                if (banner) banner.style.display = 'none';
                document.body.classList.remove('role-banner-visible');
                return;
            }
            const isPres = game.currentPresidentPlayerId && (game.currentPresidentPlayerId === youId);
            const isChanc = game.currentChancellorPlayerId && (game.currentChancellorPlayerId === youId);
            if (!isPres && !isChanc) { banner.style.display = 'none'; document.body.classList.remove('role-banner-visible'); return; }
            let text = '';
            let cls = 'role-tag';
            if (isPres && isChanc) { text = 'ðŸ‘‘ðŸ”¨ President & Chancellor'; }
            else if (isPres) { text = 'ðŸ‘‘ President'; }
            else if (isChanc) { text = 'ðŸ”¨ Chancellor'; }
            badge.className = cls;
            badge.textContent = text;
            banner.style.display = 'block';
            document.body.classList.add('role-banner-visible');
        }
        
        function updateRoleEnvelope(game, gameId) {
            const envelope = document.getElementById('role-envelope');
            if (!envelope) return;
            
            // Always show the role envelope at 100% opacity
            envelope.style.display = 'block';
            envelope.style.opacity = '1';
            envelope.style.filter = 'none';
            
            if (!game || !gameId) {
                envelope.title = 'Role envelope (game loading...)';
                return;
            }
            
            const youId = computeYouId(gameId);
            if (!youId) {
                envelope.title = 'Role envelope (waiting for player ID...)';
                return;
            }
            
            const youPlayer = (latestPlayers || []).find(p => p && p.id === youId);
            if (!youPlayer || !youPlayer.role) {
                envelope.title = 'Role envelope (waiting for role assignment...)';
                return;
            }
            
            // Player has a role - envelope is fully functional
            if (game.state === 'playing' && youPlayer.role) {
                envelope.title = 'Click to view your secret role';
            } else {
                envelope.title = `Role envelope (game state: ${game.state || 'unknown'})`;
            }
        }

        function setStatus(gameId, message, delayMs = 0) {
            try {
                const el = document.getElementById('status');
                if (!el) return;
                
                if (delayMs > 0) {
                    // Clear any existing delayed status
                    if (window.delayedStatusTimer) {
                        clearTimeout(window.delayedStatusTimer);
                    }
                    
                    // Set delayed status
                    window.delayedStatusTimer = setTimeout(() => {
                        el.textContent = message || '';
                        // retrigger small animation
                        el.classList.remove('status-updated');
                        void el.offsetWidth;
                        el.classList.add('status-updated');
                        if (gameId && message && message !== lastStatusMessage) {
                            lastStatusMessage = message;
                            try { logPublic(gameId, message, { type: 'status' }); } catch (_) {}
                        }
                    }, delayMs);
                } else {
                    // Immediate status update
                    el.textContent = message || '';
                    // retrigger small animation
                    el.classList.remove('status-updated');
                    void el.offsetWidth;
                    el.classList.add('status-updated');
                    if (gameId && message && message !== lastStatusMessage) {
                        lastStatusMessage = message;
                        try { logPublic(gameId, message, { type: 'status' }); } catch (_) {}
                    }
                }
            } catch (_) { /* no-op */ }
        }

        function renderPlayers(el, players) {
            el.innerHTML = '';
            (players || []).forEach(p => {
                const chip = document.createElement('div');
                chip.className = 'player-chip';
                const icons = [];
                if (p.isPresident) icons.push('ðŸ‘‘');
                if (p.isChancellor) icons.push('ðŸ”¨');
                const prefix = icons.length ? icons.join('') + ' ' : '';
                chip.textContent = prefix + (p.name || 'Player');
                if (p.isPresident) chip.classList.add('is-president');
                if (p.isChancellor) chip.classList.add('is-chancellor');
                el.appendChild(chip);
            });
        }

        function eligibleChancellorIds(game, players) {
            if (!game || !players) return [];
            const presId = game.currentPresidentPlayerId || null;
            const lastPres = game.termLimitLastPresidentId || null;
            const lastChanc = game.termLimitLastChancellorId || null;
            return players
                .filter(p => p && p.id && p.alive !== false)
                .filter(p => p.id !== presId)
                .filter(p => p.id !== lastPres && p.id !== lastChanc)
                .map(p => p.id);
        }

        function computePhase(game) {
            if (!game || game.state !== 'playing') return 'idle';
            const voteResolution = (game.voteResolution || null);
            if (!voteResolution) {
                const nomineeId = game.nominatedChancellorPlayerId || null;
                return nomineeId ? 'voting' : 'nomination';
            }
            let passed = false;
            if (typeof voteResolution === 'string') {
                passed = (voteResolution === 'ja');
            } else if (typeof voteResolution === 'object') {
                passed = !!voteResolution.passed;
            }
            if (passed) {
                const policyPhase = (game.policyPhase || null);
                if (policyPhase === 'chancellor_choice') return 'chancellor_choice';
                if (policyPhase === 'completed') return 'completed';
                return policyPhase || 'president_draw';
            }
            return 'post_vote';
        }

        function renderPhaseNomination(gameId, youId, game, players, actionsCenter) {
            const presId = game.currentPresidentPlayerId || null;
            const pres = players.find(p => p && p.id === presId) || null;
            if (youId && youId === presId) {
                if (pres) { setStatus(gameId, `${pres.name || 'President'}: Nominate a Chancellor`); }
                const chooseBtn = document.createElement('button');
                chooseBtn.id = 'open-nominate-btn';
                chooseBtn.className = 'btn btn-primary';
                chooseBtn.textContent = 'Choose Chancellor';
                actionsCenter.appendChild(chooseBtn);
            } else {
                setStatus(gameId, 'Waiting for the President to nominate a Chancellorâ€¦');
            }
            // Clean up any existing overlays when changing phases
            cleanupAllPolicyOverlays();
        }

        function renderPhaseVoting(gameId, youId, game, players, actionsCenter) {
            const nomineeId = game.nominatedChancellorPlayerId || null;
            const chanc = players.find(p => p && p.id === nomineeId) || null;
            if (chanc) setStatus(gameId, `Chancellor nominated: ${chanc.name || 'Player'}`);

            const votes = (game.electionVotes && typeof game.electionVotes === 'object') ? game.electionVotes : {};
            const aliveIds = (players || []).filter(p => p && p.alive !== false).map(p => p.id);
            const totalVoters = aliveIds.length || players.length;
            const numVotes = Object.keys(votes).filter(k => aliveIds.includes(k)).length;
            const youVoted = youId ? !!votes[youId] : false;

            const wrap = document.createElement('div');
            wrap.className = 'vote-pop-wrap';
            wrap.style.margin = '0 auto';

            const voteBtn = document.createElement('button');
            voteBtn.id = 'vote-toggle-btn';
            voteBtn.style.minWidth = '160px';
            voteBtn.style.minHeight = '44px';
            voteBtn.style.fontSize = '1.05rem';
            const votedValue = youVoted ? String(votes[youId]).toUpperCase() : 'Vote';
            voteBtn.innerHTML = `<span class="vote-label">${votedValue}</span><span class="vote-count">(${numVotes}/${totalVoters})</span>`;
            const canVote = youId && aliveIds.includes(youId) && !youVoted;
            if (canVote) {
                voteBtn.className = 'btn btn-black btn-attention btn-flashy';
            } else {
                voteBtn.className = 'btn btn-black';
                voteBtn.disabled = true;
                voteBtn.setAttribute('aria-disabled', 'true');
            }
            wrap.appendChild(voteBtn);
            if (canVote) {
                const pop = document.createElement('div');
                pop.id = 'vote-popover';
                pop.className = 'vote-popover';
                const row = document.createElement('div');
                row.style.display = 'flex';
                row.style.gap = '8px';
                const yesBtn = document.createElement('button');
                yesBtn.className = 'btn btn-primary';
                yesBtn.setAttribute('data-vote', 'ja');
                yesBtn.textContent = 'Ja';
                const noBtn = document.createElement('button');
                noBtn.className = 'btn';
                noBtn.setAttribute('data-vote', 'nein');
                noBtn.textContent = 'Nein';
                row.appendChild(yesBtn);
                row.appendChild(noBtn);
                pop.appendChild(row);
                wrap.appendChild(pop);
            }
            actionsCenter.appendChild(wrap);
            
            // Clean up any existing overlays when changing phases
            cleanupAllPolicyOverlays();
        }

        function renderPhasePresidentDraw(gameId, youId, game, players, actionsCenter) {
            const presId = game.currentPresidentPlayerId || null;
            const pres = players.find(p => p && p.id === presId) || null;
            if (youId && youId === presId) {
                setStatus(gameId, `${pres ? (pres.name || 'President') : 'President'}: Draw 3 policy cards`);
                try { initSpreadPresidentDrawUI(gameId); } catch (_) {}
                // Clean up any existing overlays when entering president draw phase
                cleanupAllPolicyOverlays();
            } else {
                setStatus(gameId, 'Waiting for the President to draw policy cardsâ€¦');
                try { teardownSpreadPresidentDrawUI(); } catch (_) {}
                // Clean up any existing overlays for non-presidents
                cleanupAllPolicyOverlays();
            }
        }

        function renderPhaseChancellorChoice(gameId, youId, game, players, actionsCenter) {
            const chancId = game.currentChancellorPlayerId || null;
            const chanc = players.find(p => p && p.id === chancId) || null;
            
            if (youId && youId === chancId) {
                setStatus(gameId, `${chanc ? (chanc.name || 'Chancellor') : 'Chancellor'}: Choose 1 policy to enact`);
                
                // Automatically show the chancellor choice overlay for the chancellor
                showChancellorChoiceOverlay(game);
                
                // Also show the button as a fallback in case they need to reopen it
                const showCardsBtn = document.createElement('button');
                showCardsBtn.id = 'show-chancellor-cards-btn';
                showCardsBtn.className = 'btn btn-secondary';
                showCardsBtn.textContent = 'Reopen Policy Cards';
                showCardsBtn.style.marginTop = '16px';
                showCardsBtn.style.marginBottom = '16px';
                showCardsBtn.style.display = 'block';
                showCardsBtn.style.marginLeft = 'auto';
                showCardsBtn.style.marginRight = 'auto';
                
                showCardsBtn.addEventListener('click', function() {
                    showChancellorChoiceOverlay(game);
                });
                
                actionsCenter.appendChild(showCardsBtn);
                
            } else {
                setStatus(gameId, `Waiting for ${chanc ? (chanc.name || 'Chancellor') : 'Chancellor'} to choose a policyâ€¦`);
                // Clean up any existing overlays for non-chancellors
                cleanupAllPolicyOverlays();
            }
        }

        function renderPhaseCompleted(gameId, youId, game, players, actionsCenter) {
            // Clean up any remaining overlays when entering completed phase
            cleanupAllPolicyOverlays();
            
            const enactedPolicy = game.enactedPolicy;
            if (enactedPolicy) {
                setStatus(gameId, `${enactedPolicy === 'liberal' ? 'Liberal' : 'Fascist'} policy enacted! Policy phase completed.`);
            } else {
                setStatus(gameId, 'Policy phase completed. Waiting for next turn...');
            }
            
            // Add a manual advancement button in case automatic advancement fails
            const manualAdvanceBtn = document.createElement('button');
            manualAdvanceBtn.id = 'manual-advance-btn';
            manualAdvanceBtn.className = 'btn btn-primary';
            manualAdvanceBtn.textContent = 'Advance to Next Turn';
            manualAdvanceBtn.style.marginTop = '16px';
            manualAdvanceBtn.style.marginBottom = '16px';
            manualAdvanceBtn.style.display = 'block';
            manualAdvanceBtn.style.marginLeft = 'auto';
            manualAdvanceBtn.style.marginRight = 'auto';
            
            manualAdvanceBtn.addEventListener('click', async function() {
                try {
                    console.log('Manual advancement triggered');
                    manualAdvanceBtn.disabled = true;
                    manualAdvanceBtn.textContent = 'Advancing...';
                    
                    const gameRef = doc(db, 'games', gameId);
                    await advanceToNextGovernment(gameId, gameRef);
                    
                    // Success - button will be removed when phase changes
                    manualAdvanceBtn.textContent = 'âœ… Advanced!';
                } catch (error) {
                    console.error('Manual advancement failed:', error);
                    manualAdvanceBtn.disabled = false;
                    manualAdvanceBtn.textContent = 'âŒ Failed - Try Again';
                    alert('Manual advancement failed: ' + error.message);
                }
            });
            
            actionsCenter.appendChild(manualAdvanceBtn);
        }
        
        // Chancellor choice overlay (similar to president's overlay)
        function showChancellorChoiceOverlay(game) {
            const presidentCards = game.presidentDrawnCards || [];
            if (presidentCards.length !== 2) {
                console.error('Expected 2 president cards, got:', presidentCards.length);
                return;
            }
            
            // Build overlay similar to president's reveal overlay
            const overlayId = 'chancellor-choice-overlay';
            let overlay = document.getElementById(overlayId);
            if (!overlay) {
                overlay = document.createElement('div');
                overlay.id = overlayId;
                overlay.className = 'reveal-overlay';
                document.body.appendChild(overlay);
            }
            
            // Add instruction banner
            const instr = document.createElement('div');
            instr.className = 'reveal-instruction';
                            instr.textContent = 'Click to flip, then select one to enact';
            overlay.appendChild(instr);

            // Add a close (X) button to dismiss the overlay without changing state
            const closeBtn = document.createElement('button');
            closeBtn.setAttribute('type', 'button');
            closeBtn.setAttribute('aria-label', 'Close');
            closeBtn.textContent = 'Ã—';
            // Position in top-right; reuse overlay z-index context
            closeBtn.style.position = 'absolute';
            closeBtn.style.top = '12px';
            closeBtn.style.right = '12px';
            closeBtn.style.width = '36px';
            closeBtn.style.height = '36px';
            closeBtn.style.padding = '0';
            closeBtn.style.border = '3px solid var(--propaganda-black)';
            closeBtn.style.background = 'var(--off-white)';
            closeBtn.style.fontWeight = '900';
            closeBtn.style.fontSize = '20px';
            closeBtn.style.lineHeight = '1';
            closeBtn.style.borderRadius = '8px';
            closeBtn.style.cursor = 'pointer';
            closeBtn.style.zIndex = '1';
            closeBtn.addEventListener('click', function() {
                const ov = document.getElementById('chancellor-choice-overlay');
                if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
            });
            overlay.appendChild(closeBtn);
            
            // Add actions
            const actions = document.createElement('div');
            actions.className = 'reveal-actions';
            const enactBtn = document.createElement('button');
            enactBtn.className = 'reveal-btn';
            enactBtn.textContent = 'Enact Selected Policy';
            enactBtn.disabled = true;
            actions.appendChild(enactBtn);
            overlay.appendChild(actions);
            
            const centerX = Math.round(window.innerWidth / 2);
            const centerY = Math.round(window.innerHeight / 2);
            // Responsive scale: reduce card size on narrow screens so overlays don't overwhelm UI
            const _vw = window.innerWidth || (document && document.documentElement && document.documentElement.clientWidth) || 0;
            let scale = 1.4;
            if (_vw <= 360) {
                scale = 0.95;
            } else if (_vw <= 640) {
                scale = 1.1;
            }
            
            const overlayCards = [];
            
            // Create two cards fanned out in an arc, starting face down
            presidentCards.forEach((policy, index) => {
                const clone = document.createElement('div');
                clone.className = 'reveal-card';
                clone.style.backgroundImage = 'url(../images/policy-back.png)'; // Start face down
                clone.style.cursor = 'pointer';
                clone.dataset.policy = policy; // Store the policy type for later
                clone.dataset.index = index; // Store the index
                
                // Fan the cards in an arc - left card rotated left, right card rotated right
                const angle = index === 0 ? -12 : 12; // Left card -12Â°, right card +12Â° (reduced rotation)
                const radius = 100; // Distance from center (reduced from 140)
                const cardAngle = (index - 0.5) * Math.PI / 4; // Spread over 45 degrees (reduced from 60)
                
                const targetX = centerX + Math.sin(cardAngle) * radius;
                const targetY = centerY - Math.cos(cardAngle) * radius;
                
                const finalLeft = Math.round(targetX - (92 * scale) / 2); // 92 is card width
                const finalTop = Math.round(targetY - (132 * scale) / 2); // 132 is card height
                
                clone.style.left = finalLeft + 'px';
                clone.style.top = finalTop + 'px';
                clone.style.transform = `scale(${scale}) rotate(${angle}deg)`;
                clone.style.transformOrigin = 'center center';
                clone.style.transition = 'transform 300ms ease-out, box-shadow 200ms ease-out';
                clone.dataset.originalTransform = `scale(${scale}) rotate(${angle}deg)`; // Store original transform
                
                overlay.appendChild(clone);
                overlayCards.push(clone);
                
                // Add click handler for flipping and selection
                clone.addEventListener('click', function() {
                    if (!clone.classList.contains('flipped')) {
                        // First click: flip both cards simultaneously
                        flipAllCards();
                    } else {
                        // Second click: select/deselect the card
                        if (clone.classList.contains('selected')) {
                            clone.classList.remove('selected');
                            clone.style.zIndex = ''; // Reset z-index
                        } else {
                            // Deselect all cards first
                            overlayCards.forEach(c => {
                                c.classList.remove('selected');
                                c.style.zIndex = ''; // Reset z-index for all cards
                            });
                            // Select this card
                            clone.classList.add('selected');
                            clone.style.zIndex = '10'; // Bring selected card to front
                        }
                        updateEnactButtonState();
                    }
                });
            });
            
            // Function to flip all cards simultaneously
            function flipAllCards() {
                overlayCards.forEach((card, index) => {
                    const policy = presidentCards[index];
                    
                    // Start the flip animation for each card
                    const currentTransform = card.style.transform;
                    card.style.transform = currentTransform.replace('rotateY(0deg)', 'rotateY(90deg)');
                    
                    // Halfway through the flip, change the image
                    setTimeout(() => {
                        card.style.backgroundImage = policy === 'liberal' ? 'url(../images/liberal.png)' : 'url(../images/facist.png)';
                        card.classList.add(policy);
                        card.classList.add('flipped');
                        
                        // Complete the flip
                        setTimeout(() => {
                            card.style.transform = currentTransform.replace('rotateY(90deg)', 'rotateY(0deg)');
                        }, 150);
                    }, 150);
                });
            }
            
            // Update enact button state
            function updateEnactButtonState() {
                const flipped = overlayCards.filter(c => c.classList.contains('flipped'));
                const selected = overlayCards.filter(c => c.classList.contains('selected'));
                
                // Only enable enact button when both cards are flipped AND one is selected
                enactBtn.disabled = (flipped.length !== 2 || selected.length !== 1);
            }
            
            // Handle enact button click
            enactBtn.addEventListener('click', async function() {
                const selected = overlayCards.find(c => c.classList.contains('selected'));
                if (!selected) return;
                
                const selectedIndex = overlayCards.indexOf(selected);
                const enactedPolicy = presidentCards[selectedIndex];
                const discardedPolicy = presidentCards[1 - selectedIndex];
                
                try {
                    await enactPolicyAsChancellor(enactedPolicy, discardedPolicy);
                    
                    // Close the overlay
                    if (overlay && overlay.parentNode) {
                        overlay.parentNode.removeChild(overlay);
                    }
                    
                } catch (error) {
                    console.error('Failed to enact policy:', error);
                    alert('Failed to enact policy. Please try again. Error: ' + error.message);
                }
            });
            
            updateEnactButtonState();
        }
        
        // Clean up all policy-related overlays
        function cleanupAllPolicyOverlays() {
            // Clean up chancellor choice overlay
            const chancellorOverlay = document.getElementById('chancellor-choice-overlay');
            if (chancellorOverlay && chancellorOverlay.parentNode) {
                chancellorOverlay.parentNode.removeChild(chancellorOverlay);
            }
            
            // Clean up president draw overlay
            const presidentOverlay = document.getElementById('reveal-overlay');
            if (presidentOverlay && presidentOverlay.parentNode) {
                presidentOverlay.parentNode.removeChild(presidentOverlay);
            }
            
            // Clean up any spread tooltips
            const spreadTooltip = document.getElementById('spread-tooltip');
            if (spreadTooltip && spreadTooltip.parentNode) {
                spreadTooltip.parentNode.removeChild(spreadTooltip);
            }
            
            // Reset spread state
            spreadPDRevealed = 0;
            spreadPDAssigned = null;
            spreadFanShown = false;
            spreadPDListeners = false;
        }
        
        // Clean up chancellor choice overlay (kept for backward compatibility)
        function cleanupChancellorChoiceOverlay() {
            const overlay = document.getElementById('chancellor-choice-overlay');
            if (overlay && overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }

        // President draw interactions on table-spread (local-only visuals)
        let spreadPDListeners = false;
        let spreadPDRevealed = 0;
        let spreadPDAssigned = null;
        let spreadFanShown = false;
        let drawnCards = null;
        
        // Get the actual policy cards from the game state instead of random generation
        function getActualTopThreePolicies() {
            if (drawnCards) return drawnCards;
            
            // This should be replaced with actual game state when available
            // For now, we'll use a placeholder that will be updated when the game state is properly integrated
            const totalCards = 17; // 6 Liberal + 11 Fascist
            const liberalCount = 6;
            const fascistCount = 11;
            
            // Simulate drawing from the top of the deck
            const remainingLiberal = Math.max(0, liberalCount - (latestGame?.liberalPolicies || 0));
            const remainingFascist = Math.max(0, fascistCount - (latestGame?.fascistPolicies || 0));
            const totalRemaining = remainingLiberal + remainingFascist;
            
            if (totalRemaining < 3) {
                // Not enough cards, reshuffle discard pile
                console.log('Deck running low, should reshuffle discard pile');
                // Reset discard count when deck is reshuffled
                resetDiscardCount();
                return ['liberal', 'liberal', 'fascist']; // Placeholder
            }
            
            // For now, return a reasonable distribution based on remaining cards
            const policies = [];
            const liberalRatio = remainingLiberal / totalRemaining;
            
            for (let i = 0; i < 3; i++) {
                if (Math.random() < liberalRatio && remainingLiberal > 0) {
                    policies.push('liberal');
                } else {
                    policies.push('facist');
                }
            }
            
            drawnCards = policies;
            return policies;
        }
        
        function spreadAssignTopThree() {
            if (Array.isArray(spreadPDAssigned) && spreadPDAssigned.length === 3) return spreadPDAssigned;
            spreadPDAssigned = getActualTopThreePolicies();
            return spreadPDAssigned;
        }
        function teardownSpreadPresidentDrawUI() {
            const spread = document.querySelector('.table-spread');
            if (!spread) return;
            const cards = Array.from(spread.querySelectorAll('.table-card'));
            const topThree = cards.slice(-3);
            topThree.forEach(c => { c.classList.remove('glow', 'lifting', 'is-front', 'liberal', 'facist'); c.style.transform = ''; c.style.opacity = ''; c.style.pointerEvents = ''; });
            // remove listeners by cloning nodes
            topThree.forEach((card) => { const clone = card.cloneNode(true); card.parentNode.replaceChild(clone, card); });
            spreadPDListeners = false;
            spreadPDRevealed = 0;
            spreadPDAssigned = null;
            spreadFanShown = false;
            // Remove overlay if present
            const overlay = document.getElementById('reveal-overlay');
            if (overlay && overlay.parentNode) overlay.parentNode.removeChild(overlay);
            // Remove single spread tooltip if present
            const tip = document.getElementById('spread-tooltip');
            if (tip && tip.parentNode) tip.parentNode.removeChild(tip);
            
            // Hide the "View Cards" button when teardown occurs
            const viewCardsBtn = document.getElementById('view-cards-btn');
            if (viewCardsBtn) {
                viewCardsBtn.style.display = 'none';
            }
        }
        function initSpreadPresidentDrawUI(gameId) {
            // Validate gameId parameter
            if (!gameId) {
                console.error('initSpreadPresidentDrawUI called without gameId:', gameId);
                return;
            }
            
            const spread = document.querySelector('.table-spread');
            if (!spread) return;
            const cards = Array.from(spread.querySelectorAll('.table-card'));
            if (cards.length < 3) return;
            // row-reverse means leftmost are last in DOM order
            const topThree = cards.slice(-3);
            
            // Clear any existing state
            topThree.forEach(c => { 
                c.classList.remove('glow', 'lifting', 'is-front', 'liberal', 'facist'); 
                c.style.transform = ''; 
                c.style.opacity = ''; 
                c.style.pointerEvents = ''; 
            });
            
            // highlight and add one tooltip centered above spread
            topThree.forEach(c => c.classList.add('glow'));
            if (!document.getElementById('spread-tooltip')) {
                const tip = document.createElement('div');
                tip.id = 'spread-tooltip';
                tip.className = 'spread-tooltip';
                tip.textContent = 'Tap or swipe up';
                // Position centered over the middle of the three highlighted cards
                const mid = topThree[1];
                const sr = spread.getBoundingClientRect();
                const mr = mid.getBoundingClientRect();
                const relX = mr.left + mr.width / 2 - sr.left;
                const relY = mr.top - sr.top;
                tip.style.position = 'absolute';
                tip.style.left = relX + 'px';
                tip.style.top = relY + 'px';
                spread.appendChild(tip);
            }
            const vals = spreadAssignTopThree();
            if (spreadPDListeners) return;
            spreadPDListeners = true;
            // Group drag state so all three follow the finger together
            let groupDragging = false;
            let startX = 0, startY = 0;
            let moved = false; let tapStart = 0;
            
            // Define revealAllToCenterFan function with access to gameId
            const revealAllToCenterFan = () => {
                // Debug logging
                console.log('revealAllToCenterFan called with gameId:', gameId);
                
                if (spreadFanShown) return;
                spreadFanShown = true;
                
                // Hide the "View Cards" button when overlay is shown
                const viewCardsBtn = document.getElementById('view-cards-btn');
                if (viewCardsBtn) {
                    viewCardsBtn.style.display = 'none';
                }
                
                // Remove the "Tap or Swipe Up" tip when cards are revealed
                const tip = document.getElementById('spread-tooltip');
                if (tip && tip.parentNode) {
                    tip.parentNode.removeChild(tip);
                }
                
                // Get current dragged positions of the three cards
                const currentPositions = topThree.map(card => {
                    const transform = getComputedStyle(card).transform;
                    const matrix = new DOMMatrix(transform);
                    return { x: matrix.m41, y: matrix.m42 };
                });
                
                // Build overlay and move three clones from their current positions to center
                const overlayId = 'reveal-overlay';
                let overlay = document.getElementById(overlayId);
                if (!overlay) {
                    overlay = document.createElement('div');
                    overlay.id = overlayId;
                    overlay.className = 'reveal-overlay';
                    document.body.appendChild(overlay);
                }
                // Add instruction banner and actions
                const instr = document.createElement('div');
                instr.className = 'reveal-instruction';
                instr.textContent = 'Select Two to give to your Chancellor';
                overlay.appendChild(instr);
                // Add a close (X) button to dismiss the overlay without changing state
                const closeBtn = document.createElement('button');
                closeBtn.setAttribute('type', 'button');
                closeBtn.setAttribute('aria-label', 'Close');
                closeBtn.textContent = 'Ã—';
                closeBtn.style.position = 'absolute';
                closeBtn.style.top = '12px';
                closeBtn.style.right = '12px';
                closeBtn.style.width = '36px';
                closeBtn.style.height = '36px';
                closeBtn.style.padding = '0';
                closeBtn.style.border = '3px solid var(--propaganda-black)';
                closeBtn.style.background = 'var(--off-white)';
                closeBtn.style.fontWeight = '900';
                closeBtn.style.fontSize = '20px';
                closeBtn.style.lineHeight = '1';
                closeBtn.style.borderRadius = '8px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.zIndex = '1';
                closeBtn.addEventListener('click', function() {
                    const ov = document.getElementById('reveal-overlay');
                    if (ov && ov.parentNode) ov.parentNode.removeChild(ov);
                    
                    // Reset the spread state and remove glow from cards
                    spreadFanShown = false;
                    topThree.forEach(c => { 
                        c.classList.remove('lifting', 'is-front', 'liberal', 'facist'); 
                        c.style.transform = ''; 
                        c.style.opacity = ''; 
                        c.style.pointerEvents = ''; 
                    });
                    
                    // Re-add the tip since we're back to the initial state
                    if (!document.getElementById('spread-tooltip')) {
                        const tip = document.createElement('div');
                        tip.id = 'spread-tooltip';
                        tip.className = 'spread-tooltip';
                        tip.textContent = 'Tap or swipe up';
                        // Position centered over the middle of the three highlighted cards
                        const mid = topThree[1];
                        const sr = spread.getBoundingClientRect();
                        const mr = mid.getBoundingClientRect();
                        const relX = mr.left + mr.width / 2 - sr.left;
                        const relY = mr.top - sr.top;
                        tip.style.position = 'absolute';
                        tip.style.left = relX + 'px';
                        tip.style.top = relY + 'px';
                        spread.appendChild(tip);
                    }
                    
                    // Re-add glow to the top three cards
                    topThree.forEach(c => c.classList.add('glow'));
                    
                    // Show the "View Cards" button in the floating navigation
                    const viewCardsBtn = document.getElementById('view-cards-btn');
                    if (viewCardsBtn) {
                        viewCardsBtn.style.display = 'block';
                    }
                });
                overlay.appendChild(closeBtn);
                const actions = document.createElement('div');
                actions.className = 'reveal-actions';
                const sendBtn = document.createElement('button');
                sendBtn.className = 'reveal-btn';
                sendBtn.textContent = 'Send to Chancellor';
                sendBtn.disabled = true;
                actions.appendChild(sendBtn);
                overlay.appendChild(actions);
                const centerX = Math.round(window.innerWidth / 2);
                const centerY = Math.round(window.innerHeight / 2);
                const sampleRect = topThree[0].getBoundingClientRect();
                // Responsive scale: smaller overlays on phones
                const _vw2 = window.innerWidth || (document && document.documentElement && document.documentElement.clientWidth) || 0;
                let scale = 1.4;
                if (_vw2 <= 360) {
                    scale = 1.0;
                } else if (_vw2 <= 640) {
                    scale = 1.15;
                }
                const spacing = Math.max(96, Math.round(sampleRect.width * 1.25 * scale));
                const orderMap = [2, 1, 0]; // map to left, center, right visually
                const overlayCards = [];
                orderMap.forEach((srcIdx, posIdx) => {
                    const src = topThree[srcIdx];
                    const policy = vals[srcIdx];
                    // Style source to appear flipped and hide glow
                    src.classList.add('is-front');
                    src.classList.add(policy);
                    src.classList.remove('glow');
                    // Hide originals so only overlay cards are visible
                    src.style.opacity = '0';
                    src.style.pointerEvents = 'none';
                    
                                                              // Create overlay clone starting from current dragged position (face down)
                      const clone = document.createElement('div');
                      clone.className = 'reveal-card';
                      clone.style.backgroundImage = 'url(../images/policy-back.png)'; // Start face down
                      clone.style.transition = 'transform 240ms ease-out, left 240ms ease-out, top 240ms ease-out';
                      
                      // Start from current dragged position
                      const startX = sampleRect.left + currentPositions[srcIdx].x;
                      const startY = sampleRect.top + currentPositions[srcIdx].y;
                      clone.style.left = startX + 'px';
                      clone.style.top = startY + 'px';
                      clone.style.transform = 'scale(1) rotate(0deg)';
                      clone.style.zIndex = '10'; // Set initial z-index
                      overlay.appendChild(clone);
                      overlayCards.push(clone);
                      
                      // Animate to final position
                      const targetX = centerX + (posIdx - 1) * spacing;
                      const targetY = centerY;
                      const finalLeft = Math.round(targetX - (sampleRect.width * scale) / 2);
                      const finalTop = Math.round(targetY - (sampleRect.height * scale) / 2);
                      const rot = posIdx === 0 ? -8 : (posIdx === 2 ? 8 : 0);
                      
                      requestAnimationFrame(() => {
                          clone.style.left = finalLeft + 'px';
                          clone.style.top = finalTop + 'px';
                          clone.style.transform = `scale(${scale}) rotate(${rot}deg)`;
                          
                          // After position animation completes, flip the card
                          setTimeout(() => {
                              clone.style.transition = 'transform 300ms ease-out';
                              clone.style.transform = `scale(${scale}) rotate(${rot}deg) rotateY(180deg)`;
                              
                              // Halfway through flip, change to front image
                              setTimeout(() => {
                                  clone.style.backgroundImage = policy === 'liberal' ? 'url(../images/liberal.png)' : 'url(../images/facist.png)';
                                  clone.classList.add(policy);
                              }, 150);
                              
                              // Complete the flip
                              setTimeout(() => {
                                  clone.style.transform = `scale(${scale}) rotate(${rot}deg)`;
                              }, 300);
                          }, 300); // Wait for position animation to complete
                      });
                });
                spreadPDRevealed = 3;

                // Selection logic: click to toggle; enable send when exactly 2 selected
                function updateSendState() {
                    const selected = overlayCards.filter(c => c.classList.contains('selected'));
                    sendBtn.disabled = (selected.length !== 2);
                    
                    // Update z-index for selected cards to make them pop to the top
                    overlayCards.forEach(card => {
                        if (card.classList.contains('selected')) {
                            card.style.zIndex = '20'; // Higher z-index for selected cards
                        } else {
                            card.style.zIndex = '10'; // Lower z-index for unselected cards
                        }
                    });
                }
                overlayCards.forEach((c) => {
                    c.style.cursor = 'pointer';
                    c.addEventListener('click', function() {
                        if (c.classList.contains('selected')) {
                            c.classList.remove('selected');
                        } else {
                            // Limit to 2 selected
                            const selected = overlayCards.filter(cc => cc.classList.contains('selected'));
                            if (selected.length >= 2) return;
                            c.classList.add('selected');
                        }
                        updateSendState();
                    });
                });
                updateSendState();
                
                // Handle sending cards to chancellor
                sendBtn.addEventListener('click', async function() {
                    console.log('Send button clicked with gameId:', gameId);
                    
                    // Validate gameId is available
                    if (!gameId) {
                        console.error('gameId is undefined in send button click handler');
                        alert('Game session error. Please refresh the page and try again.');
                        return;
                    }
                    
                    const selected = overlayCards.filter(c => c.classList.contains('selected'));
                    console.log('Selected cards:', selected);
                    
                    if (selected.length !== 2) {
                        console.log('Not enough cards selected:', selected.length);
                        return;
                    }
                    
                    // Get the selected card policies
                    const selectedPolicies = selected.map(card => {
                        if (card.classList.contains('liberal')) return 'liberal';
                        if (card.classList.contains('facist')) return 'fascist';
                        return 'liberal'; // fallback
                    });
                    
                    console.log('Selected policies:', selectedPolicies);
                    
                    // Get the discarded policy (the one not selected)
                    const discardedPolicy = overlayCards.find(card => !card.classList.contains('selected'));
                    const discardedPolicyType = discardedPolicy ? 
                        (discardedPolicy.classList.contains('liberal') ? 'liberal' : 'fascist') : 'liberal';
                    
                    console.log('Discarded policy:', discardedPolicyType);
                    
                    try {
                        console.log('Calling updateGameStateAfterPresidentDraw...');
                        // Update game state to remove the top 3 cards and move to chancellor phase
                        await updateGameStateAfterPresidentDraw(selectedPolicies, discardedPolicyType);
                        
                        console.log('Game state updated successfully');
                        
                        // Close the overlay and clean up
                        if (overlay && overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }
                        
                        // Clean up the spread state and remove glow from cards
                        spreadFanShown = false;
                        topThree.forEach(c => { 
                            c.classList.remove('lifting', 'is-front', 'liberal', 'facist'); 
                            c.style.transform = ''; 
                            c.style.opacity = ''; 
                            c.style.pointerEvents = ''; 
                        });
                        
                        // Remove the tip since we're moving to the next phase
                        const tip = document.getElementById('spread-tooltip');
                        if (tip && tip.parentNode) {
                            tip.parentNode.removeChild(tip);
                        }
                        
                        // Hide the "View Cards" button since we're moving to next phase
                        const viewCardsBtn = document.getElementById('view-cards-btn');
                        if (viewCardsBtn) {
                            viewCardsBtn.style.display = 'none';
                        }
                        
                        // Update the visual deck to show fewer cards and add discarded card to pile
                        updateDeckVisualAfterDraw();
                        
                        // Move to chancellor phase
                        setStatus(gameId, 'President has drawn cards. Waiting for Chancellor to choose...');
                        
                    } catch (error) {
                        console.error('Failed to update game state:', error);
                        console.error('Full error object:', error);
                        
                        // Provide more helpful error messages
                        let errorMessage = 'Failed to send cards to Chancellor. ';
                        if (error.message.includes('Game ID not found')) {
                            errorMessage += 'Game session error. Please refresh the page and try again.';
                        } else if (error.message.includes('Game data not loaded')) {
                            errorMessage += 'Game data is still loading. Please wait a moment and try again.';
                        } else {
                            errorMessage += 'Please try again. Error: ' + error.message;
                        }
                        
                        alert(errorMessage);
                    }
                });
            };
            topThree.forEach((card, idx) => {
                const policy = vals[idx];
                function onDown(e) {
                    if (spreadFanShown) return;
                    if (card.classList.contains('is-front')) return;
                    groupDragging = true; moved = false; tapStart = Date.now();
                    const pt = e.touches ? e.touches[0] : e;
                    startX = pt.clientX; startY = pt.clientY;
                    topThree.forEach(c => c.classList.add('lifting'));
                }
                function onMove(e) {
                    if (!groupDragging) return;
                    const pt = e.touches ? e.touches[0] : e;
                    const dx = pt.clientX - startX; const dy = pt.clientY - startY;
                    if (Math.abs(dx) + Math.abs(dy) > 10) moved = true;
                    const ty = Math.min(0, dy); // Only restrict upward movement
                    const tx = dx; // Allow full horizontal movement
                    topThree.forEach(c => { c.style.transform = `translate(${tx}px, ${ty}px)`; });
                }
                function onUp(e) {
                    if (!groupDragging) return;
                    groupDragging = false; topThree.forEach(c => c.classList.remove('lifting'));
                    const pt = e.changedTouches ? e.changedTouches[0] : e;
                    const deltaY = pt.clientY - startY;
                    const tapDuration = Date.now() - tapStart;
                    if (deltaY < -60 || (!moved && tapDuration < 300)) {
                        revealAllToCenterFan();
                    } else {
                        topThree.forEach(c => { c.style.transform = ''; });
                    }
                }
                card.addEventListener('mousedown', onDown);
                card.addEventListener('mousemove', onMove);
                card.addEventListener('mouseup', onUp);
                card.addEventListener('mouseleave', onUp);
                card.addEventListener('touchstart', onDown, { passive: true });
                card.addEventListener('touchmove', onMove, { passive: true });
                card.addEventListener('touchend', onUp);
                card.addEventListener('touchcancel', onUp);
                // Also handle simple click to reveal
                card.addEventListener('click', function() { revealAllToCenterFan(); });
            });
            
            // Ensure glow is visible by forcing a reflow
            setTimeout(() => {
                topThree.forEach(c => {
                    if (!c.classList.contains('glow')) {
                        c.classList.add('glow');
                    }
                });
                
                // Debug: log the glow state
                console.log('Glow state after initialization:', topThree.map(c => ({
                    element: c,
                    hasGlow: c.classList.contains('glow'),
                    classes: Array.from(c.classList)
                })));
            }, 100);
            
            // Add event listener for the "View Cards" button
            const viewCardsBtn = document.getElementById('view-cards-btn');
            if (viewCardsBtn) {
                viewCardsBtn.addEventListener('click', function() {
                    // Hide the button
                    viewCardsBtn.style.display = 'none';
                    
                    // Show the overlay again
                    revealAllToCenterFan();
                });
            }
            
            // Add event listener for the "Repair Game" button
            const repairGameMainBtn = document.getElementById('repair-game-main-btn');
            if (repairGameMainBtn) {
                repairGameMainBtn.addEventListener('click', async function() {
                    try {
                        repairGameMainBtn.disabled = true;
                        repairGameMainBtn.textContent = 'ðŸ”§ Repairing...';
                        
                        const gameId = getGameId();
                        const repaired = await repairGameState(gameId);
                        
                        if (repaired) {
                            repairGameMainBtn.textContent = 'âœ… Repaired!';
                            setTimeout(() => {
                                repairGameMainBtn.textContent = 'ðŸ”§ Repair';
                                repairGameMainBtn.disabled = false;
                            }, 2000);
                        } else {
                            repairGameMainBtn.textContent = 'âœ… No Issues';
                            setTimeout(() => {
                                repairGameMainBtn.textContent = 'ðŸ”§ Repair';
                                repairGameMainBtn.disabled = false;
                            }, 2000);
                        }
                    } catch (err) {
                        console.error('Game repair failed:', err);
                        repairGameMainBtn.textContent = 'âŒ Failed';
                        repairGameMainBtn.disabled = false;
                        setTimeout(() => {
                            repairGameMainBtn.textContent = 'ðŸ”§ Repair';
                        }, 3000);
                    }
                });
            }
        }
        
        // Helper function to update game state after president draws cards
        async function updateGameStateAfterPresidentDraw(selectedPolicies, discardedPolicy) {
            const gameId = getGameId();
            console.log('updateGameStateAfterPresidentDraw called with:', { gameId, selectedPolicies, discardedPolicy });
            
            if (!gameId) {
                throw new Error('Game ID not found');
            }
            
            if (!latestGame) {
                throw new Error('Game data not loaded yet');
            }
            
            console.log('Current game state:', latestGame);
            
            try {
                // Update the game document to reflect that cards have been drawn
                const gameRef = doc(db, 'games', gameId);
                console.log('Updating game document:', gameRef.path);
                
                const updateData = {
                    policyPhase: 'chancellor_choice',
                    presidentDrawnCards: selectedPolicies,
                    presidentDiscardedCard: discardedPolicy,
                    updatedAt: serverTimestamp()
                };
                
                console.log('Update data:', updateData);
                
                await updateDoc(gameRef, updateData);
                console.log('Game document updated successfully');
                
                // Log the action
                console.log('Logging public action...');
                await logPublic(gameId, `President drew 3 policy cards and discarded 1 ${discardedPolicy} policy`, {
                    type: 'policy_draw',
                    actorId: latestGame.currentPresidentPlayerId,
                    selectedPolicies: selectedPolicies,
                    discardedPolicy: discardedPolicy
                });
                console.log('Public action logged successfully');
                
            } catch (error) {
                console.error('Error updating game state:', error);
                console.error('Error details:', {
                    message: error.message,
                    code: error.code,
                    stack: error.stack
                });
                throw error;
            }
        }
        
        // Helper function to update the visual table spread and deck after cards are drawn
        function updateDeckVisualAfterDraw() {
            const spread = document.querySelector('.table-spread');
            if (!spread) return;
            
            const cards = Array.from(spread.querySelectorAll('.table-card'));
            if (cards.length < 3) return;
            
            // Remove the top 3 cards from the visual spread
            const topThree = cards.slice(-3);
            topThree.forEach(card => {
                if (card.parentNode) {
                    card.parentNode.removeChild(card);
                }
            });
            
            // Add the discarded card to the discard pile
            addDiscardedCardToPile();
        }
        

        
        // Helper function to add discarded card to discard pile
        function addDiscardedCardToPile() {
            console.log('Adding discarded card to discard pile');
            
            // Use our dynamic discard pile module to increment the count
            incrementDiscardCount();
            
            console.log('Discarded card added successfully');
        }
        
        // Helper function for chancellor to enact a policy
        async function enactPolicyAsChancellor(enactedPolicy, discardedPolicy) {
            const gameId = getGameId();
            if (!gameId || !latestGame) {
                throw new Error('Game not found');
            }
            
            try {
                console.log('Enacting policy:', enactedPolicy, 'Discarded:', discardedPolicy);
                console.log('Current game state before update:', latestGame);
                
                // Update the game document to reflect the enacted policy
                const gameRef = doc(db, 'games', gameId);
                const updates = {
                    policyPhase: 'completed',
                    enactedPolicy: enactedPolicy,
                    chancellorDiscardedCard: discardedPolicy,
                    updatedAt: serverTimestamp()
                };
                
                // Increment the appropriate policy counter
                if (enactedPolicy === 'liberal') {
                    updates.liberalPolicies = increment(1);
                } else if (enactedPolicy === 'fascist') {
                    updates.fascistPolicies = increment(1);
                }
                
                console.log('Updating game with:', updates);
                await updateDoc(gameRef, updates);
                console.log('Policy enacted successfully');
                
                // Log the action
                await logPublic(gameId, `Chancellor enacted a ${enactedPolicy} policy`, {
                    type: 'policy_enact',
                    actorId: latestGame.currentChancellorPlayerId,
                    enactedPolicy: enactedPolicy,
                    discardedPolicy: discardedPolicy
                });
                
                // Increment discard pile count for chancellor's discarded card
                incrementDiscardCount();
                
                // Check if this triggers executive powers
                const newLiberalCount = (latestGame.liberalPolicies || 0) + (enactedPolicy === 'liberal' ? 1 : 0);
                const newFascistCount = (latestGame.fascistPolicies || 0) + (enactedPolicy === 'fascist' ? 1 : 0);
                
                if (newFascistCount >= 3 && newFascistCount <= 5) {
                    // Executive powers unlocked
                    await logPublic(gameId, `Executive powers unlocked! President gains special abilities`, {
                        type: 'executive_powers',
                        fascistPolicies: newFascistCount
                    });
                }
                
                // Clean up all overlays immediately after policy enactment
                cleanupAllPolicyOverlays();
                
                // Wait a moment for the first update to complete, then advance to next government
                setTimeout(async () => {
                    try {
                        await advanceToNextGovernment(gameId, gameRef);
                    } catch (advanceError) {
                        console.error('Failed to advance to next government:', advanceError);
                        // Apply fallback cleanup to prevent getting stuck
                        await applyFallbackCleanup(gameId, gameRef);
                    }
                }, 1000);
                
            } catch (error) {
                console.error('Error enacting policy:', error);
                throw error;
            }
        }
        
        // Separate function to advance to next government
        async function advanceToNextGovernment(gameId, gameRef) {
            console.log('Advancing to next government...');
            
            // Get fresh game state
            const gameSnap = await getDoc(gameRef);
            if (!gameSnap.exists()) {
                throw new Error('Game no longer exists');
            }
            const currentGame = gameSnap.data();
            
            const prevChancellorId = currentGame.currentChancellorPlayerId || null;
            const prevPresidentId = currentGame.currentPresidentPlayerId || null;
            
            console.log('Previous chancellor:', prevChancellorId);
            console.log('Previous president:', prevPresidentId);
            console.log('Current players:', latestPlayers);
            
            // Get alive players and sort by orderIndex
            const orderedAlive = (latestPlayers || [])
                .filter(p => p && p.alive !== false)
                .sort((a, b) => (a.orderIndex || 0) - (b.orderIndex || 0));
            
            console.log('Ordered alive players:', orderedAlive);
            
            if (orderedAlive.length === 0) {
                console.error('No alive players found!');
                throw new Error('No alive players found');
            }
            
            // Find current president index
            const currentPresidentId = currentGame.currentPresidentPlayerId;
            const currentIndex = orderedAlive.findIndex(p => p.id === currentPresidentId);
            
            console.log('Current president ID:', currentPresidentId);
            console.log('Current president index:', currentIndex);
            
            if (currentIndex === -1) {
                console.error('Current president not found in alive players!');
                // Fallback: use the first player as next president
                const nextPresident = orderedAlive[0];
                console.log('Using fallback next president:', nextPresident);
                
                const fallbackUpdates = {
                    // Clear out policy phase artifacts
                    policyPhase: null,
                    enactedPolicy: null,
                    presidentDrawnCards: [],
                    presidentDiscardedCard: null,
                    chancellorDiscardedCard: null,
                    // Clear current chancellor and nomination
                    currentChancellorPlayerId: null,
                    nominatedChancellorPlayerId: null,
                    // Reset vote state
                    voteResolution: null,
                    electionVotes: {},
                    // Set term limits
                    termLimitLastChancellorId: prevChancellorId,
                    termLimitLastPresidentId: prevPresidentId,
                    // Set next president
                    presidentIndex: 0,
                    currentPresidentPlayerId: nextPresident.id,
                    updatedAt: serverTimestamp()
                };
                
                await updateDoc(gameRef, fallbackUpdates);
                console.log('Fallback government advancement completed');
                
                // Clean up any remaining overlays after fallback advancement
                cleanupAllPolicyOverlays();
                
                // Announce rotation
                await logPublic(
                    gameId,
                    `Next President: ${nextPresident.name || 'Player'}. President, please nominate a Chancellor.`,
                    { type: 'rotation', actorId: nextPresident.id }
                );
                
                return;
            }
            
            // Calculate next president index
            const nextIndex = (currentIndex + 1) % orderedAlive.length;
            const nextPresident = orderedAlive[nextIndex];
            
            console.log('Next president index:', nextIndex);
            console.log('Next president:', nextPresident);
            
            if (!nextPresident) {
                console.error('Next president calculation failed!');
                throw new Error('Failed to calculate next president');
            }

            const advanceUpdates = {
                // Clear out policy phase artifacts so UI returns to nomination
                policyPhase: null,
                enactedPolicy: null,
                presidentDrawnCards: [],
                // DON'T clear discarded card fields - they represent permanent game state
                // presidentDiscardedCard: null,        // Keep this for discard pile tracking
                // chancellorDiscardedCard: null,       // Keep this for discard pile tracking
                // Clear current chancellor and nomination
                currentChancellorPlayerId: null,
                nominatedChancellorPlayerId: null,
                // Reset vote state so computePhase() returns 'nomination'
                voteResolution: null,
                electionVotes: {},
                // Set term limits for next turn eligibility
                termLimitLastChancellorId: prevChancellorId,
                termLimitLastPresidentId: prevPresidentId,
                // Rotate president
                presidentIndex: nextIndex,
                currentPresidentPlayerId: nextPresident.id,
                updatedAt: serverTimestamp()
            };

            console.log('Advancing with updates:', advanceUpdates);
            await updateDoc(gameRef, advanceUpdates);
            console.log('Government advancement completed successfully');
            
            // Clean up any remaining overlays after advancing
            cleanupAllPolicyOverlays();

            // Announce rotation and prompt nomination
            try {
                await logPublic(
                    gameId,
                    `Next President: ${nextPresident.name || 'Player'}. President, please nominate a Chancellor.`,
                    { type: 'rotation', actorId: nextPresident.id }
                );
            } catch (e) {
                console.error('Failed to log rotation message:', e);
            }
        }
        
        // Fallback cleanup function to prevent getting stuck
        async function applyFallbackCleanup(gameId, gameRef) {
            console.log('Applying fallback cleanup to prevent getting stuck...');
            try {
                const fallbackUpdates = {
                    policyPhase: null,
                    enactedPolicy: null,
                    presidentDrawnCards: [],
                    // Preserve discarded card information to maintain discard pile
                    // presidentDiscardedCard: null,        // Keep this
                    // chancellorDiscardedCard: null,       // Keep this
                    currentChancellorPlayerId: null,
                    nominatedChancellorPlayerId: null,
                    voteResolution: null,
                    electionVotes: {},
                    updatedAt: serverTimestamp()
                };
                
                await updateDoc(gameRef, fallbackUpdates);
                console.log('Fallback cleanup applied successfully');
                
                // Clean up any remaining overlays after fallback cleanup
                cleanupAllPolicyOverlays();
                
                // Log the cleanup
                await logPublic(gameId, 'Game state reset due to advancement failure. Please restart the game phase.', {
                    type: 'system_error'
                });
                
            } catch (cleanupError) {
                console.error('Failed to apply fallback cleanup:', cleanupError);
            }
        }

        function renderActions(gameId) {
            const actionsCenter = document.querySelector('.actions-center');
            if (!actionsCenter) return;
            actionsCenter.innerHTML = '';

            const youId = computeYouId(gameId);
            const game = latestGame;
            const players = latestPlayers || [];
            if (!game || !players.length) return;

            if (localPaused) {
                const pausedMsg = document.createElement('div');
                pausedMsg.className = 'status-text';
                pausedMsg.textContent = 'Paused (AFK). Open Menu to resume.';
                actionsCenter.appendChild(pausedMsg);
                return;
            }

            if (game.state !== 'playing') return;

            const phase = computePhase(game);
            console.log('Rendering actions for phase:', phase, 'Game state:', {
                policyPhase: game.policyPhase,
                enactedPolicy: game.enactedPolicy,
                currentPresident: game.currentPresidentPlayerId,
                currentChancellor: game.currentChancellorPlayerId,
                voteResolution: game.voteResolution
            });
            
            if (phase === 'nomination') {
                // Clean up any lingering overlays when entering nomination phase
                cleanupAllPolicyOverlays();
                return renderPhaseNomination(gameId, youId, game, players, actionsCenter);
            }
            if (phase === 'voting') return renderPhaseVoting(gameId, youId, game, players, actionsCenter);
            if (phase === 'president_draw') return renderPhasePresidentDraw(gameId, youId, game, players, actionsCenter);
            if (phase === 'chancellor_choice') return renderPhaseChancellorChoice(gameId, youId, game, players, actionsCenter);
            if (phase === 'completed') return renderPhaseCompleted(gameId, youId, game, players, actionsCenter);
            // For other phases not yet implemented, show a neutral status
            setStatus(gameId, 'Proceeding to next phaseâ€¦');
        }

        document.addEventListener('DOMContentLoaded', async function() {
            const gid = getGameId();
            // Ensure we have an auth user so we can match uid if session id missing
            await ensureAuth();
            try { localPaused = localStorage.getItem(`sh_paused_${gid}`) === 'true'; } catch (_) {}
            const status = document.getElementById('status');
            const liberalSlots = document.getElementById('liberal-slots');
            const fascistSlots = document.getElementById('fascist-slots');
            const tracker = document.getElementById('election-tracker');
            const playersStrip = document.getElementById('players-strip');

            renderSlots(liberalSlots, 5);
            renderSlots(fascistSlots, 6);
            renderTracker(tracker);

            // Role banner is inline now, no dynamic positioning required

            // Order modal handlers (set up early so button works even if game load fails)
            const orderBtn = document.getElementById('order-btn');
            const orderModal = document.getElementById('order-modal');
            const orderClose = document.getElementById('order-close');
            const orderBody = document.getElementById('order-body');

            // History modal handlers
            const historyBtn = document.getElementById('history-btn');
            const historyModal = document.getElementById('history-modal');
            const historyClose = document.getElementById('history-close');
            const historyBody = document.getElementById('history-body');

            // Nomination modal handlers
            const nominationModal = document.getElementById('nomination-modal');
            const nominationClose = document.getElementById('nomination-close');
            const nominationBody = document.getElementById('nomination-body');

            function setRoleBannerVisibility(visible) {
                const banner = document.getElementById('role-banner');
                if (!banner) return;
                banner.style.visibility = visible ? 'visible' : 'hidden';
            }

            function formatTime(ts) {
                try {
                    if (!ts) return '';
                    const d = ts.toDate ? ts.toDate() : (ts instanceof Date ? ts : null);
                    if (!d) return '';
                    return new Intl.DateTimeFormat(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' }).format(d);
                } catch (_) { return ''; }
            }

            function youPlayerDoc() {
                const id = computeYouId(gid);
                return (latestPlayers || []).find(p => p && p.id === id) || null;
            }

            function canSeeEvent(evt) {
                const vis = (evt && evt.visibility) || 'public';
                if (vis === 'silent') return false;
                if (vis === 'public') return true;
                const you = youPlayerDoc();
                if (!you) return false;
                if (vis === 'private') {
                    const audience = Array.isArray(evt && evt.audience) ? evt.audience : [];
                    return audience.includes(you.id);
                }
                if (vis === 'partied') {
                    const party = ((evt && evt.party) || '').toString().toLowerCase();
                    const yourParty = ((you && you.party) || '').toString().toLowerCase();
                    return party && yourParty && party === yourParty;
                }
                return false;
            }

            function renderHistory() {
                if (!historyBody) return;
                historyBody.innerHTML = '';
                const wrap = document.createElement('div');
                wrap.style.display = 'flex';
                wrap.style.flexDirection = 'column';
                wrap.style.gap = '8px';

                const visibleItems = (historyItems || []).filter(canSeeEvent);

                if (visibleItems.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = 'No history yet.';
                    historyBody.appendChild(p);
                    return;
                }

                visibleItems.forEach((evt) => {
                    const row = document.createElement('div');
                    row.className = 'order-item';
                    const left = document.createElement('div');
                    left.className = 'order-left';
                    const time = document.createElement('div');
                    time.className = 'order-num';
                    time.textContent = formatTime(evt.ts);
                    const msg = document.createElement('div');
                    msg.style.fontWeight = '800';
                    msg.textContent = evt.message || '';
                    left.appendChild(time);
                    left.appendChild(msg);
                    row.appendChild(left);

                    const right = document.createElement('div');
                    right.className = 'order-right';
                    const tag = document.createElement('span');
                    tag.className = 'badge-pres';
                    tag.textContent = (evt.visibility || 'public').toUpperCase();
                    right.appendChild(tag);
                    row.appendChild(right);

                    wrap.appendChild(row);
                });
                historyBody.appendChild(wrap);
            }

            function openOrderModal() {
                orderBody.innerHTML = '';
                const list = document.createElement('div');
                list.className = 'order-list';
                if (!latestPlayers || latestPlayers.length === 0) {
                    const p = document.createElement('p');
                    p.textContent = 'Player order not available yet.';
                    orderBody.appendChild(p);
                } else {
                    latestPlayers.forEach((p, idx) => {
                        const row = document.createElement('div');
                        row.className = 'order-item';
                        const left = document.createElement('div');
                        left.className = 'order-left';
                        const num = document.createElement('div');
                        num.className = 'order-num';
                        num.textContent = String(idx + 1);
                        const name = document.createElement('div');
                        name.style.fontWeight = '800';
                        name.textContent = p.name || 'Player';
                        left.appendChild(num);
                        left.appendChild(name);
                        row.appendChild(left);

                        const right = document.createElement('div');
                        right.className = 'order-right';
                        if (latestGame && latestGame.currentPresidentPlayerId === p.id) {
                            const pres = document.createElement('span');
                            pres.className = 'badge-pres';
                            pres.textContent = 'ðŸ‘‘ President';
                            right.appendChild(pres);
                        }
                        if (latestGame && latestGame.currentChancellorPlayerId === p.id) {
                            const chanc = document.createElement('span');
                            chanc.className = 'badge-chanc';
                            chanc.textContent = 'ðŸ”¨ Chancellor';
                            right.appendChild(chanc);
                        }
                        // During an active vote, indicate who has voted
                        if (latestGame && latestGame.nominatedChancellorPlayerId) {
                            const evotes = (latestGame.electionVotes && typeof latestGame.electionVotes === 'object') ? latestGame.electionVotes : {};
                            if (evotes && Object.prototype.hasOwnProperty.call(evotes, p.id)) {
                                const voted = document.createElement('span');
                                voted.className = 'badge-pres';
                                voted.textContent = 'VOTED';
                                right.appendChild(voted);
                            }
                        }
                        row.appendChild(right);
                        list.appendChild(row);
                    });
                    orderBody.appendChild(list);
                }
                orderModal.style.display = 'flex';
                setRoleBannerVisibility(false);
            }

            function closeOrderModal() { orderModal.style.display = 'none'; setRoleBannerVisibility(true); }
                    orderBtn?.addEventListener('click', openOrderModal);
        orderClose?.addEventListener('click', closeOrderModal);
        orderModal?.addEventListener('click', function(e) { if (e.target === orderModal) closeOrderModal(); });
        
        // Role envelope event listener
        const roleEnvelope = document.getElementById('role-envelope');
        roleEnvelope?.addEventListener('click', openRoleOverlay);

            function openHistoryModal() {
                if (!historyModal) return;
                historyModal.style.display = 'flex';
                setRoleBannerVisibility(false);
                // Subscribe on open
                if (!historyUnsub) {
                    try {
                        historyUnsub = onHistory(gid, (items) => {
                            historyItems = items || [];
                            renderHistory();
                        });
                    } catch (_) {}
                }
                renderHistory();
            }

            function closeHistoryModal() {
                if (historyModal) historyModal.style.display = 'none';
                setRoleBannerVisibility(true);
                if (historyUnsub) { try { historyUnsub(); } catch (_) {} historyUnsub = null; }
            }
            historyBtn?.addEventListener('click', openHistoryModal);
            historyClose?.addEventListener('click', closeHistoryModal);
            historyModal?.addEventListener('click', function(e) { if (e.target === historyModal) closeHistoryModal(); });

            function openNominationModal() {
                if (!nominationModal) return;
                if (isNominating) return; // Prevent opening during nomination transition
                const youId = computeYouId(gid);
                const presId = latestGame && latestGame.currentPresidentPlayerId;
                if (!youId || !presId || youId !== presId) return;
                if (latestGame && latestGame.nominatedChancellorPlayerId) return;
                
                // Additional safety check - if we're in voting phase, don't open nomination modal
                if (latestGame && latestGame.nominatedChancellorPlayerId && latestGame.electionVotes) {
                    return;
                }
                nominationBody.innerHTML = '';
                const ids = eligibleChancellorIds(latestGame, latestPlayers || []);
                if (!ids.length) {
                    const p = document.createElement('p');
                    p.textContent = 'No eligible candidates right now.';
                    nominationBody.appendChild(p);
                } else {
                    const list = document.createElement('div');
                    list.style.display = 'grid';
                    list.style.gridTemplateColumns = '1fr 1fr';
                    list.style.gap = '10px';
                    ids.forEach(id => {
                        const pl = (latestPlayers || []).find(pp => pp && pp.id === id);
                        const btn = document.createElement('button');
                        btn.className = 'btn btn-primary';
                        btn.style.width = '100%';
                        btn.style.minHeight = '56px';
                        btn.style.fontSize = '1rem';
                        btn.setAttribute('data-nominate', id);
                        btn.textContent = pl ? (pl.name || 'Player') : 'Player';
                        list.appendChild(btn);
                    });
                    // If odd count, center the last button across both columns
                    if (ids.length % 2 === 1) {
                        const lastBtn = list.lastElementChild;
                        if (lastBtn) {
                            lastBtn.style.gridColumn = '1 / -1';
                            lastBtn.style.justifySelf = 'center';
                            lastBtn.style.width = '60%';
                        }
                    }
                    nominationBody.appendChild(list);
                }
                nominationModal.style.display = 'flex';
                setRoleBannerVisibility(false);
            }
            function closeNominationModal() { if (nominationModal) { nominationModal.style.display = 'none'; setRoleBannerVisibility(true); } }
            nominationClose?.addEventListener('click', closeNominationModal);
            nominationModal?.addEventListener('click', function(e) { if (e.target === nominationModal) closeNominationModal(); });

            // Rules modal handlers
            const rulesBtn = document.getElementById('help-btn');
            const rulesModal = document.getElementById('rules-modal');
            const rulesClose = document.getElementById('rules-close');
            const ruleNavButtons = rulesModal?.querySelectorAll('.rule-nav-btn');
            const ruleSections = rulesModal?.querySelectorAll('.rule-section');
            const rulesPrevBtn = document.getElementById('rules-prev');
            const rulesNextBtn = document.getElementById('rules-next');
            const rulesIndicator = document.getElementById('rules-indicator');

            const ruleKeys = ['ov','setup','roles','flow','powers','legislative','win','ref'];
            function getActiveIndex() {
                let idx = 0;
                ruleSections?.forEach((sec, i) => { if (sec.classList.contains('active')) idx = i; });
                return idx;
            }
            function setActiveByIndex(idx) {
                const clamped = Math.max(0, Math.min((ruleSections?.length || 1) - 1, idx));
                const targetId = `${ruleKeys[clamped]}-section`;
                // switch sections
                ruleSections?.forEach(sec => sec.classList.toggle('active', sec.id === targetId));
                // switch top nav active state
                ruleNavButtons?.forEach((b) => {
                    const k = b.getAttribute('data-section');
                    b.classList.toggle('active', `${k}-section` === targetId);
                });
                // update indicator
                if (rulesIndicator) rulesIndicator.textContent = `${clamped + 1}/${ruleSections?.length || 1}`;
                // scroll top of modal body for new section
                const body = document.getElementById('rules-body');
                if (body) body.scrollTo({ top: 0, behavior: 'smooth' });
            }
                    function openRulesModal() { if (rulesModal) { rulesModal.style.display = 'flex'; setRoleBannerVisibility(false); } }
        function closeRulesModal() { if (rulesModal) { rulesModal.style.display = 'none'; setRoleBannerVisibility(true); } }
        
        // Role overlay functions
        function openRoleOverlay() {
            console.log('ðŸš€ openRoleOverlay called');
            const roleOverlay = document.getElementById('role-overlay');
            const roleText = document.getElementById('role-text');
            const membershipBtn = document.getElementById('membership-btn');
            const roleBtn = document.getElementById('role-btn');
            const compatriotsBtn = document.getElementById('compatriots-btn');
            const doneBtn = document.getElementById('role-done-btn');
            
            console.log('ðŸ” Found elements:', {
                roleOverlay: !!roleOverlay,
                roleText: !!roleText,
                membershipBtn: !!membershipBtn,
                roleBtn: !!roleBtn,
                compatriotsBtn: !!compatriotsBtn,
                doneBtn: !!doneBtn
            });
            
            if (!roleOverlay || !roleText || !membershipBtn || !roleBtn || !compatriotsBtn || !doneBtn) {
                console.error('Role modal elements not found');
                return;
            }
            
            // Get current player's data
            const gameId = getGameId();
            const youId = computeYouId(gameId);
            const youPlayer = (latestPlayers || []).find(p => p && p.id === youId);
            const game = latestGame;
            
            if (!youPlayer || !game) {
                roleText.textContent = 'Player not found or game not loaded';
                roleText.style.color = '#666';
                // Disable all action buttons
                membershipBtn.disabled = true;
                roleBtn.disabled = true;
                compatriotsBtn.disabled = true;
                return;
            }
            
            // Additional validation for game state
            if (game.state !== 'playing') {
                roleText.textContent = 'Game not started yet';
                roleText.style.color = '#666';
                // Disable all action buttons
                membershipBtn.disabled = true;
                roleBtn.disabled = true;
                compatriotsBtn.disabled = true;
                return;
            }
            
            // Set up button states and permissions
            console.log('ðŸŽ¯ Setting up button permissions for player:', youPlayer?.role + ' (' + youPlayer?.party + ')');
            setupButtonPermissions(youPlayer, game, membershipBtn, roleBtn, compatriotsBtn);
            
            // Set up event listeners
            membershipBtn.onclick = () => showMembership(youPlayer, roleText, membershipBtn);
            roleBtn.onclick = () => showRole(youPlayer, roleText, roleBtn);
            compatriotsBtn.onclick = () => {
                if (!compatriotsBtn.disabled) {
                    showCompatriots(youPlayer, game, roleText);
                }
            };
            
            // Set up a retry mechanism for permissions in case game data is still loading
            let retryCount = 0;
            const maxRetries = 3;
            const retryPermissions = () => {
                if (retryCount < maxRetries && (!game.playerCount || game.playerCount <= 0)) {
                    retryCount++;
                    console.log(`Retrying permissions setup (attempt ${retryCount}/${maxRetries})`);
                    setTimeout(() => {
                        if (latestGame && latestGame.playerCount) {
                            setupButtonPermissions(youPlayer, latestGame, membershipBtn, roleBtn, compatriotsBtn);
                        } else if (retryCount < maxRetries) {
                            retryPermissions();
                        }
                    }, 1000 * retryCount); // Exponential backoff
                }
            };
            retryPermissions();
            doneBtn.onclick = () => {
                roleOverlay.style.display = 'none';
                setRoleBannerVisibility(true);
            };
            
            // Start with hidden role
            roleText.textContent = 'Hidden';
            roleText.style.color = '#000';
            
            // Reset buttons to censored state
            membershipBtn.textContent = 'ðŸ›ï¸ View Membership';
            roleBtn.textContent = 'ðŸ‘ï¸ View Role';
            membershipBtn.style.background = 'rgba(241, 230, 178, 0.8)';
            roleBtn.style.background = 'var(--highlight-cream)';
            membershipBtn.style.borderColor = 'var(--propaganda-black)';
            roleBtn.style.borderColor = 'var(--propaganda-black)';
            
            // Clear any existing help text
            const existingHelpText = roleText.querySelector('div[style*="font-style: italic"]');
            if (existingHelpText) {
                existingHelpText.remove();
            }
            

            
            // Show overlay with smooth transition
            roleOverlay.style.display = 'flex';
            roleOverlay.style.animation = 'fadeIn 0.3s ease-in-out';
            setRoleBannerVisibility(false);
        }
        
        function closeRoleOverlay() {
            const roleOverlay = document.getElementById('role-overlay');
            if (roleOverlay) {
                roleOverlay.style.display = 'none';
                setRoleBannerVisibility(true);
            }
        }
        
        function refreshRoleOverlayPermissions() {
            // Only refresh if the role overlay is currently open
            const roleOverlay = document.getElementById('role-overlay');
            if (!roleOverlay || roleOverlay.style.display === 'none') {
                return;
            }
            
            const membershipBtn = document.getElementById('membership-btn');
            const roleBtn = document.getElementById('role-btn');
            const compatriotsBtn = document.getElementById('compatriots-btn');
            
            if (!membershipBtn || !roleBtn || !compatriotsBtn) {
                return;
            }
            
            const gameId = getGameId();
            const youId = computeYouId(gameId);
            const youPlayer = (latestPlayers || []).find(p => p && p.id === youId);
            const game = latestGame;
            
            if (youPlayer && game) {
                console.log('Refreshing role overlay permissions:', {
                    gameId,
                    youId,
                    youPlayerRole: youPlayer.role,
                    youPlayerParty: youPlayer.party,
                    gameState: game.state,
                    gamePlayerCount: game.playerCount,
                    latestPlayersLength: latestPlayers.length
                });
                setupButtonPermissions(youPlayer, game, membershipBtn, roleBtn, compatriotsBtn);
                

                
                // Clear any existing help text
                const roleText = document.getElementById('role-text');
                if (roleText) {
                    const existingHelpText = roleText.querySelector('div[style*="font-style: italic"]');
                    if (existingHelpText) {
                        existingHelpText.remove();
                    }
                }
            }
        }
        
        // New core functions for the three-button role modal
        function setupButtonPermissions(youPlayer, game, membershipBtn, roleBtn, compatriotsBtn) {
            console.log('ðŸ” setupButtonPermissions called with:', {
                youPlayer: youPlayer?.role + ' (' + youPlayer?.party + ')',
                gamePlayerCount: game?.playerCount,
                latestPlayersLength: (latestPlayers || []).length
            });
            
            // Ensure we have a reliable player count
            let playerCount = game.playerCount;
            if (!playerCount || playerCount <= 0) {
                playerCount = (latestPlayers || []).length;
                // If still no valid count, try to get it from the game document
                if (!playerCount || playerCount <= 0) {
                    console.warn('No valid player count found, defaulting to 5');
                    playerCount = 5; // Default fallback
                }
            }
            
            // Log the current state for debugging
            console.log('Setting up button permissions:', {
                gamePlayerCount: game.playerCount,
                fallbackPlayerCount: playerCount,
                latestPlayersLength: latestPlayers.length,
                gameState: game.state,
                youPlayerRole: youPlayer.role,
                youPlayerParty: youPlayer.party
            });
            
            // Additional validation for game state
            if (!game || game.state !== 'playing') {
                console.warn('Game not in playing state, disabling comrades button');
                compatriotsBtn.disabled = true;
                compatriotsBtn.style.opacity = '0.6';
                compatriotsBtn.title = 'Game not started yet';
                return;
            }
            
            // Ensure we have valid player data
            if (!latestPlayers || latestPlayers.length === 0) {
                console.warn('No players loaded yet, disabling comrades button');
                compatriotsBtn.disabled = true;
                compatriotsBtn.style.opacity = '0.6';
                compatriotsBtn.title = 'Player data not loaded yet';
                return;
            }
            
            const isFascist = (youPlayer.party || '').toString().toUpperCase() === 'FASCIST' || 
                              (youPlayer.role || '').toString().toUpperCase() === 'FASCIST';
            
            // Debug logging to help troubleshoot
            console.log('setupButtonPermissions debug:', {
                playerCount,
                isFascist,
                party: youPlayer.party,
                role: youPlayer.role,
                partyUpper: (youPlayer.party || '').toString().toUpperCase(),
                roleUpper: (youPlayer.role || '').toString().toUpperCase(),
                gamePlayerCount: game.playerCount,
                latestPlayersLength: (latestPlayers || []).length,
                gameState: game.state,
                gameId: game.id
            });
            
            // Membership and role start enabled but censored (showing placeholder text)
            membershipBtn.disabled = false;
            roleBtn.disabled = false;
            membershipBtn.style.opacity = '1';
            roleBtn.style.opacity = '1';
            membershipBtn.title = 'Click to reveal your party membership';
            roleBtn.title = 'Click to reveal your secret role';
            
            // Comrades button visibility and permissions
            const roleActionsMain = document.querySelector('.role-actions-main');
            console.log('ðŸ” Found roleActionsMain:', !!roleActionsMain);
            
            if (isFascist) {
                console.log('ðŸŽ¯ Player is Fascist, checking player count:', playerCount);
                // Show comrades button for Fascists at 5+ players
                // At 5-6 players: All Fascists (including Hitler) know each other
                // At 7+ players: Fascists know each other, but Hitler doesn't know them
                if (playerCount >= 5) {
                    console.log('âœ… Enabling comrades button for Fascist at', playerCount, 'players');
                    compatriotsBtn.style.removeProperty('display');
                    compatriotsBtn.disabled = false;
                    compatriotsBtn.style.opacity = '1';
                    compatriotsBtn.title = 'View your Fascist allies';
                    roleActionsMain?.classList.remove('comrades-hidden');
                    console.log('ðŸ”§ Button state after enabling:', {
                        display: compatriotsBtn.style.display,
                        disabled: compatriotsBtn.disabled,
                        opacity: compatriotsBtn.style.opacity,
                        roleActionsMainClasses: roleActionsMain?.classList.toString()
                    });
                    
                    // Clear any existing help text
                    const roleText = document.getElementById('role-text');
                    if (roleText) {
                        const helpText = roleText.querySelector('div[style*="font-style: italic"]');
                        if (helpText) {
                            helpText.remove();
                        }
                    }
                } else {
                    // Hide button completely for games with less than 5 players
                    console.log('âŒ Hiding comrades button for Fascist at', playerCount, 'players (need 5+ players)');
                    compatriotsBtn.style.display = 'none';
                    roleActionsMain?.classList.add('comrades-hidden');
                }
            } else {
                // Show comrades button for Liberals with fun message
                console.log('ðŸŽ­ Enabling comrades button for Liberal player');
                compatriotsBtn.style.removeProperty('display');
                compatriotsBtn.disabled = false;
                compatriotsBtn.style.opacity = '1';
                compatriotsBtn.title = 'See what Liberals see (hint: nothing!)';
                roleActionsMain?.classList.remove('comrades-hidden');
            }
            
            // Add visual feedback for button states
            membershipBtn.title = 'Click to reveal your party membership';
            roleBtn.title = 'Click to reveal your secret role';
        }
        
        // Helper function to close all views and reset to hidden state
        function closeAllViews(roleText) {
            // Clear any existing help text
            const existingHelpText = roleText.querySelector('div[style*="font-style: italic"]');
            if (existingHelpText) {
                existingHelpText.remove();
            }
            
            // Reset to hidden state
            roleText.textContent = 'Hidden';
            roleText.style.color = '#000';
            
            // Reset button states back to original
            const membershipBtn = document.getElementById('membership-btn');
            const roleBtn = document.getElementById('role-btn');
            
            if (membershipBtn) {
                membershipBtn.textContent = 'ðŸ›ï¸ View Membership';
                membershipBtn.style.background = 'rgba(0, 174, 239, 0.1)';
                membershipBtn.style.borderColor = 'var(--liberal-blue)';
            }
            
            if (roleBtn) {
                roleBtn.textContent = 'ðŸ‘ï¸ View Role';
                roleBtn.style.background = 'var(--highlight-cream)';
                roleBtn.style.borderColor = 'var(--propaganda-black)';
            }
        }
        
        function showMembership(youPlayer, roleText, membershipBtn) {
            const party = (youPlayer.party || '').toString().toUpperCase();
            
            // Check if membership is currently shown or hidden
            const isCurrentlyShown = roleText.textContent.includes('Party:') && 
                                   !roleText.textContent.includes('Hidden') &&
                                   !roleText.textContent.includes('Your Fascist Comrades:') &&
                                   !roleText.textContent.includes('No other Fascist players');
            
            if (isCurrentlyShown) {
                // Hide membership - return to hidden state
                roleText.textContent = 'Hidden';
                roleText.style.color = '#000';
                membershipBtn.textContent = 'ðŸ›ï¸ View Membership';
                membershipBtn.style.background = 'rgba(0, 174, 239, 0.1)';
                membershipBtn.style.borderColor = 'var(--liberal-blue)';
            } else {
                // Close any other views first
                closeAllViews(roleText);
                
                // Show membership
                roleText.textContent = `Party: ${party}`;
                
                // Set colors based on party (same color scheme as role text)
                if (party === 'FASCIST') {
                    roleText.style.color = '#DA291C'; // Fascist red
                    membershipBtn.style.background = 'rgba(218, 41, 28, 0.1)';
                    membershipBtn.style.borderColor = '#DA291C';
                } else {
                    roleText.style.color = '#00AEEF'; // Liberal blue
                    membershipBtn.style.background = 'rgba(0, 174, 239, 0.1)';
                    membershipBtn.style.borderColor = 'var(--liberal-blue)';
                }
                
                membershipBtn.textContent = 'ðŸ™ˆ Hide Membership';
            }
            

            
            // Add subtle animation
            roleText.style.animation = 'none';
            roleText.offsetHeight; // Trigger reflow
            roleText.style.animation = 'fadeIn 0.3s ease-in-out';
        }
        
        function showRole(youPlayer, roleText, roleBtn) {
            const role = (youPlayer.role || '').toString().toUpperCase();
            const party = (youPlayer.party || '').toString().toUpperCase();
            
            // Check if role is currently hidden or shown
            const isCurrentlyHidden = roleText.textContent === 'Hidden' || 
                                    roleText.textContent.includes('Party:') ||
                                    roleText.textContent.includes('Your Fascist Comrades:') ||
                                    roleText.textContent.includes('No other Fascist players');
            
            if (isCurrentlyHidden) {
                // Close any other views first
                closeAllViews(roleText);
                
                const label = role ? `${role}${party && role !== party ? ' â€“ ' + party : ''}` : 'Not assigned yet';
                roleText.textContent = label;
                
                // Set colors based on role
                if (role === 'HITLER') roleText.style.color = '#DA291C';
                else if (party === 'FASCIST' || role === 'FASCIST') roleText.style.color = '#DA291C';
                else roleText.style.color = '#00AEEF';
                
                roleBtn.textContent = 'ðŸ™ˆ Hide Role';
                roleBtn.style.background = 'rgba(218, 41, 28, 0.1)';
                roleBtn.style.borderColor = '#DA291C';
            } else {
                roleText.textContent = 'Hidden';
                roleText.style.color = '#000';
                roleBtn.textContent = 'ðŸ‘ï¸ View Role';
                roleBtn.style.background = 'var(--highlight-cream)';
                roleBtn.style.borderColor = 'var(--propaganda-black)';
            }
            

            
            // Add subtle animation
            roleText.style.animation = 'none';
            roleText.offsetHeight; // Trigger reflow
            roleText.style.animation = 'fadeIn 0.3s ease-in-out';
        }
        
        function showCompatriots(youPlayer, game, roleText) {
            const isFascist = (youPlayer.party || '').toString().toUpperCase() === 'FASCIST' || 
                              (youPlayer.role || '').toString().toUpperCase() === 'FASCIST';
            
            // Close any other views first
            closeAllViews(roleText);
            
            if (isFascist) {
                // Handle Fascist players
                const fascistPlayers = (latestPlayers || []).filter(p => 
                    p && p.id !== youPlayer.id && 
                    ((p.party || '').toString().toUpperCase() === 'FASCIST' || 
                     (p.role || '').toString().toUpperCase() === 'FASCIST')
                );
                
                if (fascistPlayers.length === 0) {
                    roleText.textContent = 'No other Fascist players to reveal';
                    roleText.style.color = '#000';
                    
                    // Add explanation
                    const helpText = document.createElement('div');
                    helpText.style.fontSize = '0.75rem';
                    helpText.style.color = '#666';
                    helpText.style.marginTop = '8px';
                    helpText.style.fontStyle = 'italic';
                    helpText.textContent = 'This means you are the only Fascist player in the game.';
                    roleText.appendChild(helpText);
                } else {
                    const names = fascistPlayers.map(p => p.name || 'Unknown Player').join('\n');
                    roleText.textContent = `Your Fascist Comrades:\n${names}`;
                    roleText.style.color = '#DA291C';
                    
                    // Add explanation
                    const helpText = document.createElement('div');
                    helpText.style.fontSize = '0.75rem';
                    helpText.style.color = '#666';
                    helpText.style.marginTop = '8px';
                    helpText.style.fontStyle = 'italic';
                    helpText.textContent = `You know ${fascistPlayers.length} other Fascist player${fascistPlayers.length === 1 ? '' : 's'}. Work together to pass Fascist policies!`;
                    roleText.appendChild(helpText);
                }
            } else {
                // Handle Liberal players with fun message
                roleText.textContent = 'ðŸ¤·â€â™‚ï¸ Your Liberal Comrades:';
                roleText.style.color = '#00AEEF';
                
                // Add fun explanation about not knowing teammates
                const helpText = document.createElement('div');
                helpText.style.fontSize = '0.75rem';
                helpText.style.color = '#666';
                helpText.style.marginTop = '8px';
                helpText.style.fontStyle = 'italic';
                helpText.textContent = 'You have no idea who your Liberal teammates are - and that\'s part of the fun! Trust your instincts and work together to pass Liberal policies! ðŸ•µï¸â€â™€ï¸';
                roleText.appendChild(helpText);
            }
            
            // Add subtle animation
            roleText.style.animation = 'none';
            roleText.offsetHeight; // Trigger reflow
            roleText.style.animation = 'fadeIn 0.3s ease-in-out';
        }
            if (rulesBtn) {
                rulesBtn.addEventListener('click', function(e) {
                    try { e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); } catch (_) {}
                    openRulesModal();
                }, { capture: true });
            }
            rulesClose?.addEventListener('click', closeRulesModal);
            rulesModal?.addEventListener('click', function(e) { if (e.target === rulesModal) closeRulesModal(); });
            
            // Role overlay close button event listener
            const roleClose = document.getElementById('role-close');
            roleClose?.addEventListener('click', closeRoleOverlay);
            
            // Role overlay click outside to close
            const roleOverlay = document.getElementById('role-overlay');
            roleOverlay?.addEventListener('click', function(e) { if (e.target === roleOverlay) closeRoleOverlay(); });
            // Tab switching inside rules modal
            ruleNavButtons?.forEach(btn => {
                btn.addEventListener('click', function() {
                    const target = this.getAttribute('data-section');
                    ruleNavButtons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    ruleSections?.forEach(sec => {
                        if (sec.id === `${target}-section`) sec.classList.add('active');
                        else sec.classList.remove('active');
                    });
                    // update indicator after manual switch
                    setActiveByIndex(getActiveIndex());
                });
            });
            // Prev/Next controls
            rulesPrevBtn?.addEventListener('click', function() {
                setActiveByIndex(getActiveIndex() - 1);
            });
            rulesNextBtn?.addEventListener('click', function() {
                setActiveByIndex(getActiveIndex() + 1);
            });
            // Initialize indicator when modal opens
            if (rulesIndicator) rulesIndicator.textContent = `${getActiveIndex() + 1}/${ruleSections?.length || 1}`;

            // Swipe gestures for mobile
            (function enableSwipe() {
                const body = document.getElementById('rules-body');
                if (!body) return;
                let touchStartX = 0, touchStartY = 0, touching = false, moved = false;
                body.addEventListener('touchstart', function(e) {
                    if (!e.touches || e.touches.length !== 1) return;
                    const t = e.touches[0];
                    touchStartX = t.clientX; touchStartY = t.clientY; touching = true; moved = false;
                }, { passive: true });
                body.addEventListener('touchmove', function(e) {
                    if (!touching || !e.touches || e.touches.length !== 1) return;
                    const t = e.touches[0];
                    const dx = t.clientX - touchStartX; const dy = t.clientY - touchStartY;
                    if (Math.abs(dx) > 24 && Math.abs(dx) > Math.abs(dy)) moved = true;
                }, { passive: true });
                body.addEventListener('touchend', function(e) {
                    if (!touching) return; touching = false;
                    const changed = e.changedTouches && e.changedTouches[0];
                    if (!changed) return;
                    const dx = changed.clientX - touchStartX; const dy = changed.clientY - touchStartY;
                    if (!moved || Math.abs(dx) < 48 || Math.abs(dx) < Math.abs(dy)) return;
                    if (dx < 0) setActiveByIndex(getActiveIndex() + 1); else setActiveByIndex(getActiveIndex() - 1);
                });
            })();

            // Make section headers tappable to jump to next section on mobile
            (function enableHeaderTap() {
                const mq = window.matchMedia('(max-width: 640px)');
                const headers = rulesModal?.querySelectorAll('.rule-section .section-header');
                headers?.forEach(h => {
                    h.style.cursor = mq.matches ? 'pointer' : '';
                    h.addEventListener('click', function() {
                        if (!mq.matches) return;
                        setActiveByIndex(getActiveIndex() + 1);
                    });
                });
            })();
            // Esc to close
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && rulesModal && rulesModal.style.display === 'flex') {
                    closeRulesModal();
                }
                if (e.key === 'Escape' && roleOverlay && roleOverlay.style.display === 'flex') {
                    closeRoleOverlay();
                }
            });

            // Menu modal handlers
            const menuBtn = document.getElementById('menu-btn');
            const menuModal = document.getElementById('menu-modal');
            const menuClose = document.getElementById('menu-close');
            const menuBody = document.getElementById('menu-body');
            const menuTitle = menuModal?.querySelector('.modal-title');

            function isSoundEnabled() {
                try { return localStorage.getItem('sh_sound_enabled') !== 'false'; } catch (_) { return true; }
            }
            function setSoundEnabled(enabled) {
                try { localStorage.setItem('sh_sound_enabled', enabled ? 'true' : 'false'); } catch (_) {}
            }
            function sanitizePlayerNameLocal(raw) {
                const trimmed = String(raw || '').trim();
                const collapsed = trimmed.replace(/\s+/g, ' ');
                const cleaned = collapsed.replace(/[^A-Za-z0-9 _\-'.]/g, '');
                return cleaned.slice(0, 24);
            }

            function renderMenu() {
                if (!menuBody) return;
                menuBody.innerHTML = '';
                const list = document.createElement('div');
                list.style.display = 'flex';
                list.style.flexDirection = 'column';
                list.style.gap = '8px';

                const leaveBtn = document.createElement('button');
                leaveBtn.id = 'leave-game-btn';
                leaveBtn.className = 'btn';
                leaveBtn.textContent = 'â†©ï¸ Leave Game (rejoin later)';
                list.appendChild(leaveBtn);

                const pauseBtn = document.createElement('button');
                pauseBtn.id = 'pause-toggle-btn';
                pauseBtn.className = 'btn';
                pauseBtn.textContent = localPaused ? 'â–¶ï¸ Resume Game' : 'â¸ï¸ Pause Game (AFK)';
                list.appendChild(pauseBtn);

                const soundBtn = document.createElement('button');
                soundBtn.id = 'sound-toggle-btn';
                soundBtn.className = 'btn';
                soundBtn.textContent = isSoundEnabled() ? 'ðŸ”‡ Disable Sound Effects' : 'ðŸ”Š Enable Sound Effects';
                list.appendChild(soundBtn);

                const nameBtn = document.createElement('button');
                nameBtn.id = 'change-name-btn';
                nameBtn.className = 'btn';
                nameBtn.textContent = 'âœï¸ Change Name';
                list.appendChild(nameBtn);

                const repairBtn = document.createElement('button');
                repairBtn.id = 'repair-game-btn';
                repairBtn.className = 'btn';
                repairBtn.textContent = 'ðŸ”§ Repair Game State';
                list.appendChild(repairBtn);

                const quitBtn = document.createElement('button');
                quitBtn.id = 'quit-game-btn';
                quitBtn.className = 'btn';
                quitBtn.textContent = 'âš ï¸ Quit Game for Everyone';
                list.appendChild(quitBtn);

                // Add duplicate game button only for host (seat 1)
                const you = youPlayerDoc();
                if (you && you.seat === 1) {
                    const duplicateBtn = document.createElement('button');
                    duplicateBtn.id = 'duplicate-game-btn';
                    duplicateBtn.className = 'btn';
                    duplicateBtn.textContent = 'ðŸ”„ End and Duplicate Game';
                    list.appendChild(duplicateBtn);
                }

                menuBody.appendChild(list);
            }

            function openMenuModal() {
                renderMenu();
                try {
                    const you = youPlayerDoc();
                    const yourName = you ? (you.name || 'Player') : 'Player';
                    if (menuTitle) menuTitle.textContent = `Menu â€” ${yourName}`;
                } catch (_) {}
                if (menuModal) menuModal.style.display = 'flex';
                setRoleBannerVisibility(false);
            }
            function closeMenuModal() { if (menuModal) { menuModal.style.display = 'none'; setRoleBannerVisibility(true); } }
            if (menuBtn) {
                // Use capture and stop propagation to avoid other handlers firing
                menuBtn.addEventListener('click', function(e) {
                    try { e.preventDefault(); e.stopImmediatePropagation(); e.stopPropagation(); } catch (_) {}
                    openMenuModal();
                }, { capture: true });
            }
            menuClose?.addEventListener('click', closeMenuModal);
            menuModal?.addEventListener('click', function(e) { if (e.target === menuModal) closeMenuModal(); });

            // (Removed global delegation that could cause unintended opens)

            // Menu actions (delegated)
            menuBody?.addEventListener('click', async function(e) {
                const t = e.target;
                if (!(t && t.matches && t.matches('button'))) return;
                const youId = computeYouId(gid);
                const youDoc = (latestPlayers || []).find(p => p && p.id === youId) || null;
                const yourName = youDoc ? (youDoc.name || 'Player') : 'Player';

                if (t.id === 'leave-game-btn') {
                    try {
                        if (youId) {
                            try { await updateDoc(doc(db, 'games', gid, 'players', youId), { uid: null, leftAt: serverTimestamp(), updatedAt: serverTimestamp() }); } catch (_) {}
                            try { await logPublic(gid, `${yourName} left the game`, { type: 'leave', actorId: youId }); } catch (_) {}
                        }
                        try { sessionStorage.removeItem(`sh_playerId_${gid}`); } catch (_) {}
                    } finally {
                        closeMenuModal();
                        window.location.href = `./join.html?game=${encodeURIComponent(gid)}`;
                    }
                    return;
                }

                if (t.id === 'quit-game-btn') {
                    const ok = confirm('This will end the game for everyone. Are you sure?');
                    if (!ok) return;
                    try {
                        await updateDoc(doc(db, 'games', gid), { state: 'cancelled', updatedAt: serverTimestamp() });
                        try { await logPublic(gid, `Game ended by ${yourName}`, { type: 'end', actorId: youId || null }); } catch (_) {}
                    } catch (err) {
                        console.error('Failed to end game', err);
                    } finally {
                        closeMenuModal();
                        window.location.href = '../index.html';
                    }
                    return;
                }

                if (t.id === 'pause-toggle-btn') {
                    localPaused = !localPaused;
                    try { localStorage.setItem(`sh_paused_${gid}`, localPaused ? 'true' : 'false'); } catch (_) {}
                    try {
                        if (localPaused) await logPublic(gid, `${yourName} is AFK`, { type: 'status', actorId: youId || null });
                        else await logPublic(gid, `${yourName} returned`, { type: 'status', actorId: youId || null });
                    } catch (_) {}
                    renderMenu();
                    renderActions(gid);
                    return;
                }

                if (t.id === 'sound-toggle-btn') {
                    const newState = !isSoundEnabled();
                    setSoundEnabled(newState);
                    renderMenu();
                    return;
                }

                if (t.id === 'change-name-btn') {
                    const currentName = youDoc ? (youDoc.name || '') : '';
                    const input = prompt('Enter your new name (max 24 chars):', currentName);
                    if (input === null) return;
                    const cleaned = sanitizePlayerNameLocal(input);
                    if (!cleaned) return;
                    if (!youId) return;
                    try {
                        await updateDoc(doc(db, 'games', gid, 'players', youId), { name: cleaned, updatedAt: serverTimestamp() });
                        try { await logPublic(gid, `${currentName || 'Player'} is now ${cleaned}`, { type: 'rename', actorId: youId }); } catch (_) {}
                    } catch (err) {
                        console.error('Failed to change name', err);
                    }
                    closeMenuModal();
                    return;
                }

                if (t.id === 'repair-game-btn') {
                    try {
                        repairBtn.disabled = true;
                        repairBtn.textContent = 'ðŸ”§ Repairing...';
                        
                        const repaired = await repairGameState(gid);
                        
                        if (repaired) {
                            repairBtn.textContent = 'âœ… Repaired!';
                            setTimeout(() => {
                                repairBtn.textContent = 'ðŸ”§ Repair Game State';
                                repairBtn.disabled = false;
                            }, 2000);
                        } else {
                            repairBtn.textContent = 'âœ… No Issues Found';
                            setTimeout(() => {
                                repairBtn.textContent = 'ðŸ”§ Repair Game State';
                                repairBtn.disabled = false;
                            }, 2000);
                        }
                        
                        // Don't close modal - let user see the result
                    } catch (err) {
                        console.error('Game repair failed:', err);
                        repairBtn.textContent = 'âŒ Repair Failed';
                        repairBtn.disabled = false;
                        setTimeout(() => {
                            repairBtn.textContent = 'ðŸ”§ Repair Game State';
                        }, 3000);
                    }
                    return;
                }

                if (t.id === 'duplicate-game-btn') {
                    const ok = confirm('This will end the current game and create a new one with the same players. Are you sure?');
                    if (!ok) return;
                    
                    try {
                        // Collect current game data
                        const currentGame = latestGame;
                        const currentPlayers = latestPlayers || [];
                        
                        // Validate we have enough players
                        const validPlayers = currentPlayers.filter(p => p && p.name && p.name.trim());
                        if (validPlayers.length < 5) {
                            alert('Cannot duplicate game: Need at least 5 valid player names.');
                            return;
                        }
                        
                        // Sort players by seat to maintain order
                        const sortedPlayers = validPlayers
                            .sort((a, b) => (a.seat || 0) - (b.seat || 0))
                            .map(p => p.name.trim());
                        
                        // End the current game
                        await updateDoc(doc(db, 'games', gid), { 
                            state: 'cancelled', 
                            updatedAt: serverTimestamp() 
                        });
                        
                        try { 
                            await logPublic(gid, `Game ended by ${yourName} to duplicate with same players`, { 
                                type: 'end', 
                                actorId: youId || null 
                            }); 
                        } catch (_) {}
                        
                        // Close modal and redirect to create page with pre-filled data
                        closeMenuModal();
                        
                        // Build URL with game data
                        const params = new URLSearchParams();
                        params.set('duplicate', 'true');
                        params.set('gameName', currentGame?.name || 'Secret Hitler Game');
                        params.set('playerCount', String(sortedPlayers.length));
                        params.set('playerNames', sortedPlayers.join(','));
                        
                        // Note: Host password is not preserved for security reasons
                        // Users will need to set a new password if desired
                        
                        // Redirect to create page
                        window.location.href = `../pages/create.html?${params.toString()}`;
                        
                    } catch (err) {
                        console.error('Failed to duplicate game:', err);
                        alert('Failed to duplicate game. Please try again.');
                    }
                    return;
                }
            });

            if (!gid) { setStatus('', 'Missing game id'); hidePreloader(); return; }

            const gameRef = doc(db, 'games', gid);
            let gameReady = false;
            let playersReady = false;
            function maybeHide() {
                if (gameReady && playersReady) hidePreloader();
            }
            const snap = await getDoc(gameRef);
            if (!snap.exists()) { setStatus(gid, 'Game not found'); hidePreloader(); return; }
            setStatus(gid, 'Game in progress');

            onSnapshot(gameRef, (s) => {
                latestGame = s.exists() ? s.data() : null;
                if (!latestGame) { setStatus(gid, 'Game unavailable'); hidePreloader(); return; }
                if (latestGame.state === 'cancelled') { 
                    setStatus(gid, 'Game cancelled'); 
                    hidePreloader();
                    // Redirect all players to join page when game is cancelled
                    try { 
                        alert('This game has been ended. You can join a new game or rejoin this one.'); 
                    } catch (_) {}
                    window.location.href = `./join.html?game=${encodeURIComponent(gid)}`;
                    return;
                }
                
                // Initialize discard pile count from game state
                const discardCount = calculateDiscardCountFromGameState(latestGame);
                setDiscardCount(discardCount);
                
                // Initialize table spread count from game state
                const tableSpreadCount = calculateTableSpreadCountFromGameState(latestGame);
                setTableSpreadCount(tableSpreadCount);
                
                // Update player strip highlights if ids available
                renderPlayers(playersStrip, latestPlayers.map(p => ({
                    ...p,
                    isPresident: latestGame && (latestGame.currentPresidentPlayerId === p.id),
                    isChancellor: latestGame && (latestGame.currentChancellorPlayerId === p.id)
                })));
                // Update policy counters and election tracker if present
                updateFromGame(latestGame);
                            // Update floating role banner for this device
                updateRoleBanner(latestGame, gid);
                updateRoleEnvelope(latestGame, gid);
                
                // Refresh role overlay permissions if it's currently open
                refreshRoleOverlayPermissions();
                // Update actions (nomination UI etc.)
                renderActions(gid);
                // Attempt resolve vote if complete
                maybeResolveElectionVote(gid);
                
                // Reset nomination flag when we detect the phase has changed from nomination to voting
                if (latestGame && latestGame.nominatedChancellorPlayerId && isNominating) {
                    // We've moved from nomination to voting phase, reset the flag
                    isNominating = false;
                }
                
                // Check for game issues and show repair button if needed
                if (latestPlayers && latestPlayers.length > 0) {
                    const issues = detectGameIssues(gid, latestGame, latestPlayers);
                    const repairBtn = document.getElementById('repair-game-main-btn');
                    if (repairBtn) {
                        if (issues.length > 0) {
                            repairBtn.style.display = 'block';
                            repairBtn.title = `Repair ${issues.length} detected issues`;
                        } else {
                            repairBtn.style.display = 'none';
                        }
                    }
                }
                
                gameReady = true;
                maybeHide();
            });

            // Subscribe to players ordered by orderIndex
            onSnapshot(query(collection(db, 'games', gid, 'players'), orderBy('orderIndex', 'asc')), (snapColl) => {
                latestPlayers = snapColl.docs.map(d => ({ id: d.id, ...d.data() })) || [];
                renderPlayers(playersStrip, latestPlayers.map(p => ({
                    ...p,
                    isPresident: latestGame && (latestGame.currentPresidentPlayerId === p.id),
                    isChancellor: latestGame && (latestGame.currentChancellorPlayerId === p.id)
                })));
                // Also refresh the banner after players load (needed for uid->id map)
                updateRoleBanner(latestGame, gid);
                updateRoleEnvelope(latestGame, gid);
                
                // Refresh role overlay permissions if it's currently open
                refreshRoleOverlayPermissions();
                
                // Re-render history when players (and thus your party) resolves
                renderHistory();
                // Update actions when players change (eligibility)
                renderActions(gid);
                // Attempt to resolve election when players/votes change
                maybeResolveElectionVote(gid);
                playersReady = true;
                maybeHide();
            });

            // Removed redirect for help-btn; now opens in-game modal

            // Presence heartbeat to keep this player's session marked active while playing
            heartbeatOnce(gid);
            if (heartbeatTimer) clearInterval(heartbeatTimer);
            heartbeatTimer = setInterval(function() { heartbeatOnce(gid); }, HEARTBEAT_INTERVAL_MS);
            
            // Start stuck game checker to automatically fix stuck games
            const stuckGameChecker = startStuckGameChecker(gid);
            
            document.addEventListener('visibilitychange', function() {
                if (document.visibilityState === 'visible') heartbeatOnce(gid);
            });
            window.addEventListener('beforeunload', function() { 
                heartbeatOnce(gid); 
                if (stuckGameChecker) clearInterval(stuckGameChecker);
            });

            // Background: surface AFK/return notifications from history as a brief status banner
            if (!afkUnsub) {
                try {
                    afkUnsub = onHistory(gid, (items) => {
                        try {
                            const youId = computeYouId(gid);
                            const visible = (items || []).filter(canSeeEvent);
                            const matches = visible.filter((evt) => {
                                const msg = String(evt && evt.message || '');
                                const isAfk = msg.includes(' is AFK');
                                const isReturn = msg.includes(' returned');
                                if (!(evt && evt.type === 'status' && (isAfk || isReturn))) return false;
                                if (youId && evt.actorId && evt.actorId === youId) return false; // don't notify yourself
                                return true;
                            });
                            if (!matches.length) return;
                            const newest = matches[matches.length - 1];
                            const order = Number(newest && newest.clientOrder || 0);
                            if (!(order > lastAfkSeenOrder)) return;
                            lastAfkSeenOrder = order;
                            // Update banner without re-logging to history
                            setStatus('', newest.message || '');
                        } catch (_) { /* no-op */ }
                    });
                } catch (_) { /* no-op */ }
            }
            window.addEventListener('beforeunload', function() { if (afkUnsub) { try { afkUnsub(); } catch (_) {} afkUnsub = null; } });

            // Nomination click handler (event delegation on document)
            document.addEventListener('click', async function(e) {
                const t = e.target;
                if (t && t.matches && t.matches('#open-nominate-btn')) {
                    e.preventDefault();
                    openNominationModal();
                    return;
                }
                if (!(t && t.matches && t.matches('button[data-nominate]'))) return;
                const candidateId = t.getAttribute('data-nominate');
                if (!candidateId) return;
                const youId = computeYouId(gid);
                const presId = latestGame && latestGame.currentPresidentPlayerId;
                if (!youId || !presId || youId !== presId) return; // Only president can nominate
                
                // Set flag to prevent modal re-opening during nomination
                isNominating = true;
                
                try {
                    await ensureAuth();
                    // Write nomination
                    await updateDoc(doc(db, 'games', gid), {
                        nominatedChancellorPlayerId: candidateId,
                        electionVotes: {},
                        voteResolution: null,
                        updatedAt: serverTimestamp()
                    });
                    // Log publicly
                    try {
                        const p = (latestPlayers || []).find(pp => pp && pp.id === candidateId);
                        await logPublic(gid, `President nominated ${p ? (p.name || 'a player') : 'a player'} as Chancellor`, { type: 'nomination', actorId: presId });
                        await logPublic(gid, 'Chancellor vote began', { type: 'vote' });
                    } catch (_) {}
                    // Close modal after successful nomination
                    const nominationModal = document.getElementById('nomination-modal');
                    if (nominationModal) {
                        // Force immediate hiding with CSS
                        nominationModal.style.display = 'none';
                        nominationModal.style.opacity = '0';
                        nominationModal.style.visibility = 'hidden';
                        nominationModal.style.pointerEvents = 'none';
                        
                        setRoleBannerVisibility(true);
                        
                        // Also clear the modal body to prevent any lingering content
                        const nominationBody = document.getElementById('nomination-body');
                        if (nominationBody) {
                            nominationBody.innerHTML = '';
                        }
                    }
                    
                    // Don't reset the flag here - let the Firebase listener handle it
                    // when the phase actually changes from nomination to voting
                    
                    // Safety fallback - reset flag after a very short delay if Firebase doesn't fire
                    setTimeout(() => {
                        if (isNominating) {
                            isNominating = false;
                        }
                    }, 100);
                } catch (err) {
                    console.error('Failed to nominate chancellor', err);
                    isNominating = false; // Reset flag on error
                }
            });

            // Voting click handler
            document.addEventListener('click', async function(e) {
                const t = e.target;
                // Toggle vote popover (support clicks on inner elements)
                const toggleBtn = (t && t.closest) ? t.closest('#vote-toggle-btn') : null;
                if (toggleBtn) {
                    e.preventDefault();
                    const pop = document.getElementById('vote-popover');
                    if (pop) {
                        pop.style.display = (pop.style.display === 'block') ? 'none' : 'block';
                    }
                    return;
                }
                // Submit vote (support clicks on inner elements)
                const voteBtn = (t && t.closest) ? t.closest('button[data-vote]') : null;
                if (!voteBtn) return;
                const vote = voteBtn.getAttribute('data-vote');
                if (!vote || (vote !== 'ja' && vote !== 'nein')) return;
                const youId = computeYouId(gid);
                if (!youId) return;
                const game = latestGame;
                if (!game || !game.nominatedChancellorPlayerId) return;
                try {
                    await ensureAuth();
                    await updateDoc(doc(db, 'games', gid), {
                        ["electionVotes." + youId]: vote,
                        updatedAt: serverTimestamp()
                    });
                    const pop = document.getElementById('vote-popover');
                    if (pop) pop.style.display = 'none';
                    
                    // Try to resolve the election immediately after this vote
                    maybeResolveElectionVote(gid);
                } catch (err) {
                    console.error('Failed to submit vote', err);
                }
            });

            // Helper: resolve election when enough votes are in to determine outcome
            let lastResolvedNomineeId = null;
            async function maybeResolveElectionVote(gameId) {
                try {
                    const game = latestGame;
                    if (!game) return;
                    const nomineeId = game.nominatedChancellorPlayerId || null;
                    if (!nomineeId) return;
                    const votes = (game.electionVotes && typeof game.electionVotes === 'object') ? game.electionVotes : {};
                    const aliveIds = (latestPlayers || []).filter(p => p && p.alive !== false).map(p => p.id);
                    const totalVoters = aliveIds.length || (latestPlayers || []).length;
                    const numVotes = Object.keys(votes).filter(k => aliveIds.includes(k)).length;
                    if (!totalVoters || numVotes === 0) return;
                    if (lastResolvedNomineeId === nomineeId) return;

                    // Check if we can resolve early based on current votes
                    const validVotes = Object.entries(votes).filter(([pid]) => aliveIds.includes(pid)).map(([,v]) => String(v));
                    const ja = validVotes.filter(v => v === 'ja').length;
                    const nein = validVotes.filter(v => v === 'nein').length;
                    
                    // Early resolution: if remaining votes can't change the outcome
                    // Note: 50/50 is a failed election (nein >= majority threshold)
                    const remainingVotes = totalVoters - numVotes;
                    const canPass = ja > (totalVoters / 2);
                    const canFail = nein >= Math.ceil((totalVoters + 1) / 2); // nein >= majority threshold
                    
                    // Log early resolution attempt
                    console.log(`Election check: ${ja} Ja, ${nein} Nein, ${numVotes}/${totalVoters} votes. Can pass: ${canPass}, Can fail: ${canFail}`);
                    
                    // If we can't resolve early, wait for more votes
                    if (!canPass && !canFail && numVotes < totalVoters) {
                        console.log('Waiting for more votes - outcome still uncertain');
                        return;
                    }
                    
                    if (canPass || canFail) {
                        console.log(`Early resolution possible: ${canPass ? 'PASS' : 'FAIL'} (${remainingVotes} votes remaining won\'t change outcome)`);
                    }

                    const gameRef = doc(db, 'games', gameId);
                    const outcome = await runTransaction(getFirestore(app), async (tx) => {
                        const snap = await tx.get(gameRef);
                        if (!snap.exists()) return null;
                        const g = snap.data();
                        const currentNominee = g.nominatedChancellorPlayerId || null;
                        if (!currentNominee || currentNominee !== nomineeId) return null;
                        const already = g.voteResolution && g.voteResolution.nomineeId === currentNominee && g.voteResolution.at;
                        if (already) return null;
                        const gvotes = (g.electionVotes && typeof g.electionVotes === 'object') ? g.electionVotes : {};
                        const aliveNow = (latestPlayers || []).filter(p => p && p.alive !== false).map(p => p.id);
                        const totalNow = aliveNow.length || (latestPlayers || []).length;
                        const validVotes = Object.entries(gvotes).filter(([pid]) => aliveNow.includes(pid)).map(([,v]) => String(v));
                        if (totalNow === 0) return null;
                        
                        // Use the early resolution values we calculated above
                        // Note: This may resolve before all players have voted if outcome is certain
                        const ja = validVotes.filter(v => v === 'ja').length;
                        const nein = validVotes.filter(v => v === 'nein').length;
                        const passed = ja > (totalNow / 2);
                        const payload = {
                            voteResolution: { nomineeId: currentNominee, ja, nein, passed, at: serverTimestamp() },
                            electionVotes: {},
                            updatedAt: serverTimestamp()
                        };
                        if (passed) {
                            payload.electionTracker = 0;
                            payload.currentChancellorPlayerId = currentNominee;
                            payload.nominatedChancellorPlayerId = null;
                            // Optional: set term limits for next nomination phase
                            payload.termLimitLastPresidentId = g.currentPresidentPlayerId || null;
                            payload.termLimitLastChancellorId = currentNominee;
                        } else {
                            payload.electionTracker = (typeof g.electionTracker === 'number' ? g.electionTracker : 0) + 1;
                            // Clear failed nominee
                            payload.nominatedChancellorPlayerId = null;
                        }
                        tx.update(gameRef, payload);
                        return { ja, nein, passed };
                    });

                    if (outcome) {
                        lastResolvedNomineeId = nomineeId;
                        console.log(`Election resolved: ${outcome.passed ? 'PASSED' : 'FAILED'} with ${outcome.ja} Ja / ${outcome.nein} Nein votes`);
                        try {
                            if (outcome.passed) {
                                await logPublic(gameId, `Election passed: ${outcome.ja} Ja / ${outcome.nein} Nein`, { type: 'vote' });
                            } else {
                                await logPublic(gameId, `Election failed: ${outcome.nein} Nein / ${outcome.ja} Ja`, { type: 'vote' });
                                await logPublic(gameId, 'Election tracker advanced by 1', { type: 'system' });
                            }
                        } catch (_) {}
                    }
                } catch (err) {
                    console.error('Failed to resolve election vote', err);
                }
            }

            // Debug button handler
            const debugBtn = document.getElementById('debug-btn');
            if (debugBtn) {
                debugBtn.addEventListener('click', function() {
                    debugGameState(gid);
                });
            }

        });

        // ===== DYNAMIC DISCARD PILE MODULE =====
        
        // Card configuration data - memorized visual order
        const DISCARD_CARD_CONFIG = [
            { translateY: -2, rotate: -15, zIndex: 2, className: 'policy-on-discard' },
            { translateY: -3, rotate: 12, zIndex: 3, className: 'policy-on-discard-top' },
            { translateY: -4, rotate: -8, zIndex: 4, className: 'policy-on-discard-2' },
            { translateY: -5, rotate: 18, zIndex: 5, className: 'policy-on-discard-3' },
            { translateY: -6, rotate: -22, zIndex: 6, className: 'policy-on-discard-4' },
            { translateY: -7, rotate: 6, zIndex: 7, className: 'policy-on-discard-5' },
            { translateY: -8, rotate: -14, zIndex: 8, className: 'policy-on-discard-6' },
            { translateY: -9, rotate: 20, zIndex: 9, className: 'policy-on-discard-7' },
            { translateY: -10, rotate: -10, zIndex: 10, className: 'policy-on-discard-8' },
            { translateY: -11, rotate: 16, zIndex: 11, className: 'policy-on-discard-9' },
            { translateY: -12, rotate: -25, zIndex: 12, className: 'policy-on-discard-10' }
        ];

        // Responsive scaling factors
        const RESPONSIVE_SCALES = {
            base: 1.0,
            small: 1.0,
            large: 1.0
        };

        // Current discard count
        let currentDiscardCount = 0;

        // Function to update the discard pile visualization
        function updateDiscardPileVisual(count) {
            const discardStack = document.querySelector('.card-stack.discard');
            if (!discardStack) return;

            // Remove existing policy cards (keep the base discard card)
            const existingPolicyCards = discardStack.querySelectorAll('.stack-card:not(.is-discard)');
            existingPolicyCards.forEach(card => card.remove());

            // Add new policy cards based on count
            for (let i = 0; i < count && i < DISCARD_CARD_CONFIG.length; i++) {
                const config = DISCARD_CARD_CONFIG[i];
                const card = document.createElement('div');
                card.className = `stack-card ${config.className}`;
                card.style.backgroundImage = 'url(../images/policy-back.png)';
                card.style.transform = `translateY(${config.translateY}px) rotate(${config.rotate}deg) scale(${RESPONSIVE_SCALES.base})`;
                card.style.transformOrigin = '50% 50%';
                card.style.zIndex = config.zIndex;
                
                discardStack.appendChild(card);
            }

            // Update responsive styles
            updateResponsiveDiscardStyles(count);
            
            // Update count display
            updateCountDisplay(count);
        }

        // Function to update responsive styles for different screen sizes
        function updateResponsiveDiscardStyles(count) {
            // Remove existing responsive styles
            const existingStyles = document.getElementById('dynamic-discard-styles');
            if (existingStyles) existingStyles.remove();

            // Create new style element
            const style = document.createElement('style');
            style.id = 'dynamic-discard-styles';
            
            let css = '';
            
            // Small screens (â‰¤640px)
            css += '@media (max-width: 640px) {';
            for (let i = 0; i < count && i < DISCARD_CARD_CONFIG.length; i++) {
                const config = DISCARD_CARD_CONFIG[i];
                css += `.card-stack.discard .stack-card.${config.className} { transform: translateY(${config.translateY}px) rotate(${config.rotate}deg) scale(${RESPONSIVE_SCALES.small}) !important; }`;
            }
            css += '}';
            
            // Very small screens (â‰¤360px)
            css += '@media (max-width: 360px) {';
            for (let i = 0; i < count && i < DISCARD_CARD_CONFIG.length; i++) {
                const config = DISCARD_CARD_CONFIG[i];
                css += `.card-stack.discard .stack-card.${config.className} { transform: translateY(${config.translateY}px) rotate(${config.rotate}deg) scale(${RESPONSIVE_SCALES.small}) !important; }`;
            }
            css += '}';
            
            // Large screens (â‰¥768px)
            css += '@media (min-width: 768px) {';
            for (let i = 0; i < count && i < DISCARD_CARD_CONFIG.length; i++) {
                const config = DISCARD_CARD_CONFIG[i];
                // Scale up the translateY for larger screens
                const scaledTranslateY = Math.round(config.translateY * 1.6);
                css += `.card-stack.discard .stack-card.${config.className} { transform: translateY(${scaledTranslateY}px) rotate(${config.rotate}deg) scale(${RESPONSIVE_SCALES.large}) !important; }`;
            }
            css += '}';
            
            document.head.appendChild(style);
        }

        // Function to increment discard count (called when cards are discarded)
        async function incrementDiscardCount() {
            currentDiscardCount++;
            updateDiscardPileVisual(currentDiscardCount);
            
            // Decrease table spread count when cards are discarded
            decrementTableSpreadCount();
            
            // Persist the discard count to the database so it survives game state reloads
            try {
                const gameId = getGameId();
                if (gameId && latestGame) {
                    const gameRef = doc(db, 'games', gameId);
                    await updateDoc(gameRef, {
                        totalDiscardedCards: increment(1),
                        updatedAt: serverTimestamp()
                    });
                    console.log(`Discard count persisted to database: ${currentDiscardCount}`);
                }
            } catch (error) {
                console.error('Failed to persist discard count to database:', error);
            }
            
            console.log(`Discard count increased to: ${currentDiscardCount}`);
        }

        // Function to decrement discard count (called when deck is reshuffled)
        async function decrementDiscardCount() {
            if (currentDiscardCount > 0) {
                currentDiscardCount--;
                updateDiscardPileVisual(currentDiscardCount);
                
                // Update the database to reflect the decreased count
                try {
                    const gameId = getGameId();
                    if (gameId && latestGame) {
                        const gameRef = doc(db, 'games', gameId);
                        await updateDoc(gameRef, {
                            totalDiscardedCards: increment(-1),
                            updatedAt: serverTimestamp()
                        });
                        console.log(`Discard count decreased in database: ${currentDiscardCount}`);
                    }
                } catch (error) {
                    console.error('Failed to update discard count in database:', error);
                }
                
                console.log(`Discard count decreased to: ${currentDiscardCount}`);
            }
        }

        // Function to reset discard count (called when deck is reshuffled)
        async function resetDiscardCount() {
            currentDiscardCount = 0;
            updateDiscardPileVisual(currentDiscardCount);
            
            // Reset the cumulative discard count in the database when deck is reshuffled
            try {
                const gameId = getGameId();
                if (gameId && latestGame) {
                    const gameRef = doc(db, 'games', gameId);
                    await updateDoc(gameRef, {
                        totalDiscardedCards: 0,
                        presidentDiscardedCard: null,
                        chancellorDiscardedCard: null,
                        updatedAt: serverTimestamp()
                    });
                    console.log(`Discard count reset in database (deck reshuffled)`);
                }
            } catch (error) {
                console.error('Failed to reset discard count in database:', error);
            }
            
            console.log(`Discard count reset to 0 (deck reshuffled)`);
        }

        // Function to set discard count (called when game state is loaded)
        function setDiscardCount(count) {
            currentDiscardCount = Math.max(0, count);
            updateDiscardPileVisual(currentDiscardCount);
            console.log(`Discard count set to: ${currentDiscardCount}`);
        }

        // Function to calculate discard count from game state
        function calculateDiscardCountFromGameState(game) {
            if (!game) return 0;
            
            let count = 0;
            
            // Count president discarded cards
            if (game.presidentDiscardedCard) count++;
            if (game.presidentDiscardedCards && Array.isArray(game.presidentDiscardedCards)) {
                count += game.presidentDiscardedCards.length;
            }
            
            // Count chancellor discarded cards
            if (game.chancellorDiscardedCard) count++;
            if (game.chancellorDiscardedCards && Array.isArray(game.chancellorDiscardedCards)) {
                count += game.chancellorDiscardedCards.length;
            }
            
            // Count any other discarded cards from game history
            if (game.discardedCards && Array.isArray(game.discardedCards)) {
                count += game.discardedCards.length;
            }
            
            // Use cumulative discard count if available (this persists across turns)
            if (game.totalDiscardedCards && typeof game.totalDiscardedCards === 'number') {
                count = Math.max(count, game.totalDiscardedCards);
            }
            
            console.log(`Calculated discard count from game state: ${count}`);
            return count;
        }

        // Initialize discard pile with 0 cards
        document.addEventListener('DOMContentLoaded', function() {
            setDiscardCount(0);
            
            // Add test buttons for development (remove in production)
            addTestButtons();
        });

        // Function to add test buttons for development
        function addTestButtons() {
            const actionsCenter = document.querySelector('.actions-center');
            if (!actionsCenter) return;
            
            const testDiv = document.createElement('div');
            testDiv.style.marginTop = '10px';
            testDiv.style.textAlign = 'center';
            testDiv.innerHTML = `
                <button onclick="incrementDiscardCount().catch(console.error)" style="margin: 2px; padding: 4px 8px; font-size: 12px;">+1 Discard</button>
                <button onclick="decrementDiscardCount().catch(console.error)" style="margin: 2px; padding: 4px 8px; font-size: 12px;">-1 Discard</button>
                <button onclick="resetDiscardCount().catch(console.error)" style="margin: 2px; padding: 4px 8px; font-size: 12px;">Reset</button>
                <button onclick="forceRefreshDiscardPile()" style="margin: 2px; padding: 4px 8px; font-size: 12px;">ðŸ”„ Force Refresh</button>
                <span style="margin-left: 10px; font-size: 12px;">Count: <span id="discard-count-display">0</span></span>
            `;
            
            actionsCenter.appendChild(testDiv);
            
            // Update count display
            updateCountDisplay(currentDiscardCount);
        }

        // Function to update the count display
        function updateCountDisplay(count) {
            const countDisplay = document.getElementById('discard-count-display');
            if (countDisplay) {
                countDisplay.textContent = count;
            }
        }

        // Manual force refresh function for debugging
        function forceRefreshDiscardPile() {
            console.log('=== FORCE REFRESH DISCARD PILE ===');
            const gameId = getGameId();
            console.log('Game ID:', gameId);
            console.log('Latest Game:', latestGame);
            console.log('Current Discard Count:', currentDiscardCount);
            
            if (latestGame) {
                const calculatedCount = calculateDiscardCountFromGameState(latestGame);
                console.log('Calculated count from game state:', calculatedCount);
                console.log('Stored count in game:', latestGame.totalDiscardedCards);
                
                // Force update the visual
                setDiscardCount(calculatedCount);
                updateDiscardPileVisual(calculatedCount);
                updateCountDisplay(calculatedCount);
                
                console.log('Force refresh completed. New count:', calculatedCount);
            } else {
                console.log('No game data available');
            }
            console.log('=== END FORCE REFRESH ===');
        }
        
        // Make it globally accessible for console debugging
        window.forceRefreshDiscardPile = forceRefreshDiscardPile;
        
        // ===== END DYNAMIC DISCARD PILE MODULE =====

        // ===== DYNAMIC TABLE SPREAD MODULE =====
        
        // Table spread card configuration - memorized visual arrangement
        const TABLE_SPREAD_CONFIG = [
            { rotate: 18, className: 'table-card-1' },
            { rotate: 14, className: 'table-card-2' },
            { rotate: 10, className: 'table-card-3' },
            { rotate: 6, className: 'table-card-4' },
            { rotate: 3, className: 'table-card-5' },
            { rotate: 1, className: 'table-card-6' },
            { rotate: -1, className: 'table-card-7' },
            { rotate: -3, className: 'table-card-8' },
            { rotate: -6, className: 'table-card-9' },
            { rotate: -10, className: 'table-card-10' },
            { rotate: -14, className: 'table-card-11' },
            { rotate: -18, className: 'table-card-12' }
        ];

        // Current table spread count
        let currentTableSpreadCount = 0;

        // Function to update the table spread visualization
        function updateTableSpreadVisual(count) {
            const tableSpread = document.querySelector('.table-spread');
            if (!tableSpread) return;

            // Remove existing table cards
            const existingTableCards = tableSpread.querySelectorAll('.table-card');
            existingTableCards.forEach(card => card.remove());

            // Add new table cards based on count
            for (let i = 0; i < count && i < TABLE_SPREAD_CONFIG.length; i++) {
                const config = TABLE_SPREAD_CONFIG[i];
                const card = document.createElement('div');
                card.className = `table-card ${config.className}`;
                card.style.backgroundImage = 'url(../images/policy-back.png)';
                card.style.transform = `rotate(${config.rotate}deg)`;
                card.style.backgroundSize = 'cover';
                card.style.backgroundPosition = 'center';
                card.style.border = '3px solid var(--propaganda-black)';
                card.style.borderRadius = '6px';
                card.style.boxShadow = '0 4px 8px rgba(0,0,0,0.2), inset 0 0 0 3px rgba(241,230,178,0.6)';
                card.style.margin = '0 -18px';
                card.style.transformOrigin = '50% 100%';
                
                tableSpread.appendChild(card);
            }

            // Update responsive styles
            updateResponsiveTableSpreadStyles(count);
        }

        // Function to update responsive styles for different screen sizes
        function updateResponsiveTableSpreadStyles(count) {
            // Remove existing responsive styles
            const existingStyles = document.getElementById('dynamic-table-spread-styles');
            if (existingStyles) existingStyles.remove();

            // Create new style element
            const style = document.createElement('style');
            style.id = 'dynamic-table-spread-styles';
            
            let css = '';
            
            // Small screens (â‰¤640px)
            css += '@media (max-width: 640px) {';
            for (let i = 0; i < count && i < TABLE_SPREAD_CONFIG.length; i++) {
                const config = TABLE_SPREAD_CONFIG[i];
                css += `.table-spread .table-card.${config.className} { 
                    width: var(--play-card-w, 56px); 
                    height: var(--play-card-h, 82px); 
                    margin: 0 -18px; 
                    transform: rotate(${config.rotate}deg); 
                }`;
            }
            css += '}';
            
            // Very small screens (â‰¤360px)
            css += '@media (max-width: 360px) {';
            for (let i = 0; i < count && i < TABLE_SPREAD_CONFIG.length; i++) {
                const config = TABLE_SPREAD_CONFIG[i];
                css += `.table-spread .table-card.${config.className} { 
                    width: var(--play-card-w, 50px); 
                    height: var(--play-card-h, 74px); 
                    margin: 0 -20px; 
                    transform: rotate(${config.rotate}deg); 
                }`;
            }
            css += '}';
            
            // Large screens (â‰¥768px)
            css += '@media (min-width: 768px) {';
            for (let i = 0; i < count && i < TABLE_SPREAD_CONFIG.length; i++) {
                const config = TABLE_SPREAD_CONFIG[i];
                css += `.table-spread .table-card.${config.className} { 
                    width: var(--play-card-w, 72px); 
                    height: var(--play-card-h, 104px); 
                    margin: 0 -18px; 
                    transform: rotate(${config.rotate}deg); 
                }`;
            }
            css += '}';
            
            document.head.appendChild(style);
        }

        // Function to increment table spread count
        function incrementTableSpreadCount() {
            if (currentTableSpreadCount < TABLE_SPREAD_CONFIG.length) {
                currentTableSpreadCount++;
                updateTableSpreadVisual(currentTableSpreadCount);
                console.log(`Table spread count increased to: ${currentTableSpreadCount}`);
            }
        }

        // Function to decrement table spread count
        function decrementTableSpreadCount() {
            if (currentTableSpreadCount > 0) {
                currentTableSpreadCount--;
                updateTableSpreadVisual(currentTableSpreadCount);
                console.log(`Table spread count decreased to: ${currentTableSpreadCount}`);
            }
        }

        // Function to set table spread count
        function setTableSpreadCount(count) {
            currentTableSpreadCount = Math.max(0, Math.min(count, TABLE_SPREAD_CONFIG.length));
            updateTableSpreadVisual(currentTableSpreadCount);
            console.log(`Table spread count set to: ${currentTableSpreadCount}`);
        }

        // Function to calculate table spread count from game state
        function calculateTableSpreadCountFromGameState(game) {
            if (!game) return 0;
            
            console.log(`=== TABLE SPREAD CALCULATION ===`);
            console.log(`Full game object:`, game);
            
            // For now, let's use a simpler approach - just show the policy stack size
            // This should be the actual number of cards available to draw
            const policyStackSize = game.currentPolicyStack?.length || 0;
            console.log(`Using policy stack size directly: ${policyStackSize}`);
            
            // If no policy stack data, default to a reasonable number
            if (policyStackSize === 0) {
                console.log(`No policy stack data, defaulting to 8 cards`);
                return 8;
            }
            
            console.log(`================================`);
            return policyStackSize;
        }

        // Initialize table spread with default count
        document.addEventListener('DOMContentLoaded', function() {
            setTableSpreadCount(6); // Start with 6 cards
            
            // Update test buttons to include table spread controls
            updateTestButtons();
        });

        // Function to update test buttons to include table spread controls
        function updateTestButtons() {
            const testDiv = document.querySelector('.cards-area .test-buttons');
            if (!testDiv) return;
            
            // Add table spread controls
            const tableSpreadControls = document.createElement('div');
            tableSpreadControls.style.marginTop = '10px';
            tableSpreadControls.style.textAlign = 'center';
            tableSpreadControls.innerHTML = `
                <button onclick="incrementTableSpreadCount()" style="margin: 2px; padding: 4px 8px; font-size: 12px;">+1 Spread</button>
                <button onclick="decrementTableSpreadCount()" style="margin: 2px; padding: 4px 8px; font-size: 12px;">-1 Spread</button>
                <button onclick="setTableSpreadCount(6)" style="margin: 2px; padding: 4px 8px; font-size: 12px;">Reset Spread</button>
                <span style="margin-left: 10px; font-size: 12px;">Spread: <span id="table-spread-count-display">6</span></span>
            `;
            
            testDiv.appendChild(tableSpreadControls);
            
            // Update count display
            updateTableSpreadCountDisplay(currentTableSpreadCount);
        }

        // Function to update the table spread count display
        function updateTableSpreadCountDisplay(count) {
            const countDisplay = document.getElementById('table-spread-count-display');
            if (countDisplay) {
                countDisplay.textContent = count;
            }
        }

        // ===== END DYNAMIC TABLE SPREAD MODULE =====

        // Comprehensive game repair and diagnostic system
        async function repairGameState(gameId) {
            console.log('=== GAME REPAIR SYSTEM ACTIVATED ===');
            
            if (!gameId || !latestGame) {
                console.error('Cannot repair: missing game ID or game data');
                return false;
            }
            
            try {
                const gameRef = doc(db, 'games', gameId);
                const repairUpdates = {};
                let repairsApplied = 0;
                
                console.log('Analyzing game state for issues...');
                
                // 1. Fix discard pile inconsistencies
                if (repairDiscardPile(gameId, latestGame, repairUpdates)) {
                    repairsApplied++;
                }
                
                // 2. Fix stuck game phases
                if (repairStuckGamePhase(gameId, latestGame, repairUpdates)) {
                    repairsApplied++;
                }
                
                // 3. Fix player state inconsistencies
                if (repairPlayerStates(gameId, latestGame, latestPlayers, repairUpdates)) {
                    repairsApplied++;
                }
                
                // 4. Fix policy count inconsistencies
                if (repairPolicyCounts(gameId, latestGame, repairUpdates)) {
                    repairsApplied++;
                }
                
                // 5. Fix election tracker issues
                if (repairElectionTracker(gameId, latestGame, repairUpdates)) {
                    repairsApplied++;
                }
                
                // Apply all repairs if any were found
                if (repairsApplied > 0) {
                    repairUpdates.updatedAt = serverTimestamp();
                    repairUpdates.lastRepairAt = serverTimestamp();
                    repairUpdates.repairsApplied = repairsApplied;
                    
                    console.log(`Applying ${repairsApplied} repairs:`, repairUpdates);
                    await updateDoc(gameRef, repairUpdates);
                    
                    // Log the repair action
                    await logPublic(gameId, `Game automatically repaired: ${repairsApplied} issues fixed`, {
                        type: 'system_repair',
                        repairsApplied: repairsApplied
                    });
                    
                    // Refresh the visual discard pile after repair
                    if (repairUpdates.totalDiscardedCards !== undefined) {
                        console.log('Refreshing discard pile visual after repair');
                        setDiscardCount(repairUpdates.totalDiscardedCards);
                        
                        // Force a complete visual refresh
                        setTimeout(() => {
                            const newCount = repairUpdates.totalDiscardedCards;
                            console.log(`Force refreshing discard pile to show ${newCount} cards`);
                            updateDiscardPileVisual(newCount);
                            updateCountDisplay(newCount);
                        }, 100);
                    }
                    
                    console.log('Game repair completed successfully');
                    return true;
                } else {
                    console.log('No repairs needed - game state is healthy');
                    return false;
                }
                
            } catch (error) {
                console.error('Game repair failed:', error);
                return false;
            }
        }
        
        // Repair discard pile inconsistencies
        function repairDiscardPile(gameId, game, repairUpdates) {
            let needsRepair = false;
            
            console.log('=== DISCARD PILE REPAIR ANALYSIS ===');
            console.log('Game object:', game);
            console.log('President discarded card:', game.presidentDiscardedCard);
            console.log('Chancellor discarded card:', game.chancellorDiscardedCard);
            console.log('President discarded cards array:', game.presidentDiscardedCards);
            console.log('Chancellor discarded cards array:', game.chancellorDiscardedCards);
            console.log('Other discarded cards:', game.discardedCards);
            console.log('Total discarded cards (stored):', game.totalDiscardedCards);
            
            // Check if discard count is inconsistent with game state
            const calculatedDiscardCount = calculateDiscardCountFromGameState(game);
            const storedDiscardCount = game.totalDiscardedCards || 0;
            
            console.log('Calculated discard count:', calculatedDiscardCount);
            console.log('Stored discard count:', storedDiscardCount);
            
            if (calculatedDiscardCount !== storedDiscardCount) {
                console.log(`Discard pile inconsistency detected: calculated=${calculatedDiscardCount}, stored=${storedDiscardCount}`);
                
                // Use the calculated count as the source of truth
                repairUpdates.totalDiscardedCards = calculatedDiscardCount;
                
                // Also ensure individual discard fields are consistent
                if (game.presidentDiscardedCard && !game.presidentDiscardedCards) {
                    repairUpdates.presidentDiscardedCards = [game.presidentDiscardedCard];
                }
                if (game.chancellorDiscardedCard && !game.chancellorDiscardedCards) {
                    repairUpdates.chancellorDiscardedCards = [game.chancellorDiscardedCard];
                }
                
                needsRepair = true;
                console.log('Repair needed: true');
            } else {
                console.log('No discard pile repair needed');
            }
            
            console.log('=== END DISCARD PILE REPAIR ANALYSIS ===');
            return needsRepair;
        }
        
        // Repair stuck game phases
        function repairStuckGamePhase(gameId, game, repairUpdates) {
            let needsRepair = false;
            
            // Check for stuck completed phase
            if (game.policyPhase === 'completed' && game.enactedPolicy) {
                const timeSinceUpdate = game.updatedAt ? (Date.now() - game.updatedAt.toDate().getTime()) : 0;
                const isStuck = timeSinceUpdate > 10000; // 10 seconds
                
                if (isStuck) {
                    console.log('Stuck game phase detected - advancing to next government');
                    
                    // Clear policy phase artifacts
                    repairUpdates.policyPhase = null;
                    repairUpdates.enactedPolicy = null;
                    repairUpdates.presidentDrawnCards = [];
                    repairUpdates.currentChancellorPlayerId = null;
                    repairUpdates.nominatedChancellorPlayerId = null;
                    repairUpdates.voteResolution = null;
                    repairUpdates.electionVotes = {};
                    
                    // Set term limits for next turn
                    repairUpdates.termLimitLastChancellorId = game.currentChancellorPlayerId;
                    repairUpdates.termLimitLastPresidentId = game.currentPresidentPlayerId;
                    
                    // Find next president
                    const orderedAlive = (latestPlayers || [])
                        .filter(p => p && p.alive !== false)
                        .sort((a, b) => (a.orderIndex || 0) - (b.orderIndex || 0));
                    
                    if (orderedAlive.length > 0) {
                        const currentIndex = orderedAlive.findIndex(p => p.id === game.currentPresidentPlayerId);
                        const nextIndex = (currentIndex + 1) % orderedAlive.length;
                        const nextPresident = orderedAlive[nextIndex];
                        
                        repairUpdates.presidentIndex = nextIndex;
                        repairUpdates.currentPresidentPlayerId = nextPresident.id;
                    }
                    
                    needsRepair = true;
                }
            }
            
            return needsRepair;
        }
        
        // Repair player state inconsistencies
        function repairPlayerStates(gameId, game, players, repairUpdates) {
            let needsRepair = false;
            
            if (!players || players.length === 0) return false;
            
            // Check for players with missing orderIndex
            const playersNeedingOrder = players.filter(p => p && typeof p.orderIndex !== 'number');
            if (playersNeedingOrder.length > 0) {
                console.log(`${playersNeedingOrder.length} players missing orderIndex - fixing`);
                
                // Assign order indices based on current array order
                playersNeedingOrder.forEach((player, index) => {
                    const playerRef = doc(db, 'games', gameId, 'players', player.id);
                    updateDoc(playerRef, { orderIndex: index }).catch(console.error);
                });
                
                needsRepair = true;
            }
            
            // Check for dead players who shouldn't be dead
            const deadPlayers = players.filter(p => p && p.alive === false);
            if (deadPlayers.length > 0) {
                console.log(`${deadPlayers.length} dead players detected - this may be intentional`);
                // Don't auto-repair dead players as this could be legitimate game state
            }
            
            return needsRepair;
        }
        
        // Repair policy count inconsistencies
        function repairPolicyCounts(gameId, game, repairUpdates) {
            let needsRepair = false;
            
            // Check if policy counts are within valid ranges
            const liberalPolicies = game.liberalPolicies || 0;
            const fascistPolicies = game.fascistPolicies || 0;
            
            if (liberalPolicies > 5) {
                console.log(`Invalid liberal policy count: ${liberalPolicies} - capping at 5`);
                repairUpdates.liberalPolicies = 5;
                needsRepair = true;
            }
            
            if (fascistPolicies > 6) {
                console.log(`Invalid fascist policy count: ${fascistPolicies} - capping at 6`);
                repairUpdates.fascistPolicies = 6;
                needsRepair = true;
            }
            
            // Check if game should be over
            if (liberalPolicies >= 5 || fascistPolicies >= 6) {
                console.log('Game should be over - checking for missing end state');
                if (game.state === 'playing') {
                    repairUpdates.state = 'completed';
                    repairUpdates.winner = liberalPolicies >= 5 ? 'liberal' : 'fascist';
                    needsRepair = true;
                }
            }
            
            return needsRepair;
        }
        
        // Repair election tracker issues
        function repairElectionTracker(gameId, game, repairUpdates) {
            let needsRepair = false;
            
            const electionTracker = game.electionTracker || 0;
            
            // Check if election tracker is within valid range
            if (electionTracker < 0 || electionTracker > 3) {
                console.log(`Invalid election tracker value: ${electionTracker} - fixing to valid range`);
                repairUpdates.electionTracker = Math.max(0, Math.min(3, electionTracker));
                needsRepair = true;
            }
            
            // Check if game should end due to 3 failed elections
            if (electionTracker >= 3 && game.state === 'playing') {
                console.log('Game should end due to 3 failed elections');
                repairUpdates.state = 'completed';
                repairUpdates.winner = 'fascist';
                repairUpdates.endReason = 'election_tracker';
                needsRepair = true;
            }
            
            return needsRepair;
        }
        
        // Enhanced debug function with repair capabilities
        function debugGameState(gameId) {
            console.log('=== GAME STATE DEBUG ===');
            console.log('Game ID:', gameId);
            console.log('Latest Game:', latestGame);
            console.log('Latest Players:', latestPlayers);
            
            if (latestGame) {
                console.log('Game State:', latestGame.state);
                console.log('Policy Phase:', latestGame.policyPhase);
                console.log('Enacted Policy:', latestGame.enactedPolicy);
                console.log('Current President:', latestGame.currentPresidentPlayerId);
                console.log('Current Chancellor:', latestGame.currentChancellorPlayerId);
                console.log('Nominated Chancellor:', latestGame.nominatedChancellorPlayerId);
                console.log('Vote Resolution:', latestGame.voteResolution);
                console.log('Election Votes:', latestGame.electionVotes);
                console.log('President Index:', latestGame.presidentIndex);
                console.log('Liberal Policies:', latestGame.liberalPolicies);
                console.log('Fascist Policies:', latestGame.fascistPolicies);
                console.log('Election Tracker:', latestGame.electionTracker);
                console.log('Total Discarded Cards:', latestGame.totalDiscardedCards);
                console.log('Last Repair:', latestGame.lastRepairAt);
                
                const phase = computePhase(latestGame);
                console.log('Computed Phase:', phase);
                
                // Check for common issues
                const issues = detectGameIssues(gameId, latestGame, latestPlayers);
                if (issues.length > 0) {
                    console.log('=== DETECTED ISSUES ===');
                    issues.forEach(issue => console.log(`- ${issue}`));
                    console.log('=== END ISSUES ===');
                }
            }
            
            if (latestPlayers && latestPlayers.length > 0) {
                console.log('Player Details:');
                latestPlayers.forEach((player, index) => {
                    console.log(`  ${index + 1}. ${player.name || 'Player'} (ID: ${player.id}, Order: ${player.orderIndex}, Alive: ${player.alive !== false})`);
                });
            }
            
            console.log('========================');
        }
        
        // Detect common game issues
        function detectGameIssues(gameId, game, players) {
            const issues = [];
            
            if (!game || !players) return issues;
            
            // Check discard pile consistency
            const calculatedDiscardCount = calculateDiscardCountFromGameState(game);
            const storedDiscardCount = game.totalDiscardedCards || 0;
            if (calculatedDiscardCount !== storedDiscardCount) {
                issues.push(`Discard pile count mismatch: calculated=${calculatedDiscardCount}, stored=${storedDiscardCount}`);
            }
            
            // Check for stuck phases
            if (game.policyPhase === 'completed' && game.enactedPolicy) {
                const timeSinceUpdate = game.updatedAt ? (Date.now() - game.updatedAt.toDate().getTime()) : 0;
                if (timeSinceUpdate > 10000) {
                    issues.push(`Game stuck in completed phase for ${Math.round(timeSinceUpdate / 1000)} seconds`);
                }
            }
            
            // Check policy count validity
            const liberalPolicies = game.liberalPolicies || 0;
            const fascistPolicies = game.fascistPolicies || 0;
            if (liberalPolicies > 5) issues.push(`Invalid liberal policy count: ${liberalPolicies}`);
            if (fascistPolicies > 6) issues.push(`Invalid fascist policy count: ${fascistPolicies}`);
            
            // Check election tracker
            const electionTracker = game.electionTracker || 0;
            if (electionTracker < 0 || electionTracker > 3) {
                issues.push(`Invalid election tracker value: ${electionTracker}`);
            }
            
            // Check player consistency
            const playersWithoutOrder = players.filter(p => p && typeof p.orderIndex !== 'number');
            if (playersWithoutOrder.length > 0) {
                issues.push(`${playersWithoutOrder.length} players missing orderIndex`);
            }
            
            return issues;
        }

        // Enhanced periodic check to detect and fix stuck games using repair system
        function startStuckGameChecker(gameId) {
            const checkInterval = setInterval(async () => {
                try {
                    if (!latestGame || latestGame.state !== 'playing') return;
                    
                    // Check for any game issues that need repair
                    const issues = detectGameIssues(gameId, latestGame, latestPlayers);
                    if (issues.length > 0) {
                        console.warn('Auto-detected game issues:', issues);
                        
                        // Only auto-repair if there are critical issues (stuck phases, invalid counts)
                        const criticalIssues = issues.filter(issue => 
                            issue.includes('stuck') || 
                            issue.includes('Invalid') || 
                            issue.includes('mismatch')
                        );
                        
                        if (criticalIssues.length > 0) {
                            console.log('Auto-repairing critical game issues...');
                            try {
                                await repairGameState(gameId);
                                console.log('Auto-repair completed successfully');
                            } catch (repairError) {
                                console.error('Auto-repair failed:', repairError);
                                
                                // Fallback to old stuck game handling
                                const phase = computePhase(latestGame);
                                if (phase === 'completed') {
                                    const timeSinceUpdate = latestGame.updatedAt ? (Date.now() - latestGame.updatedAt.toDate().getTime()) : 0;
                                    const isStuck = timeSinceUpdate > 15000; // 15 seconds
                                    
                                    if (isStuck) {
                                        console.warn('Fallback: Auto-advancing stuck game in completed phase');
                                        try {
                                            const gameRef = doc(db, 'games', gameId);
                                            await advanceToNextGovernment(gameId, gameRef);
                                        } catch (advanceError) {
                                            console.error('Fallback advancement failed:', advanceError);
                                            await applyFallbackCleanup(gameId, gameRef);
                                        }
                                    }
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error in enhanced stuck game checker:', error);
                }
            }, 10000); // Check every 10 seconds (less aggressive than before)
            
            // Return the interval ID so it can be cleared later
            return checkInterval;
        }
    </script>
</body>
</html>