<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secret Hitler - Multi-Device Setup</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles/themes.css">
    <link rel="stylesheet" href="../styles/main.css">
    <style>
        .multi-device-setup {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .setup-section {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            padding: 20px;
            margin: 20px 0;
            transition: all 0.3s ease;
            box-shadow: var(--card-shadow);
        }
        
        .setup-section:hover {
            box-shadow: 0 4px 16px var(--shadow-medium);
            border-color: var(--primary-color);
        }
        
        .role-distribution, .enhanced-section {
            transition: all 0.3s ease;
        }
        
        .game-creation, .game-joining {
            display: none;
        }
        
        .game-creation.active, .game-joining.active {
            display: block;
        }
        
        .form-group {
            margin-bottom: 15px;
            position: relative;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-primary);
        }
        
        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--input-text);
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
        }
        
        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px var(--shadow-light);
            transform: translateY(-1px);
        }
        
        .form-group select {
            cursor: pointer;
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
            background-position: right 8px center;
            background-repeat: no-repeat;
            background-size: 16px;
            padding-right: 40px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
        }
        
        .form-help {
            display: block;
            margin-top: 5px;
            font-size: 0.875rem;
            color: var(--text-secondary);
            transition: color 0.3s ease;
        }
        
        .form-group select:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background-color: var(--bg-tertiary);
            color: var(--text-muted);
        }
        
        .form-group select:disabled + .form-help {
            color: var(--accent-danger);
        }
        
        .form-group select:disabled option {
            color: var(--text-muted);
        }
        
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
        
        .btn:disabled:hover {
            transform: none !important;
            box-shadow: none !important;
        }
        
        /* Loading state for the select dropdown */
        .form-group.loading select {
            background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 24 24'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15'/%3e%3c/svg%3e");
            background-size: 20px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .game-lobby {
            display: none;
        }
        
        .game-lobby.active {
            display: block;
        }
        
        .players-list {
            margin: 20px 0;
        }
        
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin: 5px 0;
        }
        
        .player-host {
            background: var(--accent-color);
            color: white;
        }
        
        .game-id-display {
            background: var(--highlight-bg);
            padding: 15px;
            border-radius: 4px;
            margin: 20px 0;
            text-align: center;
            font-family: monospace;
            font-size: 18px;
        }
        
        .status-message {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .status-success {
            background: var(--success-bg);
            color: var(--success-color);
            border: 1px solid var(--success-border);
        }
        
        .status-error {
            background: var(--error-bg);
            color: var(--error-color);
            border: 1px solid var(--error-border);
        }
        
        .status-info {
            background: var(--info-bg);
            color: var(--info-color);
            border: 1px solid var(--info-border);
        }
        


        /* Pass-and-play style player count selector */
        .player-count-selector {
            margin: 20px 0;
        }

        .player-count-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .player-btn {
            width: 3rem;
            height: 3rem;
            border: 2px solid var(--border-color);
            background: var(--card-bg);
            color: var(--text-primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            box-shadow: var(--card-shadow);
        }
        
        .player-btn:hover:not(:disabled) {
            border-color: var(--primary-color);
            background: var(--primary-color);
            color: var(--text-light);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-medium);
        }
        
        .player-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: var(--bg-tertiary);
            color: var(--text-muted);
        }

        .player-count-display {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 0.75rem 1.5rem;
            text-align: center;
            min-width: 120px;
            box-shadow: var(--card-shadow);
            transition: all 0.3s ease;
        }
        
        .player-count-display:hover {
            border-color: var(--primary-color);
            box-shadow: 0 4px 16px var(--shadow-medium);
        }
        
        .current-count {
            display: block;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
            margin-bottom: 0.25rem;
        }
        
        .count-label {
            display: block;
            font-size: 0.9rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Role distribution styling */
        .role-distribution {
            margin: 20px 0;
        }

        .role-distribution h4 {
            margin-bottom: 15px;
            color: var(--text-primary);
            font-weight: 700;
            letter-spacing: -0.5px;
        }

        .role-info {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            padding: 20px;
            box-shadow: var(--card-shadow);
        }

        .role-distribution-compact {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            max-width: 100%;
        }

        .role-item {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            border-radius: 12px;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            transition: all 0.3s ease;
            box-shadow: var(--card-shadow);
        }

        .role-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 16px var(--shadow-medium);
            border-color: var(--primary-color);
        }

        .role-item.liberal {
            border-color: #28a745;
            color: #155724;
        }

        .role-item.fascist {
            border-color: #dc3545;
            color: #721c24;
        }

        .role-item.hitler {
            border-color: #6f42c1;
            color: #4a148c;
        }

        .role-icon {
            width: 2rem;
            height: 2rem;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            flex-shrink: 0;
        }

        .role-item.liberal .role-icon {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%2328a745'%3E%3Cpath d='M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z'/%3E%3C/svg%3E");
        }

        .role-item.fascist .role-icon {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23dc3545'%3E%3Cpath d='M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z'/%3E%3C/svg%3E");
        }

        .role-item.hitler .role-icon {
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236f42c1'%3E%3Cpath d='M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z'/%3E%3C/svg%3E");
        }

        .role-details {
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
            flex: 1;
        }

        .role-name {
            font-size: 0.875rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .role-stats {
            font-size: 0.75rem;
            font-weight: 500;
            opacity: 0.8;
        }

        /* Player inputs styling */
        .player-inputs {
            margin: 20px 0;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
        }

        .player-input-group {
            margin-bottom: 15px;
        }

        .player-input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .player-name-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background: var(--input-bg);
            color: var(--input-text);
            font-size: 1rem;
            transition: all 0.3s ease;
            font-family: 'Inter', sans-serif;
        }

        .player-name-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px var(--shadow-light);
            transform: translateY(-1px);
        }

        /* Setup actions */
        .setup-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .btn {
            padding: 12px 24px;
            border: 2px solid transparent;
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            text-align: center;
            font-family: 'Inter', sans-serif;
            box-shadow: var(--card-shadow);
        }
        
        .btn-primary {
            background: var(--primary-color);
            color: var(--text-light);
            border-color: var(--primary-color);
        }

        .btn-primary:hover:not(:disabled) {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-medium);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-outline {
            background: transparent;
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn-outline:hover {
            background: var(--primary-color);
            color: var(--text-light);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-medium);
        }
        
        /* Responsive design */
        @media (max-width: 768px) {
            .player-count-controls {
                gap: 15px;
            }

            .player-btn {
                width: 3.5rem;
                height: 3.5rem;
                font-size: 1.3rem;
            }

            .player-count-display {
                font-size: 1.3rem;
                min-width: 100px;
            }

            .setup-actions {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 100%;
                max-width: 300px;
            }

            .role-distribution-compact .role-icon {
                width: 1.5rem;
                height: 1.5rem;
            }
        }

        /* Desktop Layout - Side by side cards for wider screens */
        @media (min-width: 768px) {
            .role-distribution-compact {
                display: grid;
                grid-template-columns: repeat(3, 1fr);
                gap: 1rem;
                max-width: 800px;
                margin-left: auto;
                margin-right: auto;
            }
            
            .role-distribution-compact .role-item {
                flex-direction: column;
                text-align: center;
                padding: 1.25rem;
                min-height: 120px;
                justify-content: center;
                gap: 0.75rem;
            }
            
            .role-distribution-compact .role-icon {
                width: 3rem;
                height: 3rem;
            }
            
            .role-distribution-compact .role-details {
                align-items: center;
                gap: 0.5rem;
            }
            
            .role-distribution-compact .role-name {
                font-size: 1rem;
                margin-bottom: 0.25rem;
            }
            
            .role-distribution-compact .role-stats {
                font-size: 1.25rem;
                font-weight: 600;
            }
        }

        /* Enhanced setup sections with modern design */
        .enhanced-section {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            padding: 2rem;
            margin: 1.5rem 0;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .enhanced-section:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 35px rgba(0, 0, 0, 0.15);
            border-color: var(--primary-color);
        }
        
        .enhanced-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--primary-color), var(--accent-color));
            transform: scaleX(0);
            transition: transform 0.3s ease;
        }
        
        .enhanced-section:hover::before {
            transform: scaleX(1);
        }
        
        /* Section headers with icons */
        .section-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border-color);
            position: relative;
        }
        
        .section-header::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 60px;
            height: 2px;
            background: var(--primary-color);
            transition: width 0.3s ease;
        }
        
        .section-header:hover::after {
            width: 100px;
        }
        
        .section-icon {
            font-size: 1.5rem;
            color: var(--primary-color);
            transition: transform 0.3s ease;
        }
        
        .section-header:hover .section-icon {
            transform: scale(1.1);
        }
        
        .section-header h3, .section-header h4 {
            margin: 0;
            color: var(--text-primary);
            font-size: 1.3rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        /* Create/Join/Lobby headers */
        .create-header, .join-header, .lobby-header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: var(--accent-bg);
            border-radius: 16px;
            border: 2px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }
        
        .create-header::before, .join-header::before, .lobby-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-color);
        }
        
        .create-icon, .join-icon, .lobby-icon {
            font-size: 2rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
            transition: transform 0.3s ease;
        }
        
        .create-header:hover .create-icon, .join-header:hover .join-icon, .lobby-header:hover .lobby-icon {
            transform: scale(1.05);
        }
        
        .create-header h2, .join-header h2, .lobby-header h2 {
            margin: 0 0 1rem 0;
            color: var(--text-primary);
            font-size: 1.8rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .create-description, .join-description, .lobby-description {
            margin: 0;
            color: var(--text-secondary);
            font-size: 1.1rem;
            line-height: 1.6;
            opacity: 0.9;
        }
        
        /* Enhanced player count selector */
        .player-count-selector {
            text-align: center;
            margin: 2rem 0;
        }
        
        .player-count-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }
        
        .player-btn {
            width: 4rem;
            height: 4rem;
            border: 3px solid var(--primary-color);
            background: var(--bg-secondary);
            color: var(--primary-color);
            border-radius: 50%;
            cursor: pointer;
            font-weight: bold;
            font-size: 1.5rem;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }
        
        .player-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }
        
        .player-btn:hover::before {
            left: 100%;
        }
        
        .player-btn:hover:not(:disabled) {
            background: var(--primary-color);
            color: white;
            transform: scale(1.1);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .player-btn:active:not(:disabled) {
            transform: scale(0.95);
        }
        
        .player-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .player-btn .btn-icon {
            font-size: 1.2rem;
            transition: transform 0.3s ease;
        }
        
        .player-btn:hover .btn-icon {
            transform: scale(1.1);
        }
        
        .player-count-display {
            background: var(--bg-tertiary);
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border: 2px solid var(--border-color);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            min-width: 120px;
            text-align: center;
        }
        
        .current-count {
            font-size: 2rem;
            font-weight: bold;
            color: var(--primary-color);
            display: block;
        }
        
        .count-label {
            font-size: 1rem;
            color: var(--text-secondary);
            font-weight: 500;
        }
        
        .player-count-range {
            margin-top: 1rem;
        }
        
        .range-text {
            color: var(--text-secondary);
            font-size: 0.9rem;
            font-weight: 500;
            opacity: 0.8;
        }
        
        /* Enhanced role distribution */
        .role-distribution {
            margin-top: 2rem;
        }
        
        .role-distribution h4 {
            color: var(--text-primary);
            margin-bottom: 1rem;
            font-size: 1.2rem;
            font-weight: 600;
        }
        
        .role-info {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            min-height: 100px;
        }
        
        /* Enhanced player inputs */
        .player-inputs {
            margin-top: 1rem;
        }
        
        .player-input-group {
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            transition: all 0.3s ease;
        }
        
        .player-input-group:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
            border-color: var(--primary-color);
        }
        
        .player-input-group label {
            min-width: 100px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 0.95rem;
        }
        
        .player-name-input {
            flex: 1;
            padding: 0.75rem;
            border: 2px solid var(--input-border);
            border-radius: 8px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background: var(--input-bg);
            color: var(--input-text);
        }
        
        .player-name-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.1);
            transform: translateY(-1px);
        }
        
        /* Enhanced setup actions */
        .setup-actions {
            text-align: center;
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 2px solid var(--border-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }
        
        /* Enhanced game info card */
        .game-info-card {
            background: var(--bg-secondary);
            border-radius: 16px;
            padding: 2rem;
            margin: 1.5rem 0;
            border: 2px solid var(--border-color);
            text-align: center;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
        }
        
        .game-info-card h3 {
            margin-bottom: 1rem;
            color: var(--text-primary);
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .game-id-display {
            background: var(--accent-bg);
            padding: 1.5rem;
            border-radius: 12px;
            margin: 1.5rem 0;
            border: 2px solid var(--border-color);
        }
        
        .game-id-label {
            display: block;
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        .game-id-value {
            display: block;
            font-family: monospace;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--primary-color);
            letter-spacing: 2px;
        }
        
        .share-text {
            color: var(--text-secondary);
            font-size: 1rem;
            margin: 0;
            font-style: italic;
        }
        
        /* Enhanced players list */
        .players-list {
            margin: 2rem 0;
        }
        
        .players-container {
            display: grid;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .player-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
        }
        
        .player-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
            border-color: var(--primary-color);
        }
        
        .player-host {
            background: linear-gradient(135deg, var(--accent-color), var(--primary-color));
            color: white;
            border-color: var(--accent-color);
        }
        
        .player-host span:last-child {
            background: rgba(255, 255, 255, 0.2);
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
        }
        /* Responsive design improvements */
        @media (max-width: 768px) {
            .enhanced-section {
                padding: 1.5rem;
                margin: 1rem 0;
                border-radius: 12px;
            }
            
            .create-header h2, .join-header h2, .lobby-header h2 {
                font-size: 1.8rem;
            }
            
            .create-description, .join-description, .lobby-description {
                font-size: 1rem;
            }
            
            .create-icon, .join-icon, .lobby-icon {
                font-size: 2.5rem;
            }
            
            .section-header {
                flex-direction: column;
                text-align: center;
                gap: 0.5rem;
            }
            
            .section-icon {
                min-width: 2.5rem;
                height: 2.5rem;
                font-size: 1.5rem;
            }
            
            .section-header h3, .section-header h4 {
                font-size: 1.3rem;
            }
            
            .player-count-controls {
                gap: 1.5rem;
                flex-wrap: wrap;
            }
            
            .player-btn {
                width: 3.5rem;
                height: 3.5rem;
                font-size: 1.3rem;
            }
            
            .player-count-display {
                padding: 0.875rem 1.25rem;
                min-width: 100px;
            }
            
            .current-count {
                font-size: 1.75rem;
            }
            
            .player-input-group {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.75rem;
                padding: 1.25rem;
            }
            
            .player-input-group label {
                min-width: auto;
                font-size: 0.9rem;
            }
            
            .player-name-input {
                width: 100%;
                padding: 0.875rem;
            }
            
            .setup-actions {
                gap: 0.75rem;
            }
            
            .btn-large {
                min-width: 200px;
                padding: 1rem 1.5rem;
            }
            
            .btn-medium {
                min-width: 180px;
                padding: 0.875rem 1.5rem;
            }
            
            .game-info-card {
                padding: 1.5rem;
            }
            
            .game-id-display {
                padding: 1.25rem;
            }
            
            .game-id-value {
                font-size: 1.25rem;
                letter-spacing: 1px;
            }
            
            .player-item {
                padding: 0.875rem 1.25rem;
                flex-direction: column;
                gap: 0.5rem;
                text-align: center;
            }
        }
        
        @media (max-width: 480px) {
            .enhanced-section {
                padding: 1.25rem;
                margin: 0.75rem 0;
                border-radius: 10px;
            }
            
            .create-header h2, .join-header h2, .lobby-header h2 {
                font-size: 1.6rem;
            }
            
            .create-description, .join-description, .lobby-description {
                font-size: 0.95rem;
            }
            
            .create-icon, .join-icon, .lobby-icon {
                font-size: 2rem;
            }
            
            .section-header h3, .section-header h4 {
                font-size: 1.2rem;
            }
            
            .player-count-controls {
                gap: 1rem;
            }
            
            .player-btn {
                width: 3rem;
                height: 3rem;
                font-size: 1.1rem;
                border-width: 2px;
            }
            
            .player-count-display {
                padding: 0.75rem 1rem;
                min-width: 90px;
            }
            
            .current-count {
                font-size: 1.5rem;
            }
            
            .player-input-group {
                padding: 1rem;
            }
            
            .player-input-group label {
                font-size: 0.85rem;
            }
            
            .player-name-input {
                padding: 0.75rem;
                font-size: 0.95rem;
            }
            
            .btn-large {
                min-width: 180px;
                padding: 0.875rem 1.25rem;
                font-size: 1rem;
            }
            
            .btn-medium {
                min-width: 160px;
                padding: 0.75rem 1.25rem;
            }
            
            .game-info-card {
                padding: 1.25rem;
            }
            
            .game-id-display {
                padding: 1rem;
            }
            
            .game-id-value {
                font-size: 1.1rem;
            }
            
            .player-item {
                padding: 0.75rem 1rem;
            }
        }
        
        /* Extra small mobile devices */
        @media (max-width: 360px) {
            .enhanced-section {
                padding: 1rem;
                margin: 0.5rem 0;
            }
            
            .create-header h2, .join-header h2, .lobby-header h2 {
                font-size: 1.5rem;
            }
            
            .player-count-controls {
                gap: 0.75rem;
            }
            
            .player-btn {
                width: 2.75rem;
                height: 2.75rem;
                font-size: 1rem;
            }
            
            .player-count-display {
                padding: 0.625rem 0.875rem;
                min-width: 80px;
            }
            
            .current-count {
                font-size: 1.25rem;
            }
            
            .btn-large {
                min-width: 160px;
                padding: 0.75rem 1rem;
                font-size: 0.95rem;
            }
            
            .btn-medium {
                min-width: 140px;
                padding: 0.625rem 1rem;
                font-size: 0.9rem;
            }
        }

        /* Game Mechanics Styling */
        .game-mechanics {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        /* CSS Variables for game mechanics */
        :root {
            --accent-danger: #dc3545;
            --accent-danger-hover: #c82333;
            --accent-info: #17a2b8;
            --accent-success: #28a745;
            --accent-warning: #ffc107;
            --info-bg: rgba(23, 162, 184, 0.1);
            --success-bg: rgba(40, 167, 69, 0.1);
            --warning-bg: rgba(255, 193, 7, 0.1);
            --accent-bg: rgba(102, 16, 242, 0.1);
        }
        
        /* Game Header */
        .game-header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: var(--accent-bg);
            border-radius: 16px;
            border: 2px solid var(--border-color);
            position: relative;
            overflow: hidden;
        }
        
        .game-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--primary-color);
        }
        
        .game-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        
        .game-header h2 {
            margin: 0 0 1rem 0;
            color: var(--text-primary);
            font-size: 2rem;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .game-description {
            margin: 0;
            color: var(--text-secondary);
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        /* Game Phase Display */
        .game-phase-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 1.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
        }
        
        .phase-indicator, .turn-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }
        
        .phase-label, .turn-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .phase-value, .turn-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary-color);
        }
        
        /* Game Board */
        .game-board {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
        }
        
        .policy-tracks {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }
        
        .policy-track {
            text-align: center;
            padding: 1.5rem;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-secondary);
        }
        
        .policy-track h3 {
            margin: 0 0 1rem 0;
            color: var(--text-primary);
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .track-spaces {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        
        .track-space {
            width: 2.5rem;
            height: 2.5rem;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            background: var(--bg-tertiary);
            color: var(--text-secondary);
        }
        
        .track-space.filled {
            background: var(--primary-color);
            color: var(--text-light);
            border-color: var(--primary-color);
            transform: scale(1.1);
        }
        
        .track-space.win {
            background: var(--accent-color);
            color: var(--text-light);
            border-color: var(--accent-color);
            animation: winner 1s ease-in-out infinite alternate;
        }
        
        @keyframes winner {
            from { transform: scale(1.1); }
            to { transform: scale(1.2); }
        }
        
        .track-space.power {
            background: var(--accent-color);
            color: var(--text-light);
            border-color: var(--accent-color);
        }
        
        .track-count {
            font-size: 1.2rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .election-tracker {
            text-align: center;
            padding: 1.5rem;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            background: var(--bg-secondary);
        }
        
        .election-tracker h3 {
            margin: 0 0 1rem 0;
            color: var(--text-primary);
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .tracker-spaces {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
        }
        
        .tracker-space {
            width: 2rem;
            height: 2rem;
            border: 2px solid var(--border-color);
            border-radius: 50%;
            background: var(--bg-tertiary);
            transition: all 0.3s ease;
        }
        
        .tracker-space.filled {
            background: var(--accent-danger);
            border-color: var(--accent-danger);
            transform: scale(1.1);
        }
        
        /* Game Actions */
        .game-actions {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
            text-align: center;
        }
        
        .action-phase {
            margin-bottom: 2rem;
        }
        
        .action-phase h3 {
            margin: 0 0 1rem 0;
            color: var(--text-primary);
            font-size: 1.5rem;
            font-weight: 600;
        }
        
        .action-description {
            margin: 0 0 1.5rem 0;
            color: var(--text-secondary);
            font-size: 1.1rem;
            line-height: 1.6;
        }
        
        .action-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .action-btn {
            padding: 1rem 2rem;
            border: 2px solid var(--primary-color);
            border-radius: 12px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            background: var(--primary-color);
            color: var(--text-light);
            min-width: 150px;
        }
        
        .action-btn:hover:not(:disabled) {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px var(--shadow-medium);
        }
        
        .action-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        
        .action-btn.secondary {
            background: transparent;
            color: var(--primary-color);
        }
        
        .action-btn.secondary:hover:not(:disabled) {
            background: var(--primary-color);
            color: var(--text-light);
        }
        
        /* Game Log */
        .game-log {
            background: var(--card-bg);
            border: 2px solid var(--border-color);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--card-shadow);
        }
        
        .game-log h3 {
            margin: 0 0 1rem 0;
            color: var(--text-primary);
            font-size: 1.3rem;
            font-weight: 600;
        }
        
        .log-entries {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            background: var(--bg-secondary);
        }
        
        .log-entry {
            padding: 0.75rem;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 0.5rem;
            border-radius: 4px;
            background: var(--card-bg);
        }
        
        .log-entry:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .log-entry.phase {
            background: var(--accent-bg);
            border-left: 4px solid var(--primary-color);
        }
        
        .log-entry.action {
            background: var(--info-bg);
            border-left: 4px solid var(--accent-info);
        }
        
        .log-entry.vote {
            background: var(--success-bg);
            border-left: 4px solid var(--accent-success);
        }
        
        .log-entry.policy {
            background: var(--warning-bg);
            border-left: 4px solid var(--accent-warning);
        }
        
        .log-timestamp {
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 0.25rem;
        }
        
        .log-message {
            color: var(--text-primary);
            font-weight: 500;
        }
        
        /* Game Controls */
        .game-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
        }
        
        /* Responsive Design for Game Mechanics */
        @media (max-width: 768px) {
            .game-mechanics {
                padding: 1rem;
            }
            
            .game-header {
                padding: 1.5rem;
                margin-bottom: 1.5rem;
            }
            
            .game-header h2 {
                font-size: 1.8rem;
            }
            
            .game-icon {
                font-size: 2.5rem;
            }
            
            .game-phase-display {
                flex-direction: column;
                gap: 1rem;
                padding: 1rem;
            }
            
            .policy-tracks {
                grid-template-columns: 1fr;
                gap: 1rem;
            }
            
            .track-spaces {
                flex-wrap: wrap;
                gap: 0.25rem;
            }
            
            .track-space {
                width: 2rem;
                height: 2rem;
                font-size: 0.8rem;
            }
            
            .action-buttons {
                flex-direction: column;
                align-items: center;
            }
            
            .action-btn {
                width: 100%;
                max-width: 300px;
            }
            
            .game-controls {
                flex-direction: column;
                align-items: center;
            }
        }
        
        /* Enhanced header styling to match home page */
        header {
            text-align: center;
            margin-bottom: 1.5rem;
            color: var(--header-text);
            position: relative;
            z-index: 1;
            padding: 1rem 0;
            background: var(--bg-secondary);
            border-bottom: 2px solid var(--border-color);
        }
        
        .header-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem;
        }
        
        .game-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 0.5rem;
        }
        
        .logo-icon {
            font-size: 2.5rem;
            background: var(--primary-color);
            color: var(--text-light);
            padding: 0.6rem;
            border-radius: 50%;
            border: none;
            animation: none;
            box-shadow: 0 4px 12px var(--shadow-medium);
            transition: all 0.3s ease;
        }
        
        .logo-icon:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px var(--shadow-medium);
        }
        
        .logo-text h1 {
            font-size: 2.2rem;
            margin-bottom: 0.25rem;
            text-shadow: none;
            cursor: pointer;
            transition: all 0.3s ease;
            color: var(--primary-color);
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        
        .logo-text h1:hover {
            transform: scale(1.02);
            color: var(--primary-hover);
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.8;
            font-weight: 400;
            letter-spacing: 0.5px;
            color: var(--text-secondary);
        }
        
        .header-decoration {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
        }
        
        .decoration-line {
            width: 40px;
            height: 2px;
            background: var(--primary-color);
            transition: all 0.3s ease;
        }
        
        .header-decoration:hover .decoration-line {
            background: var(--primary-hover);
            transform: scaleX(1.1);
        }
        
        .decoration-dot {
            width: 6px;
            height: 6px;
            background: var(--primary-color);
            border-radius: 50%;
            animation: none;
            transition: all 0.3s ease;
        }
        
        .header-decoration:hover .decoration-dot {
            background: var(--primary-hover);
            transform: scale(1.2);
        }
        
        /* Status Messages */
        .status-message {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        
        .status-success {
            background: var(--success-bg);
            color: var(--success-color);
            border: 1px solid var(--success-border);
        }
        
        .status-error {
            background: var(--error-bg);
            color: var(--error-color);
            border: 1px solid var(--error-border);
        }
        
        .status-info {
            background: var(--info-bg);
            color: var(--info-color);
            border: 1px solid var(--info-border);
        }
        
        /* Status Banner */
        .status-banner {
            background: linear-gradient(135deg, var(--accent-color), var(--primary-color));
            color: white;
            padding: 1rem;
            border-radius: 12px;
            margin-bottom: 2rem;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            animation: slideDown 0.5s ease-out;
        }
        
        @keyframes slideDown {
            from { transform: translateY(-20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        .banner-content {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
        }
        
        .banner-icon {
            font-size: 1.2rem;
        }
        
        .banner-text {
            font-weight: 600;
            font-size: 1rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-content">
                <div class="game-logo">
                    <div class="logo-icon"></div>
                    <div class="logo-text">
                        <h1 id="header-title" style="cursor: pointer;">Secret Hitler</h1>
                        <p class="subtitle" id="page-subtitle">Multi-Device Edition</p>
                    </div>
                </div>
                <div class="header-decoration">
                    <div class="decoration-line"></div>
                    <div class="decoration-dot"></div>
                    <div class="decoration-line"></div>
                </div>
            </div>
        </header>
        
        <main class="multi-device-setup">
            
            <!-- Status Banner -->
            <div id="status-banner" class="status-banner" style="display: none;">
                <div class="banner-content">
                    <span class="banner-icon"></span>
                    <span class="banner-text">Running in offline mode. Backend server not available.</span>
                </div>
            </div>
            
            <!-- Game Creation Section -->
            <div id="create-section" class="setup-section game-creation active">
                <div class="create-header">
                    <div class="create-icon"></div>
                    <h2>Create New Game</h2>
                    <p class="create-description">Set up a new Secret Hitler game with your preferred player count and names</p>
                </div>

                <div class="setup-section enhanced-section">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <h3>Player Count</h3>
                    </div>
                    <div class="player-count-selector">
                        <div class="player-count-controls">
                            <button class="player-btn player-minus" id="player-minus" disabled>
                                <span class="btn-icon"></span>
                            </button>
                            <div class="player-count-display">
                                <span class="current-count">0</span>
                                <span class="count-label">players</span>
                            </div>
                            <button class="player-btn player-plus" id="player-plus">
                                <span class="btn-icon"></span>
                            </button>
                        </div>
                        <div class="player-count-range">
                            <span class="range-text">Range: 5-10 players</span>
                        </div>
                    </div>
                    
                    <div class="role-distribution" id="role-distribution-section" style="display: none;">
                        <h4>Role Distribution</h4>
                        <div id="role-info" class="role-info">
                            <!-- Role distribution will be populated here -->
                        </div>
                    </div>
                </div>
                    
                <div class="setup-section enhanced-section" id="player-names-section" style="display: none;">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <h3>Player Names</h3>
                    </div>
                    <div id="player-inputs" class="player-inputs">
                        <!-- Player input fields will be generated here -->
                    </div>
                </div>
                    
                <div class="setup-actions">
                    <button id="create-game-btn" class="btn btn-primary btn-large">
                        <span class="btn-icon"></span>
                        <span class="btn-text">Create Game</span>
                    </button>
                    <button type="button" class="btn btn-outline btn-medium" onclick="window.history.back()">
                        <span class="btn-icon"></span>
                        <span class="btn-text">Back</span>
                    </button>
                </div>
            </div>
            
            <!-- Game Joining Section -->
            <div id="join-section" class="setup-section game-joining">
                <div class="join-header">
                    <div class="join-icon"></div>
                    <h2>Join Existing Game</h2>
                    <p class="join-description">Enter a Game ID to join an existing Secret Hitler game</p>
                </div>
                
                <form id="join-game-form">
                    <div class="form-group">
                        <label for="game-id-input">Game ID:</label>
                        <input type="text" id="game-id-input" placeholder="Enter game ID" required>
                    </div>
                    
                    <div class="form-group">
                        <label for="player-name-select">Select Your Name:</label>
                        <select id="player-name-select" required>
                            <option value="">Choose your name from the game...</option>
                        </select>
                        <small class="form-help">Available names will load after entering the Game ID</small>
                    </div>
                    
                    <div class="btn-group">
                        <button type="submit" class="btn btn-primary btn-large">
                            <span class="btn-icon"></span>
                            <span class="btn-text">Join Game</span>
                        </button>
                        <button type="button" class="btn btn-outline btn-medium" onclick="window.history.back()">
                            <span class="btn-icon"></span>
                            <span class="btn-text">Back</span>
                        </button>
                    </div>
                </form>
            </div>
            
            <!-- Game Lobby Section -->
            <div id="game-lobby" class="setup-section game-lobby">
                <div class="lobby-header">
                    <div class="lobby-icon"></div>
                    <h2>Game Lobby</h2>
                    <p class="lobby-description">Waiting for players to join. Share the Game ID with others!</p>
                </div>
                
                <div id="game-info" class="game-info-card">
                    <h3 id="lobby-game-name"></h3>
                    <div class="game-id-display">
                        <span class="game-id-label">Game ID:</span>
                        <span id="lobby-game-id" class="game-id-value"></span>
                    </div>
                    <p class="share-text">Share this Game ID with other players to join!</p>
                </div>
                
                <div class="players-list">
                    <div class="section-header">
                        <div class="section-icon"></div>
                        <h4>Players (<span id="player-count">0</span>/<span id="max-player-count">0</span>)</h4>
                    </div>
                    <div id="players-container" class="players-container">
                        <!-- Players will be populated here -->
                    </div>
                </div>
                
                <div class="btn-group">
                    <button id="start-game-btn" class="btn btn-primary btn-large" style="display: none;">
                        <span class="btn-icon"></span>
                        <span class="btn-text">Start Game</span>
                    </button>
                    <button id="leave-game-btn" class="btn btn-outline btn-medium">
                        <span class="btn-icon"></span>
                        <span class="btn-text">Leave Game</span>
                    </button>
                </div>
            </div>
            
            <!-- Game Mechanics Section -->
            <div id="game-mechanics" class="setup-section game-mechanics" style="display: none;">
                <div class="game-header">
                    <div class="game-icon"></div>
                    <h2>Secret Hitler - Game in Progress</h2>
                    <p class="game-description">Follow the game flow and make your decisions</p>
                </div>
                
                <!-- Game Phase Display -->
                <div class="game-phase-display">
                    <div class="phase-indicator">
                        <span class="phase-label">Current Phase:</span>
                        <span id="current-phase" class="phase-value">Setup</span>
                    </div>
                    <div class="turn-info">
                        <span class="turn-label">Turn:</span>
                        <span id="current-turn" class="turn-value">1</span>
                    </div>
                </div>
                
                <!-- Game Board -->
                <div class="game-board">
                    <div class="policy-tracks">
                        <div class="policy-track liberal-track">
                            <h3>Liberal Policies</h3>
                            <div class="track-spaces" id="liberal-track">
                                <!-- Liberal policy spaces will be populated here -->
                            </div>
                            <div class="track-count">0/5</div>
                        </div>
                        <div class="policy-track fascist-track">
                            <h3>Fascist Policies</h3>
                            <div class="track-spaces" id="fascist-track">
                                <!-- Fascist policy spaces will be populated here -->
                            </div>
                            <div class="track-count">0/6</div>
                        </div>
                    </div>
                    
                    <div class="election-tracker">
                        <h3>Election Tracker</h3>
                        <div class="tracker-spaces" id="election-tracker">
                            <!-- Election tracker spaces will be populated here -->
                        </div>
                    </div>
                </div>
                
                <!-- Game Actions -->
                <div class="game-actions" id="game-actions">
                    <!-- Game actions will be populated based on current phase -->
                </div>
                
                <!-- Game Log -->
                <div class="game-log">
                    <div class="log-header">
                        <h3>Game Log</h3>
                        <div class="log-controls">
                            <span class="spoiler-warning"> Contains game information</span>
                            <button class="log-toggle-btn btn btn-outline" data-expanded="false">
                                <span class="toggle-text">Show Log</span>
                                <span class="toggle-icon"></span>
                            </button>
                        </div>
                    </div>
                    <div class="log-entries collapsed" id="game-log-entries">
                        <!-- Game log entries will be populated here -->
                    </div>
                </div>
                
                <!-- Game Controls -->
                <div class="game-controls">
                    <button id="next-phase-btn" class="btn btn-primary btn-large">
                        <span class="btn-icon"></span>
                        <span class="btn-text">Next Phase</span>
                    </button>
                    <button id="reset-game-btn" class="btn btn-outline btn-medium">
                        <span class="btn-icon"></span>
                        <span class="btn-text">Reset Game</span>
                    </button>
                    <button id="end-game-btn" class="btn btn-outline btn-medium">
                        <span class="btn-icon"></span>
                        <span class="btn-text">End Game</span>
                    </button>
                    <button id="back-to-lobby-btn" class="btn btn-outline btn-medium">
                        <span class="btn-icon"></span>
                        <span class="btn-text">Back to Lobby</span>
                    </button>
                </div>
            </div>
            
            <!-- Status Messages -->
            <div id="status-container"></div>
        </main>
    </div>
    
    <script>
        class MultiDeviceGame {
            constructor() {
                // Use relative backend URL for current file structure
                this.backendUrl = '/backend';
                this.currentGame = null;
                this.currentPlayer = null;
                this.isBackendAvailable = false;
                
                // Game state for integrated gameplay
                this.gameState = {
                    players: [],
                    currentTurn: 1,
                    currentPhase: 'setup',
                    currentPresident: 0,
                    currentChancellor: null,
                    liberalPolicies: 0,
                    fascistPolicies: 0,
                    electionTracker: 0,
                    gameOver: false,
                    winner: null,
                    policyStacks: [],
                    currentPolicyStack: null,
                    presidentDiscarded: null,
                    executivePowers: [],
                    gameLog: [],
                    lastChancellor: null,
                    consecutiveFailedElections: 0
                };
                
                this.init();
            }
            
            async init() {
                this.setupEventListeners();
                this.setupHeaderNavigation();
                this.autoShowSection();
                this.initializePlayerCount();
                await this.checkBackendAvailability();
            }
            
            async checkBackendAvailability() {
                try {
                    // Check if we can access the backend status endpoint
                    const response = await fetch(`${this.backendUrl}/api/status.php`, { 
                        method: 'GET',
                        signal: AbortSignal.timeout(5000) // 5 second timeout
                    });
                    
                    if (response.ok) {
                        const data = await response.json();
                        this.isBackendAvailable = data.connected || false;
                        
                        if (this.isBackendAvailable) {
                            console.log('Backend connected successfully:', data);
                        } else {
                            console.log('Backend available but database not connected:', data.error);
                        }
                    } else {
                        this.isBackendAvailable = false;
                        console.log('Backend responded with error status:', response.status);
                    }
                } catch (error) {
                    this.isBackendAvailable = false;
                    console.log('Backend not available:', error.message);
                    console.log('To use the backend:');
                    console.log('1. Make sure you have PHP installed');
                    console.log('2. Run: php -S localhost:8000 -t backend');
                    console.log('3. Or use XAMPP with project in htdocs/PassAndPlaySH/');
                }
                
                this.updateUIForBackendStatus();
            }
            
            updateUIForBackendStatus() {
                const createGameBtn = document.getElementById('create-game-btn');
                const joinGameBtn = document.querySelector('#join-game-form .btn-primary');
                const statusBanner = document.getElementById('status-banner');
                
                if (!this.isBackendAvailable) {
                    // Show create game button in offline mode with offline styling
                    if (createGameBtn) {
                        createGameBtn.style.display = 'block';
                        createGameBtn.innerHTML = `
                            <span class="btn-icon"></span>
                            <span class="btn-text">Offline Mode - Create Game</span>
                        `;
                        createGameBtn.classList.remove('btn-primary');
                        createGameBtn.classList.add('btn-secondary');
                    }
                    
                    // Show offline mode message
                    const createSection = document.querySelector('#create-section');
                    if (createSection) {
                        const offlineMessage = document.createElement('div');
                        offlineMessage.className = 'offline-message';
                        offlineMessage.innerHTML = `
                            <div class="offline-notice">
                                <span class="offline-icon"></span>
                                <div class="offline-text">
                                    <h4>Backend Connection Required</h4>
                                    <p>To create and join games, you need to connect to the backend server.</p>
                                    <p><strong>Quick Setup Options:</strong></p>
                                    <ul style="text-align: left; margin: 0.5rem 0;">
                                        <li><strong>Option 1:</strong> Use XAMPP - Place project in htdocs/PassAndPlaySH/</li>
                                        <li><strong>Option 2:</strong> PHP Server - Run: php -S localhost:8000 -t backend</li>
                                        <li><strong>Option 3:</strong> Use offline mode - Click "Create Game" to play locally</li>
                                    </ul>
                                </div>
                            </div>
                        `;
                        
                        // Remove any existing offline message
                        const existingMessage = createSection.querySelector('.offline-message');
                        if (existingMessage) {
                            existingMessage.remove();
                        }
                        
                        createSection.appendChild(offlineMessage);
                    }
                    
                    if (joinGameBtn) {
                        joinGameBtn.disabled = true;
                        joinGameBtn.innerHTML = `
                            <span class="btn-icon"></span>
                            <span class="btn-text">Backend Unavailable</span>
                        `;
                    }
                    
                    // Show status banner
                    if (statusBanner) {
                        statusBanner.style.display = 'block';
                    }
                    
                    // Show offline notice
                    this.showStatus('Running in offline mode. Backend server not available.', 'info');
                } else {
                    // Show create game button when backend is available
                    if (createGameBtn) {
                        createGameBtn.style.display = 'block';
                        createGameBtn.innerHTML = `
                            <span class="btn-icon"></span>
                            <span class="btn-text">Create Game</span>
                        `;
                        createGameBtn.classList.remove('btn-secondary');
                        createGameBtn.classList.add('btn-primary');
                    }
                    
                    // Remove offline message when backend is available
                    const offlineMessage = document.querySelector('.offline-message');
                    if (offlineMessage) {
                        offlineMessage.remove();
                    }
                    
                    // Hide status banner
                    if (statusBanner) {
                        statusBanner.style.display = 'none';
                    }
                }
            }
            
            initializePlayerCount() {
                // Start with 0 players like pass-and-play
                this.updatePlayerCount(0);
            }
            
            setupHeaderNavigation() {
                // Make the header title clickable to return to home
                const headerTitle = document.getElementById('header-title');
                if (headerTitle) {
                    headerTitle.addEventListener('click', () => {
                        window.location.href = '../index.html';
                    });
                }
            }
            
            setupEventListeners() {
                // Player count +/- buttons
                const minusBtn = document.getElementById('player-minus');
                const plusBtn = document.getElementById('player-plus');
                
                if (minusBtn && plusBtn) {
                    minusBtn.addEventListener('click', () => {
                        const currentCount = this.getCurrentPlayerCount();
                        if (currentCount > 5) {
                            this.updatePlayerCount(currentCount - 1);
                        } else if (currentCount === 5) {
                            this.updatePlayerCount(0);
                        }
                    });
                    
                    plusBtn.addEventListener('click', () => {
                        const currentCount = this.getCurrentPlayerCount();
                        if (currentCount === 0) {
                            this.updatePlayerCount(5);
                        } else if (currentCount < 10) {
                            this.updatePlayerCount(currentCount + 1);
                        }
                    });
                }

                // Create game button
                document.getElementById('create-game-btn').addEventListener('click', () => {
                    if (this.isBackendAvailable) {
                        this.createGame();
                    } else {
                        this.startOfflineGame();
                    }
                });
                
                // Join game form
                document.getElementById('join-game-form').addEventListener('submit', (e) => {
                    e.preventDefault();
                    if (this.isBackendAvailable) {
                        this.joinGame();
                    } else {
                        this.showStatus('Cannot join games in offline mode. Backend server required.', 'error');
                    }
                });
                
                // Game ID input - load player names when game ID is entered
                document.getElementById('game-id-input').addEventListener('input', (e) => {
                    if (!this.isBackendAvailable) {
                        e.target.disabled = true;
                        return;
                    }
                    
                    const gameId = e.target.value.trim();
                    if (gameId.length >= 3) { // Load names after 3+ characters
                        this.loadAvailablePlayerNames(gameId);
                    } else {
                        this.clearPlayerNamesDropdown();
                    }
                    this.updateJoinButtonState();
                });
                
                // Player name select - update join button state when selection changes
                document.getElementById('player-name-select').addEventListener('change', () => {
                    this.updateJoinButtonState();
                });
                
                // Start game button
                document.getElementById('start-game-btn').addEventListener('click', () => {
                    this.startGame();
                });
                
                // Leave game button
                document.getElementById('leave-game-btn').addEventListener('click', () => {
                    this.leaveGame();
                });

                // Next Phase button
                document.getElementById('next-phase-btn').addEventListener('click', () => {
                    this.nextPhase();
                });

                // Reset Game button
                document.getElementById('reset-game-btn').addEventListener('click', () => {
                    this.resetGame();
                });

                // Log toggle button
                document.addEventListener('click', (event) => {
                    const logToggleBtn = event.target.closest('.log-toggle-btn');
                    if (logToggleBtn) {
                        const logEntries = document.getElementById('game-log-entries');
                        const isExpanded = logToggleBtn.dataset.expanded === 'true';
                        
                        if (isExpanded) {
                            // Collapse log
                            logEntries.classList.add('collapsed');
                            logToggleBtn.dataset.expanded = 'false';
                            logToggleBtn.querySelector('.toggle-text').textContent = 'Show Log';
                            logToggleBtn.querySelector('.toggle-icon').textContent = '';
                        } else {
                            // Expand log
                            logEntries.classList.remove('collapsed');
                            logToggleBtn.dataset.expanded = 'true';
                            logToggleBtn.querySelector('.toggle-text').textContent = 'Hide Log';
                            logToggleBtn.querySelector('.toggle-icon').textContent = '';
                        }
                    }
                });
            }
            
            startOfflineGame() {
                const maxPlayers = this.getCurrentPlayerCount();
                
                // Validate inputs
                if (maxPlayers === 0) {
                    this.showStatus('Please select a player count', 'error');
                    return;
                }
                
                // Collect all player names
                const playerNames = [];
                for (let i = 1; i <= maxPlayers; i++) {
                    const input = document.getElementById(`player-${i}`);
                    const name = input.value.trim();
                    if (!name) {
                        this.showStatus(`Please enter a name for Player ${i}`, 'error');
                        input.focus();
                        return;
                    }
                    playerNames.push(name);
                }
                
                this.showStatus('Starting integrated game...', 'success');
                
                // Start the integrated game
                this.startIntegratedGame(playerNames);
            }
            
            // Load available player names for the specified game
            async loadAvailablePlayerNames(gameId) {
                if (!this.isBackendAvailable) return;
                
                const formGroup = document.querySelector('#join-section .form-group:last-child');
                const select = document.getElementById('player-name-select');
                const helpText = document.querySelector('.form-help');
                
                try {
                    // Show loading state
                    if (formGroup) formGroup.classList.add('loading');
                    if (helpText) {
                        helpText.textContent = 'Loading available names...';
                        helpText.style.color = 'var(--accent-info)';
                    }
                    
                    const response = await fetch(`${this.backendUrl}/api/games.php?id=${gameId}`);
                    const data = await response.json();
                    
                    if (data.success && data.players) {
                        this.populatePlayerNamesDropdown(data.players);
                    } else {
                        this.clearPlayerNamesDropdown();
                        this.showStatus('Game not found or invalid Game ID', 'error');
                    }
                } catch (error) {
                    console.error('Error loading player names:', error);
                    this.clearPlayerNamesDropdown();
                    if (helpText) {
                        helpText.textContent = 'Error loading player names. Please try again.';
                        helpText.style.color = 'var(--accent-danger)';
                    }
                } finally {
                    // Remove loading state
                    if (formGroup) formGroup.classList.remove('loading');
                }
            }
            
            // Populate the player names dropdown with available names
            populatePlayerNamesDropdown(players) {
                const select = document.getElementById('player-name-select');
                const helpText = document.querySelector('.form-help');
                
                // Clear existing options except the first one
                select.innerHTML = '<option value="">Choose your name from the game...</option>';
                
                // Add player names that haven't been claimed yet
                const availablePlayers = players.filter(player => !player.is_claimed);
                
                if (availablePlayers.length === 0) {
                    // No available names
                    if (helpText) {
                        helpText.textContent = 'All player names have been claimed for this game.';
                        helpText.style.color = 'var(--accent-danger)';
                    }
                    select.disabled = true;
                } else {
                    // Add available names
                    availablePlayers.forEach(player => {
                        const option = document.createElement('option');
                        option.value = player.name;
                        option.textContent = player.name;
                        select.appendChild(option);
                    });
                    
                    if (helpText) {
                        helpText.textContent = `${availablePlayers.length} available name(s) found. Select yours to join!`;
                        helpText.style.color = 'var(--accent-success)';
                    }
                    select.disabled = false;
                }
                
                // Update join button state
                this.updateJoinButtonState();
            }
            
            // Clear the player names dropdown
            clearPlayerNamesDropdown() {
                const select = document.getElementById('player-name-select');
                const helpText = document.querySelector('.form-help');
                
                select.innerHTML = '<option value="">Choose your name from the game...</option>';
                
                if (helpText) {
                    if (this.isBackendAvailable) {
                        helpText.textContent = 'Available names will load after entering the Game ID';
                        helpText.style.color = 'var(--text-secondary)';
                    } else {
                        helpText.textContent = 'Backend server not available';
                        helpText.style.color = 'var(--accent-danger)';
                    }
                }
                
                // Update join button state
                this.updateJoinButtonState();
            }
            
            autoShowSection() {
                // Get the mode from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                const mode = urlParams.get('mode') || 'create';
                
                // Update page subtitle based on mode
                const subtitle = document.getElementById('page-subtitle');
                if (subtitle) {
                    subtitle.textContent = mode === 'create' ? 'Create New Game' : 'Join Existing Game';
                }
                
                // Show the appropriate section based on mode
                this.showSection(mode);
            }
            
            showSection(sectionName) {
                // Hide all sections
                document.querySelectorAll('.setup-section').forEach(section => {
                    section.classList.remove('active');
                });
                
                // Show selected section
                document.getElementById(`${sectionName}-section`).classList.add('active');
            }
            
            getCurrentPlayerCount() {
                const currentCountSpan = document.querySelector('.current-count');
                return currentCountSpan ? parseInt(currentCountSpan.textContent) : 0;
            }
            
            updatePlayerCount(newCount) {
                const currentCount = this.getCurrentPlayerCount();
                
                if (newCount === currentCount) return;
                
                // Update the display
                const countDisplay = document.querySelector('.current-count');
                if (countDisplay) {
                    countDisplay.textContent = newCount;
                }
                
                // Update role distribution and player inputs
                const roleInfo = document.getElementById('role-info');
                const playerInputs = document.getElementById('player-inputs');
                const createGameBtn = document.getElementById('create-game-btn');
                const roleDistributionSection = document.getElementById('role-distribution-section');
                const playerNamesSection = document.getElementById('player-names-section');
                
                if (newCount === 0) {
                    // Hide role distribution and player inputs when count is 0
                    roleInfo.innerHTML = '<p>Select player count to see role distribution</p>';
                    playerInputs.innerHTML = '';
                    createGameBtn.disabled = true;
                    roleDistributionSection.style.display = 'none';
                    playerNamesSection.style.display = 'none';
                    return;
                }

                // Show role distribution and player names sections
                roleDistributionSection.style.display = 'block';
                playerNamesSection.style.display = 'block';
                
                // Update role distribution display - EXACTLY like pass-and-play
                const distribution = this.getRoleDistribution(newCount);
                const liberalPercent = Math.round((distribution.liberals / newCount) * 100);
                const fascistPercent = Math.round((distribution.fascists / newCount) * 100);
                const hitlerPercent = Math.round((distribution.hitler / newCount) * 100);
                
                roleInfo.innerHTML = `
                    <div class="role-distribution-compact">
                        <div class="role-item liberal">
                            <div class="role-icon"></div>
                            <div class="role-details">
                                <span class="role-name">Liberal</span>
                                <span class="role-stats">${distribution.liberals} (${liberalPercent}%)</span>
                            </div>
                        </div>
                        <div class="role-item fascist">
                            <div class="role-icon"></div>
                            <div class="role-details">
                                <span class="role-name">Fascist</span>
                                <span class="role-stats">${distribution.fascists} (${fascistPercent}%)</span>
                            </div>
                        </div>
                        <div class="role-item hitler">
                            <div class="role-icon"></div>
                            <div class="role-details">
                                <span class="role-name">Hitler</span>
                                <span class="role-stats">${distribution.hitler} (${hitlerPercent}%)</span>
                            </div>
                        </div>
                    </div>
                `;

                // Smart player input management - preserve existing names EXACTLY like pass-and-play
                const existingInputs = playerInputs.querySelectorAll('.player-input-group');
                const existingNames = Array.from(existingInputs).map(group => {
                    const input = group.querySelector('.player-name-input');
                    return input ? input.value.trim() : '';
                });
                
                // Clear existing inputs
                playerInputs.innerHTML = '';
                
                // Add new inputs, preserving names where possible
                for (let i = 1; i <= newCount; i++) {
                    const inputGroup = document.createElement('div');
                    inputGroup.className = 'player-input-group';
                    
                    // Preserve existing name if available, otherwise use empty placeholder
                    const existingName = existingNames[i - 1] || '';
                    const placeholder = existingName || `Enter player name`;
                    
                    inputGroup.innerHTML = `
                        <label for="player-${i}">Player ${i}:</label>
                        <input type="text" id="player-${i}" class="player-name-input" 
                               placeholder="${placeholder}" value="${existingName}">
                    `;
                    playerInputs.appendChild(inputGroup);
                }

                // Enable create game button
                createGameBtn.disabled = false;
                
                // Update button states
                const minusBtn = document.getElementById('player-minus');
                const plusBtn = document.getElementById('player-plus');
                
                if (minusBtn) {
                    minusBtn.disabled = newCount <= 5;
                }
                if (plusBtn) {
                    plusBtn.disabled = newCount >= 10;
                }
            }
            
            getRoleDistribution(playerCount) {
                const distributions = {
                    5: { liberals: 3, fascists: 1, hitler: 1 },
                    6: { liberals: 4, fascists: 1, hitler: 1 },
                    7: { liberals: 4, fascists: 2, hitler: 1 },
                    8: { liberals: 5, fascists: 2, hitler: 1 },
                    9: { liberals: 6, fascists: 2, hitler: 1 },
                    10: { liberals: 6, fascists: 3, hitler: 1 }
                };
                return distributions[playerCount] || { liberals: 0, fascists: 0, hitler: 0 };
            }
            
            async createGame() {
                if (!this.isBackendAvailable) {
                    this.startOfflineGame();
                    return;
                }
                
                const maxPlayers = this.getCurrentPlayerCount();
                
                // Validate inputs
                if (maxPlayers === 0) {
                    this.showStatus('Please select a player count', 'error');
                    return;
                }
                
                // Collect all player names
                const playerNames = [];
                for (let i = 1; i <= maxPlayers; i++) {
                    const input = document.getElementById(`player-${i}`);
                    const name = input.value.trim();
                    if (!name) {
                        this.showStatus(`Please enter a name for Player ${i}`, 'error');
                        input.focus();
                        return;
                    }
                    playerNames.push(name);
                }
                
                try {
                    this.showStatus('Creating game...', 'info');
                    
                    const response = await fetch(`${this.backendUrl}/api/games.php`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            action: 'create',
                            name: `Secret Hitler Game`,
                            maxPlayers: maxPlayers,
                            playerNames: playerNames
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.currentGame = {
                            id: data.game_id,
                            name: 'Secret Hitler Game',
                            maxPlayers: maxPlayers,
                            playerNames: playerNames
                        };
                        this.currentPlayer = {
                            id: data.host_id,
                            name: playerNames[0], // First player is the host
                            isHost: true
                        };
                        
                        this.showStatus('Game created successfully!', 'success');
                        this.showGameLobby();
                        this.refreshGameInfo();
                    } else {
                        this.showStatus(`Error: ${data.error}`, 'error');
                    }
                    
                } catch (error) {
                    console.error('Error creating game:', error);
                    this.showStatus('Failed to create game. Backend server may be unavailable.', 'error');
                    this.showStatus('Try using offline mode instead.', 'info');
                }
            }
            
            async joinGame() {
                if (!this.isBackendAvailable) {
                    this.showStatus('Cannot join games in offline mode. Backend server required.', 'error');
                    return;
                }
                
                const gameId = document.getElementById('game-id-input').value.trim();
                const playerName = document.getElementById('player-name-select').value;
                
                // Validation
                if (!gameId) {
                    this.showStatus('Please enter a Game ID', 'error');
                    return;
                }
                
                if (!playerName) {
                    this.showStatus('Please select your name from the available options', 'error');
                    return;
                }
                
                try {
                    this.showStatus('Joining game...', 'info');
                    
                    const response = await fetch(`${this.backendUrl}/api/games.php`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            action: 'join',
                            gameId: gameId,
                            playerName: playerName
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.currentGame = { id: gameId };
                        this.currentPlayer = {
                            id: data.player_id,
                            name: playerName,
                            isHost: false
                        };
                        
                        this.showStatus('Joined game successfully!', 'success');
                        this.showGameLobby();
                        this.refreshGameInfo();
                    } else {
                        this.showStatus(`Error: ${data.error}`, 'error');
                    }
                    
                } catch (error) {
                    console.error('Error joining game:', error);
                    this.showStatus('Failed to join game. Backend server may be unavailable.', 'error');
                }
            }
            
            async refreshGameInfo() {
                if (!this.currentGame || !this.isBackendAvailable) return;
                
                try {
                    const response = await fetch(`${this.backendUrl}/api/games.php?id=${this.currentGame.id}`);
                    const data = await response.json();
                    
                    if (data.success) {
                        this.updateLobbyDisplay(data);
                    }
                } catch (error) {
                    console.error('Error refreshing game info:', error);
                }
            }
            
            updateLobbyDisplay(gameData) {
                // Update game info
                document.getElementById('lobby-game-name').textContent = gameData.game.name;
                document.getElementById('lobby-game-id').textContent = gameData.game.id;
                document.getElementById('player-count').textContent = gameData.game.current_players;
                document.getElementById('max-player-count').textContent = gameData.game.max_players;
                
                // Update players list
                const playersContainer = document.getElementById('players-container');
                playersContainer.innerHTML = '';
                
                gameData.players.forEach(player => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `player-item ${player.is_host ? 'player-host' : ''}`;
                    playerDiv.innerHTML = `
                        <span>${player.name}</span>
                        <span>${player.is_host ? ' Host' : ''}</span>
                    `;
                    playersContainer.appendChild(playerDiv);
                });
                
                // Show/hide start button for host
                const startBtn = document.getElementById('start-game-btn');
                if (this.currentPlayer.isHost && gameData.game.status === 'lobby') {
                    startBtn.style.display = 'block';
                } else {
                    startBtn.style.display = 'none';
                }
            }
            
            async startGame() {
                if (!this.currentGame || !this.currentPlayer.isHost) return;
                
                try {
                    this.showStatus('Starting game...', 'info');
                    
                    const response = await fetch(`${this.backendUrl}/api/games.php`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            action: 'start',
                            gameId: this.currentGame.id,
                            hostId: this.currentPlayer.id
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.success) {
                        this.showStatus('Game started! Initializing game mechanics...', 'success');
                        
                        // Initialize the Secret Hitler game
                        const playerNames = this.currentGame.playerNames || [];
                        if (playerNames.length > 0) {
                            game = new SecretHitlerGame(playerNames);
                            this.showGameMechanics();
                        } else {
                            this.showStatus('Error: No player names available', 'error');
                        }
                    } else {
                        this.showStatus(`Error: ${data.error}`, 'error');
                    }
                    
                } catch (error) {
                    console.error('Error starting game:', error);
                    this.showStatus('Failed to start game. Backend server may be unavailable.', 'error');
                }
            }
            
            showGameMechanics() {
                // Hide lobby and show game mechanics
                document.getElementById('game-lobby').classList.remove('active');
                document.getElementById('game-mechanics').style.display = 'block';
                
                // Update page title
                const subtitle = document.getElementById('page-subtitle');
                if (subtitle) {
                    subtitle.textContent = 'Game in Progress';
                }
                
                // Setup game control event listeners
                this.setupGameControlListeners();
            }
            
            setupGameControlListeners() {
                // End game button
                const endGameBtn = document.getElementById('end-game-btn');
                if (endGameBtn) {
                    endGameBtn.addEventListener('click', () => {
                        if (confirm('Are you sure you want to end the game?')) {
                            this.endGame();
                        }
                    });
                }
                
                // Back to lobby button
                const backToLobbyBtn = document.getElementById('back-to-lobby-btn');
                if (backToLobbyBtn) {
                    backToLobbyBtn.addEventListener('click', () => {
                        this.showGameLobby();
                    });
                }
            }
            
            endGame() {
                if (game) {
                    game.gameOver = true;
                    game.winner = 'ended';
                    game.logGameEvent('phase', 'Game ended by host');
                    game.updateGameDisplay();
                }
                
                this.showStatus('Game ended', 'info');
            }
            
            leaveGame() {
                this.currentGame = null;
                this.currentPlayer = null;
                this.hideGameLobby();
                window.history.back();
            }
            
            showGameLobby() {
                // Hide game mechanics and show lobby
                document.getElementById('game-mechanics').style.display = 'none';
                document.getElementById('game-lobby').classList.add('active');
                
                // Update page title
                const subtitle = document.getElementById('page-subtitle');
                if (subtitle) {
                    subtitle.textContent = 'Game Lobby';
                }
                
                // Reset game if exists
                if (game) {
                    game = null;
                }
            }
            

            
            hideGameLobby() {
                document.getElementById('game-lobby').classList.remove('active');
            }
            
            showStatus(message, type = 'info') {
                const statusContainer = document.getElementById('status-container');
                const statusDiv = document.createElement('div');
                statusDiv.className = `status-message status-${type}`;
                statusDiv.textContent = message;
                
                statusContainer.appendChild(statusDiv);
                
                // Auto-remove after 5 seconds
                setTimeout(() => {
                    statusDiv.remove();
                }, 5000);
            }

            updateJoinButtonState() {
                const gameIdInput = document.getElementById('game-id-input');
                const playerNameSelect = document.getElementById('player-name-select');
                const joinBtn = document.querySelector('#join-game-form .btn-primary');

                if (gameIdInput && playerNameSelect && joinBtn) {
                    const gameId = gameIdInput.value.trim();
                    const playerName = playerNameSelect.value;

                    if (gameId.length >= 3 && playerName && this.isBackendAvailable) {
                        joinBtn.disabled = false;
                    } else {
                        joinBtn.disabled = true;
                    }
                }
            }
        }
        
        // Initialize the multi-device game
        const multiDeviceGame = new MultiDeviceGame();
        
        // Auto-refresh game info every 5 seconds when in lobby
        setInterval(() => {
            if (multiDeviceGame.currentGame) {
                multiDeviceGame.refreshGameInfo();
            }
        }, 5000);
        
        // Secret Hitler Game Engine
        class SecretHitlerGame {
            constructor(players) {
                this.players = players;
                this.playerCount = players.length;
                this.currentTurn = 1;
                this.currentPhase = 'setup';
                this.currentPresident = 0;
                this.currentChancellor = null;
                this.liberalPolicies = 0;
                this.fascistPolicies = 0;
                this.electionTracker = 0;
                this.gameOver = false;
                this.winner = null;
                
                // Game state
                this.playerRoles = {};
                this.policyDeck = [];
                this.discardPile = [];
                this.policyStacks = [];
                this.bonusCard = null;
                this.votes = [];
                this.gameLog = [];
                
                this.initializeGame();
            }
            
            initializeGame() {
                this.logGameEvent('phase', 'Game initialized with ' + this.playerCount + ' players');
                this.randomizePlayerOrder();
                this.assignRoles();
                this.revealCompanions();
                this.chooseFirstPresident();
                this.setupPolicyCards();
                this.logGameEvent('phase', 'Game setup complete. Ready to begin!');
            }
            
            randomizePlayerOrder() {
                // Fisher-Yates shuffle
                for (let i = this.players.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.players[i], this.players[j]] = [this.players[j], this.players[i]];
                }
                this.logGameEvent('action', 'Player order randomized');
            }
            
            assignRoles() {
                const distribution = this.getRoleDistribution();
                const roles = [];
                
                // Add roles based on distribution
                for (let i = 0; i < distribution.liberals; i++) {
                    roles.push('liberal');
                }
                for (let i = 0; i < distribution.fascists; i++) {
                    roles.push('fascist');
                }
                roles.push('hitler');
                
                // Shuffle roles and assign to players
                this.shuffleArray(roles);
                this.playerRoles = {};
                this.players.forEach((player, index) => {
                    this.playerRoles[player] = roles[index];
                });
                
                this.logGameEvent('action', 'Roles assigned to players');
            }
            
            getRoleDistribution() {
                const distributions = {
                    5: { liberals: 3, fascists: 1, hitler: 1 },
                    6: { liberals: 4, fascists: 1, hitler: 1 },
                    7: { liberals: 4, fascists: 2, hitler: 1 },
                    8: { liberals: 5, fascists: 2, hitler: 1 },
                    9: { liberals: 6, fascists: 2, hitler: 1 },
                    10: { liberals: 6, fascists: 3, hitler: 1 }
                };
                return distributions[this.playerCount] || distributions[5];
            }
            
            revealCompanions() {
                // Reveal fascist companions to fascists and Hitler
                const fascists = this.players.filter(player => 
                    this.playerRoles[player] === 'fascist' || this.playerRoles[player] === 'hitler'
                );
                
                this.logGameEvent('action', 'Fascist companions revealed to fascist team');
                this.logGameEvent('action', 'Fascist team: ' + fascists.join(', '));
            }
            
            chooseFirstPresident() {
                // Randomly choose first president
                this.currentPresident = Math.floor(Math.random() * this.playerCount);
                this.logGameEvent('action', this.players[this.currentPresident] + ' chosen as first President');
            }
            
            setupPolicyCards() {
                // Create policy deck: 6 Liberal, 11 Fascist
                this.policyDeck = [];
                for (let i = 0; i < 6; i++) {
                    this.policyDeck.push('liberal');
                }
                for (let i = 0; i < 11; i++) {
                    this.policyDeck.push('fascist');
                }
                
                this.shuffleArray(this.policyDeck);
                
                // Create stacks of three
                this.policyStacks = [];
                while (this.policyDeck.length >= 3) {
                    this.policyStacks.push(this.policyDeck.splice(0, 3));
                }
                
                // Set aside remaining cards as bonus
                this.bonusCard = this.policyDeck.length > 0 ? this.policyDeck.pop() : null;
                
                this.logGameEvent('action', 'Policy cards shuffled into ' + this.policyStacks.length + ' stacks of three');
                if (this.bonusCard) {
                    this.logGameEvent('action', 'Bonus card set aside');
                }
            }
            
            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }
            
            startElection() {
                this.currentPhase = 'election';
                this.votes = [];
                this.logGameEvent('phase', 'Election phase begins');
                this.logGameEvent('action', this.players[this.currentPresident] + ' must choose a Chancellor');
                this.updateGameDisplay();
            }
            
            chooseChancellor(chancellorIndex) {
                if (this.currentPhase !== 'election') return false;
                
                // Cannot choose the same person as last election
                if (this.currentChancellor === chancellorIndex) {
                    this.logGameEvent('action', 'Cannot choose the same Chancellor twice in a row');
                    return false;
                }
                
                this.currentChancellor = chancellorIndex;
                this.logGameEvent('action', this.players[this.currentPresident] + ' chose ' + this.players[this.currentChancellor] + ' as Chancellor');
                this.startVoting();
                return true;
            }
            
            startVoting() {
                this.currentPhase = 'voting';
                this.logGameEvent('phase', 'Voting phase begins');
                this.logGameEvent('action', 'All players must vote Ja or Nein on the election');
                this.updateGameDisplay();
            }
            
            submitVote(playerIndex, vote) {
                if (this.currentPhase !== 'voting') return false;
                if (this.votes.some(v => v.player === playerIndex)) return false;
                
                this.votes.push({ player: playerIndex, vote: vote });
                this.logGameEvent('vote', this.players[playerIndex] + ' voted ' + vote);
                
                if (this.votes.length === this.playerCount) {
                    this.resolveElection();
                }
                
                this.updateGameDisplay();
                return true;
            }
            
            resolveElection() {
                const jaVotes = this.votes.filter(v => v.vote === 'ja').length;
                const neinVotes = this.votes.filter(v => v.vote === 'nein').length;
                
                if (jaVotes > neinVotes) {
                    // Election successful
                    this.electionTracker = 0;
                    this.logGameEvent('action', 'Election successful! ' + jaVotes + ' Ja vs ' + neinVotes + ' Nein');
                    this.startLegislation();
                } else {
                    // Election failed
                    this.electionTracker++;
                    this.logGameEvent('action', 'Election failed! ' + neinVotes + ' Nein vs ' + jaVotes + ' Ja');
                    this.logGameEvent('action', 'Election tracker: ' + this.electionTracker + '/3');
                    
                    if (this.electionTracker >= 3) {
                        this.enactTopPolicy();
                        this.electionTracker = 0;
                    }
                    
                    this.nextTurn();
                }
            }
            
            startLegislation() {
                this.currentPhase = 'legislation';
                this.logGameEvent('phase', 'Legislation phase begins');
                this.logGameEvent('action', 'President must choose a policy stack');
                this.updateGameDisplay();
            }
            
            choosePolicyStack(stackIndex) {
                if (this.currentPhase !== 'legislation') return false;
                if (stackIndex < 0 || stackIndex >= this.policyStacks.length) return false;
                
                const selectedStack = this.policyStacks[stackIndex];
                this.logGameEvent('action', this.players[this.currentPresident] + ' chose policy stack ' + (stackIndex + 1));
                this.logGameEvent('action', 'Stack contains: ' + selectedStack.join(', '));
                
                // President discards one card
                this.currentPhase = 'president-discard';
                this.logGameEvent('phase', this.players[this.currentPresident] + ' must discard one policy card');
                this.updateGameDisplay();
                return true;
            }
            
            presidentDiscard(cardIndex) {
                if (this.currentPhase !== 'president-discard') return false;
                
                const selectedStack = this.policyStacks.find(stack => stack.length === 3);
                if (!selectedStack || cardIndex < 0 || cardIndex >= selectedStack.length) return false;
                
                const discardedCard = selectedStack.splice(cardIndex, 1)[0];
                this.discardPile.push(discardedCard);
                this.logGameEvent('action', this.players[this.currentPresident] + ' discarded ' + discardedCard + ' policy');
                
                // Chancellor chooses one to enact
                this.currentPhase = 'chancellor-choose';
                this.logGameEvent('phase', this.players[this.currentChancellor] + ' must choose one policy to enact');
                this.updateGameDisplay();
                return true;
            }
            
            chancellorEnact(cardIndex) {
                if (this.currentPhase !== 'chancellor-choose') return false;
                
                const selectedStack = this.policyStacks.find(stack => stack.length === 2);
                if (!selectedStack || cardIndex < 0 || cardIndex >= selectedStack.length) return false;
                
                const enactedCard = selectedStack.splice(cardIndex, 1)[0];
                this.enactPolicy(enactedCard);
                
                // Remove the stack
                this.policyStacks = this.policyStacks.filter(stack => stack.length > 0);
                
                // Check for superpowers
                this.checkSuperpowers();
                
                // Check win conditions
                if (!this.checkWinConditions()) {
                    this.nextTurn();
                }
                
                return true;
            }
            
            enactPolicy(policy) {
                if (policy === 'liberal') {
                    this.liberalPolicies++;
                    this.logGameEvent('policy', 'Liberal policy enacted! Total: ' + this.liberalPolicies + '/5');
                } else {
                    this.fascistPolicies++;
                    this.logGameEvent('policy', 'Fascist policy enacted! Total: ' + this.fascistPolicies + '/6');
                }
                
                this.updateGameDisplay();
            }
            
            enactTopPolicy() {
                if (this.policyDeck.length === 0) return;
                
                const policy = this.policyDeck.pop();
                this.enactPolicy(policy);
                this.logGameEvent('action', 'Top policy enacted due to election tracker failure');
            }
            
            checkSuperpowers() {
                if (this.fascistPolicies >= 3 && this.fascistPolicies <= 5) {
                    this.logGameEvent('action', 'Superpower unlocked! President gains special abilities');
                    // TODO: Implement superpower mechanics
                }
            }
            
            checkWinConditions() {
                // Liberal win
                if (this.liberalPolicies >= 5) {
                    this.gameOver = true;
                    this.winner = 'liberal';
                    this.logGameEvent('phase', 'GAME OVER! Liberals win with 5 policies!');
                    this.updateGameDisplay();
                    return true;
                }
                
                // Fascist win
                if (this.fascistPolicies >= 6) {
                    this.gameOver = true;
                    this.winner = 'fascist';
                    this.logGameEvent('phase', 'GAME OVER! Fascists win with 6 policies!');
                    this.updateGameDisplay();
                    return true;
                }
                
                return false;
            }
            
            nextTurn() {
                this.currentTurn++;
                this.currentPresident = (this.currentPresident + 1) % this.playerCount;
                this.currentChancellor = null;
                this.votes = [];
                
                this.logGameEvent('phase', 'Turn ' + this.currentTurn + ' begins');
                this.logGameEvent('action', this.players[this.currentPresident] + ' is now President');
                
                this.startElection();
            }
            
            logGameEvent(type, message) {
                const timestamp = new Date().toLocaleTimeString();
                this.gameLog.push({
                    type: type,
                    message: message,
                    timestamp: timestamp
                });
                
                // Keep only last 50 log entries
                if (this.gameLog.length > 50) {
                    this.gameLog = this.gameLog.slice(-50);
                }
                
                this.updateGameLog();
            }
            
            updateGameLog() {
                const logContainer = document.getElementById('game-log-entries');
                if (!logContainer) return;
                
                logContainer.innerHTML = '';
                this.gameLog.slice().reverse().forEach(entry => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${entry.type}`;
                    logEntry.innerHTML = `
                        <div class="log-timestamp">${entry.timestamp}</div>
                        <div class="log-message">${entry.message}</div>
                    `;
                    logContainer.appendChild(logEntry);
                });
            }
            
            updateGameDisplay() {
                this.updatePhaseDisplay();
                this.updatePolicyTracks();
                this.updateElectionTracker();
                this.updateGameActions();
            }
            
            updatePhaseDisplay() {
                const phaseElement = document.getElementById('current-phase');
                const turnElement = document.getElementById('current-turn');
                
                if (phaseElement) {
                    phaseElement.textContent = this.currentPhase.replace('-', ' ').toUpperCase();
                }
                if (turnElement) {
                    turnElement.textContent = this.currentTurn;
                }
            }
            
            updatePolicyTracks() {
                const liberalTrack = document.getElementById('liberal-track');
                const fascistTrack = document.getElementById('fascist-track');
                
                if (liberalTrack) {
                    liberalTrack.innerHTML = '';
                    for (let i = 0; i < 5; i++) {
                        const space = document.createElement('div');
                        space.className = `track-space ${i < this.liberalPolicies ? 'filled' : ''} ${i === 4 && this.liberalPolicies >= 5 ? 'win' : ''}`;
                        space.textContent = i + 1;
                        liberalTrack.appendChild(space);
                    }
                }
                
                if (fascistTrack) {
                    fascistTrack.innerHTML = '';
                    for (let i = 0; i < 6; i++) {
                        const space = document.createElement('div');
                        space.className = `track-space ${i < this.fascistPolicies ? 'filled' : ''} ${i === 5 && this.fascistPolicies >= 6 ? 'win' : ''} ${i >= 2 && i <= 4 ? 'power' : ''}`;
                        space.textContent = i + 1;
                        fascistTrack.appendChild(space);
                    }
                }
                
                // Update track counts
                const liberalCount = document.querySelector('.liberal-track .track-count');
                const fascistCount = document.querySelector('.fascist-track .track-count');
                
                if (liberalCount) liberalCount.textContent = this.liberalPolicies + '/5';
                if (fascistCount) fascistCount.textContent = this.fascistPolicies + '/6';
            }
            
            updateElectionTracker() {
                const tracker = document.getElementById('election-tracker');
                if (!tracker) return;
                
                tracker.innerHTML = '';
                for (let i = 0; i < 3; i++) {
                    const space = document.createElement('div');
                    space.className = `tracker-space ${i < this.electionTracker ? 'filled' : ''}`;
                    tracker.appendChild(space);
                }
            }
            
            updateGameActions() {
                const actionsContainer = document.getElementById('game-actions');
                if (!actionsContainer) return;
                
                if (this.gameOver) {
                    this.showGameOverActions(actionsContainer);
                    return;
                }
                
                switch (this.currentPhase) {
                    case 'election':
                        this.showElectionActions(actionsContainer);
                        break;
                    case 'voting':
                        this.showVotingActions(actionsContainer);
                        break;
                    case 'legislation':
                        this.showLegislationActions(actionsContainer);
                        break;
                    case 'president-discard':
                        this.showPresidentDiscardActions(actionsContainer);
                        break;
                    case 'chancellor-choose':
                        this.showChancellorChooseActions(actionsContainer);
                        break;
                    default:
                        actionsContainer.innerHTML = '<p>Game phase not recognized</p>';
                }
            }
            
            showElectionActions(container) {
                container.innerHTML = `
                    <div class="action-phase">
                        <h3>Choose Chancellor</h3>
                        <p class="action-description">
                            ${this.players[this.currentPresident]} (President) must choose a Chancellor for this election.
                        </p>
                        <div class="action-buttons">
                            ${this.players.map((player, index) => 
                                index !== this.currentPresident && index !== this.currentChancellor ?
                                    `<button class="action-btn" onclick="game.chooseChancellor(${index})">${player}</button>` :
                                    ''
                            ).join('')}
                        </div>
                    </div>
                `;
            }
            
            showVotingActions(container) {
                const remainingVotes = this.playerCount - this.votes.length;
                container.innerHTML = `
                    <div class="action-phase">
                        <h3>Vote on Election</h3>
                        <p class="action-description">
                            All players must vote Ja or Nein on the election of ${this.players[this.currentChancellor]} as Chancellor.
                            ${remainingVotes > 0 ? remainingVotes + ' votes remaining.' : 'All votes submitted.'}
                        </p>
                        <div class="action-buttons">
                            ${this.players.map((player, index) => {
                                const hasVoted = this.votes.some(v => v.player === index);
                                return hasVoted ? 
                                    `<button class="action-btn secondary" disabled>${player} - Voted</button>` :
                                    `<div style="display: inline-block; margin: 0 0.5rem;">
                                        <button class="action-btn" onclick="game.submitVote(${index}, 'ja')">${player} - Ja</button>
                                        <button class="action-btn secondary" onclick="game.submitVote(${index}, 'nein')">${player} - Nein</button>
                                    </div>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            showLegislationActions(container) {
                container.innerHTML = `
                    <div class="action-phase">
                        <h3>Choose Policy Stack</h3>
                        <p class="action-description">
                            ${this.players[this.currentPresident]} (President) must choose one of the remaining policy stacks.
                        </p>
                        <div class="action-buttons">
                            ${this.policyStacks.map((stack, index) => 
                                `<button class="action-btn" onclick="game.choosePolicyStack(${index})">Stack ${index + 1} (${stack.length} cards)</button>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }
            
            showPresidentDiscardActions(container) {
                const selectedStack = this.policyStacks.find(stack => stack.length === 3);
                if (!selectedStack) return;
                
                container.innerHTML = `
                    <div class="action-phase">
                        <h3>Discard Policy Card</h3>
                        <p class="action-description">
                            ${this.players[this.currentPresident]} (President) must discard one policy card from the selected stack.
                            Remaining cards: ${selectedStack.join(', ')}
                        </p>
                        <div class="action-buttons">
                            ${selectedStack.map((card, index) => 
                                `<button class="action-btn" onclick="game.presidentDiscard(${index})">Discard ${card}</button>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }
            
            showChancellorChooseActions(container) {
                const selectedStack = this.policyStacks.find(stack => stack.length === 2);
                if (!selectedStack) return;
                
                container.innerHTML = `
                    <div class="action-phase">
                        <h3>Enact Policy</h3>
                        <p class="action-description">
                            ${this.players[this.currentChancellor]} (Chancellor) must choose one policy to enact.
                            Available policies: ${selectedStack.join(', ')}
                        </p>
                        <div class="action-buttons">
                            ${selectedStack.map((card, index) => 
                                `<button class="action-btn" onclick="game.chancellorEnact(${index})">Enact ${card}</button>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }
            
            showGameOverActions(container) {
                container.innerHTML = `
                    <div class="action-phase">
                        <h3>Game Over!</h3>
                        <p class="action-description">
                            The ${this.winner} team has won the game!
                        </p>
                        <div class="final-score">
                            <p><strong>Final Score:</strong></p>
                            <p>Liberal Policies: ${this.liberalPolicies}/5</p>
                            <p>Fascist Policies: ${this.fascistPolicies}/6</p>
                        </div>
                    </div>
                `;
            }

            // Integrated Game Methods
            startIntegratedGame(playerNames) {
                this.gameState.players = playerNames;
                this.gameState.playerCount = playerNames.length;
                this.gameState.currentPhase = 'election';
                this.gameState.currentTurn = 1;
                this.gameState.currentPresident = 0;
                
                // Initialize policy stacks
                this.setupPolicyStacks();
                
                // Log game start
                this.logGameEvent('phase', 'Game started with ' + this.gameState.playerCount + ' players');
                this.logGameEvent('action', 'Roles assigned and policy deck shuffled');
                
                // Show game mechanics
                this.showGameMechanics();
                this.updateGameDisplay();
            }

            setupPolicyStacks() {
                // Create policy stacks for the game
                this.gameState.policyStacks = [
                    ['liberal', 'fascist', 'liberal'],
                    ['fascist', 'fascist', 'liberal'],
                    ['liberal', 'liberal', 'fascist']
                ];
                this.logGameEvent('action', 'Policy cards organized into ' + this.gameState.policyStacks.length + ' stacks');
            }

            nextPhase() {
                switch (this.gameState.currentPhase) {
                    case 'election':
                        this.gameState.currentPhase = 'legislation';
                        this.logGameEvent('phase', 'Legislation phase begins');
                        break;
                    case 'legislation':
                        this.gameState.currentPhase = 'president-discard';
                        this.gameState.currentPolicyStack = this.gameState.policyStacks[0];
                        this.logGameEvent('phase', 'President must discard one policy card');
                        break;
                    case 'president-discard':
                        this.gameState.currentPhase = 'chancellor-choose';
                        this.logGameEvent('phase', 'Chancellor must choose one policy to enact');
                        break;
                    case 'chancellor-choose':
                        this.gameState.currentPhase = 'executive';
                        this.gameState.executivePowers = ['investigate', 'special_election'];
                        this.logGameEvent('phase', 'Executive powers unlocked!');
                        break;
                    case 'executive':
                        this.gameState.currentPhase = 'election';
                        this.gameState.currentTurn++;
                        this.gameState.currentPresident = (this.gameState.currentPresident + 1) % this.gameState.playerCount;
                        this.logGameEvent('phase', 'Turn ' + this.gameState.currentTurn + ' begins');
                        this.logGameEvent('action', this.gameState.players[this.gameState.currentPresident] + ' is now President');
                        break;
                }
                this.updateGameDisplay();
            }

            logGameEvent(type, message) {
                const timestamp = new Date().toLocaleTimeString();
                this.gameState.gameLog.push({
                    type: type,
                    message: message,
                    timestamp: timestamp
                });
                
                // Keep only last 50 log entries
                if (this.gameState.gameLog.length > 50) {
                    this.gameState.gameLog = this.gameState.gameLog.slice(-50);
                }
            }

            updateGameDisplay() {
                this.updatePhaseDisplay();
                this.updatePolicyTracks();
                this.updateElectionTracker();
                this.updateGameActions();
                this.updateGameLog();
            }

            updatePhaseDisplay() {
                const phaseElement = document.getElementById('current-phase');
                const turnElement = document.getElementById('current-turn');
                
                if (phaseElement) {
                    phaseElement.textContent = this.gameState.currentPhase.replace('-', ' ').toUpperCase();
                }
                if (turnElement) {
                    turnElement.textContent = this.gameState.currentTurn;
                }
            }

            updatePolicyTracks() {
                const liberalTrack = document.getElementById('liberal-track');
                const fascistTrack = document.getElementById('fascist-track');
                
                if (liberalTrack) {
                    liberalTrack.innerHTML = '';
                    for (let i = 0; i < 5; i++) {
                        const space = document.createElement('div');
                        space.className = `track-space ${i < this.gameState.liberalPolicies ? 'filled' : ''} ${i === 4 && this.gameState.liberalPolicies >= 5 ? 'win' : ''}`;
                        space.textContent = i + 1;
                        liberalTrack.appendChild(space);
                    }
                }
                
                if (fascistTrack) {
                    fascistTrack.innerHTML = '';
                    for (let i = 0; i < 6; i++) {
                        const space = document.createElement('div');
                        space.className = `track-space ${i < this.gameState.fascistPolicies ? 'filled' : ''} ${i === 5 && this.gameState.fascistPolicies >= 6 ? 'win' : ''} ${i >= 2 && i <= 4 ? 'power' : ''}`;
                        space.textContent = i + 1;
                        fascistTrack.appendChild(space);
                    }
                }
                
                // Update track counts
                const liberalCount = document.querySelector('.liberal-track .track-count');
                const fascistCount = document.querySelector('.fascist-track .track-count');
                
                if (liberalCount) liberalCount.textContent = this.gameState.liberalPolicies + '/5';
                if (fascistCount) fascistCount.textContent = this.gameState.fascistPolicies + '/6';
            }

            updateElectionTracker() {
                const tracker = document.getElementById('election-tracker');
                if (!tracker) return;
                
                tracker.innerHTML = '';
                for (let i = 0; i < 3; i++) {
                    const space = document.createElement('div');
                    space.className = `tracker-space ${i < this.gameState.electionTracker ? 'filled' : ''}`;
                    space.textContent = i + 1;
                    tracker.appendChild(space);
                }
            }

            updateGameActions() {
                const actionsContainer = document.getElementById('game-actions');
                if (!actionsContainer) return;
                
                switch (this.gameState.currentPhase) {
                    case 'election':
                        actionsContainer.innerHTML = `
                            <div class="action-phase">
                                <h3>Choose Chancellor</h3>
                                <p class="action-description">
                                    ${this.gameState.players[this.gameState.currentPresident]} (President) must choose a Chancellor for this election.
                                </p>
                                <div class="chancellor-options">
                                    ${this.gameState.players.map((player, index) => 
                                        index !== this.gameState.currentPresident ?
                                            `<button class="chancellor-btn btn btn-primary" onclick="multiDeviceGame.selectChancellor(${index})">${player}</button>` :
                                            ''
                                    ).join('')}
                                </div>
                            </div>
                        `;
                        break;
                    case 'legislation':
                        actionsContainer.innerHTML = `
                            <div class="action-phase">
                                <h3>Choose Policy Stack</h3>
                                <p class="action-description">
                                    ${this.gameState.players[this.gameState.currentPresident]} (President) must choose one of the remaining policy stacks.
                                </p>
                                <div class="policy-stack-options">
                                    ${this.gameState.policyStacks.map((stack, index) => 
                                        `<button class="stack-btn btn btn-primary" onclick="multiDeviceGame.selectPolicyStack(${index})">Stack ${index + 1} (${stack.length} cards)</button>`
                                    ).join('')}
                                </div>
                            </div>
                        `;
                        break;
                    case 'president-discard':
                        actionsContainer.innerHTML = `
                            <div class="action-phase">
                                <h3>Discard Policy Card</h3>
                                <p class="action-description">
                                    ${this.gameState.players[this.gameState.currentPresident]} (President) must discard one policy card from the selected stack.
                                    Remaining cards: ${this.gameState.currentPolicyStack.join(', ')}
                                </p>
                                <div class="discard-options">
                                    ${this.gameState.currentPolicyStack.map((card, index) => 
                                        `<button class="discard-btn btn btn-secondary" onclick="multiDeviceGame.discardPolicy(${index})">Discard ${card}</button>`
                                    ).join('')}
                                </div>
                            </div>
                        `;
                        break;
                    case 'chancellor-choose':
                        actionsContainer.innerHTML = `
                            <div class="action-phase">
                                <h3>Enact Policy</h3>
                                <p class="action-description">
                                    ${this.gameState.players[this.gameState.currentChancellor] || 'Chancellor'} must choose one policy to enact.
                                    Available policies: ${this.gameState.currentPolicyStack.join(', ')}
                                </p>
                                <div class="enact-options">
                                    ${this.gameState.currentPolicyStack.map((card, index) => 
                                        `<button class="enact-btn btn btn-primary" onclick="multiDeviceGame.enactPolicy(${index})">Enact ${card}</button>`
                                    ).join('')}
                                </div>
                            </div>
                        `;
                        break;
                    case 'executive':
                        actionsContainer.innerHTML = `
                            <div class="action-phase">
                                <h3>Executive Powers</h3>
                                <p class="action-description">
                                    ${this.gameState.players[this.gameState.currentPresident]} (President) has special powers due to fascist policies.
                                </p>
                                <div class="power-options">
                                    ${this.gameState.executivePowers.map(power => 
                                        `<button class="power-btn btn btn-accent" onclick="multiDeviceGame.useExecutivePower('${power}')">Use ${power.replace('_', ' ')}</button>`
                                    ).join('')}
                                </div>
                            </div>
                        `;
                        break;
                    default:
                        actionsContainer.innerHTML = '<p>Game phase not recognized</p>';
                }
            }

            updateGameLog() {
                const logContainer = document.getElementById('game-log-entries');
                if (!logContainer) return;
                
                logContainer.innerHTML = '';
                this.gameState.gameLog.slice().reverse().forEach(entry => {
                    const logEntry = document.createElement('div');
                    logEntry.className = `log-entry ${entry.type}`;
                    logEntry.innerHTML = `
                        <div class="log-timestamp">${entry.timestamp}</div>
                        <div class="log-message">${entry.message}</div>
                    `;
                    logContainer.appendChild(entry);
                });
            }

            // Game action methods
            selectChancellor(chancellorIndex) {
                this.gameState.currentChancellor = chancellorIndex;
                this.gameState.lastChancellor = this.gameState.currentPresident;
                this.logGameEvent('action', this.gameState.players[chancellorIndex] + ' selected as Chancellor');
                this.nextPhase();
            }

            selectPolicyStack(stackIndex) {
                this.gameState.currentPolicyStack = [...this.gameState.policyStacks[stackIndex]];
                this.logGameEvent('action', 'Policy stack ' + (stackIndex + 1) + ' selected');
                this.nextPhase();
            }

            discardPolicy(cardIndex) {
                const discarded = this.gameState.currentPolicyStack.splice(cardIndex, 1)[0];
                this.gameState.presidentDiscarded = discarded;
                this.logGameEvent('action', discarded + ' policy discarded by President');
                this.nextPhase();
            }

            enactPolicy(cardIndex) {
                const enacted = this.gameState.currentPolicyStack.splice(cardIndex, 1)[0];
                if (enacted === 'liberal') {
                    this.gameState.liberalPolicies++;
                } else {
                    this.gameState.fascistPolicies++;
                }
                this.logGameEvent('policy', enacted + ' policy enacted');
                this.nextPhase();
            }

            useExecutivePower(power) {
                this.logGameEvent('action', power.replace('_', ' ') + ' power used');
                this.nextPhase();
            }

            resetGame() {
                this.gameState = {
                    players: this.gameState.players,
                    currentTurn: 1,
                    currentPhase: 'election',
                    currentPresident: 0,
                    currentChancellor: null,
                    liberalPolicies: 0,
                    fascistPolicies: 0,
                    electionTracker: 0,
                    gameOver: false,
                    winner: null,
                    policyStacks: [],
                    currentPolicyStack: null,
                    presidentDiscarded: null,
                    executivePowers: [],
                    gameLog: [],
                    lastChancellor: null,
                    consecutiveFailedElections: 0
                };
                
                this.setupPolicyStacks();
                this.logGameEvent('phase', 'Game reset');
                this.updateGameDisplay();
            }
        }
        
        // Global game instance
        let game = null;
    </script>
</body>
</html>
