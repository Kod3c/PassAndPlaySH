<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lobby - Secret Hitler</title>
    <link rel="stylesheet" href="../styles/app.css">
    <meta name="theme-color" content="#101820">
    <style>
        .badge { display:inline-block; padding: 0.125rem 0.5rem; border: var(--border-medium) solid var(--propaganda-black); background: var(--off-white); font-weight: 700; font-size: var(--font-sm); border-radius: 999px; margin-left: 0.5rem; }
        .player-list-ul { list-style: none; padding-left: 0; margin: 0; display: grid; gap: var(--space-sm); }
        .player-list-item { display: flex; align-items: center; gap: 8px; padding: 0.375rem 0.5rem; background: #fff; border: var(--border-thin) dashed var(--propaganda-black); }
        .player-name { font-weight: 600; letter-spacing: 0.02em; }
        .lobby-actions { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; }
        .lobby-actions .btn { flex: 0 1 auto; }
        @media (max-width: 640px) {
            .lobby-actions { flex-direction: column; align-items: stretch; gap: 10px; }
            .lobby-actions .btn { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="page-wrapper">
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <div class="logo" onclick="window.location.href='../index.html'">
                        <span class="logo-icon">ðŸŽ­</span>
                        <div class="logo-text">
                            <h1>Secret Hitler</h1>
                            <p class="subtitle">Lobby</p>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <main>
            <div class="container">
                <div class="card mb-4">
                    <div class="card-header">
                        <span class="card-icon">ðŸ•’</span>
                        <div>
                            <h2 class="card-title">Game Lobby</h2>
                            <p class="section-description">Waiting for players to join...</p>
                        </div>
                    </div>
                    <div class="card-content">
                        <div id="lobby-info" class="lobby-info"></div>
                        <div id="players-list" class="players-list mt-3"></div>

                        <div class="invite-section mt-3">
                            <div class="invite-row">
                                <input id="invite-link" class="form-control" type="text" readonly>
                                <button id="copy-invite-btn" class="btn btn-secondary">Copy Invite</button>
                            </div>
                            <small class="form-help">Share this link with other players to join the lobby.</small>
                        </div>

                        <div class="lobby-actions mt-4">
                            <button id="start-game-btn" class="btn btn-primary btn-lg" disabled>Continue</button>
                            <button id="leave-lobby-btn" class="btn btn-outline btn-lg">ðŸšª Leave Lobby</button>
                            <button id="cancel-game-btn" class="btn btn-outline btn-lg">ðŸ›‘ Cancel Game</button>
                            <button class="btn btn-outline btn-lg" onclick="window.location.href='../index.html'">Back to Home</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <footer class="main-footer">
            <div class="container">
                <div class="footer-content">
                    <p class="footer-text">Built for offline play - no accounts or servers required</p>
                    <div class="footer-links">
                        <a href="../pages/rules.html" class="footer-link">ðŸ“– Rules</a>
                        <span class="footer-separator">â€¢</span>
                        <a href="../index.html" class="footer-link">ðŸŽ® Play</a>
                    </div>
                </div>
            </div>
        </footer>
    </div>

    <script type="module">
        import { onGameSnapshot, getGame, logPublic, logPrivate, logPartied, logSilent } from '../js/db.js';
        import { app } from '../js/firebase.js';
        import { getFirestore, doc, updateDoc, serverTimestamp, collection, query, where, getDocs, setDoc, orderBy } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
        (function() {
            const lobbyInfo = document.getElementById('lobby-info');
            const playersList = document.getElementById('players-list');
            const inviteInput = document.getElementById('invite-link');
            const copyInviteBtn = document.getElementById('copy-invite-btn');
            const startBtn = document.getElementById('start-game-btn');

            const db = getFirestore(app);
            const PRESENT_WINDOW_MS = 90 * 1000; // 90s to match faster reclaim on join page
            const HEARTBEAT_INTERVAL_MS = 25 * 1000; // 25s
            let heartbeatTimer = null;
            let removalHandled = false;

            function handleGameRemoved() {
                if (removalHandled) return;
                removalHandled = true;
                try { alert('This game is no longer available. Returning to home.'); } catch (_) {}
                window.location.href = '../index.html';
            }

            async function ensureAuth() {
                const auth = getAuth(app);
                if (!auth.currentUser) await signInAnonymously(auth);
                return auth.currentUser;
            }

            async function autoClaimHost(gameId) {
                // Attempt to claim Player 1 (seat 1) if it has no uid yet
                try {
                    const authUser = await ensureAuth();
                    if (!authUser) return null;
                    const playersQ = query(collection(doc(db, 'games', gameId), 'players'), where('seat', '==', 1));
                    const snap = await getDocs(playersQ);
                    for (const d of snap.docs) {
                        const data = d.data() || {};
                        if (!data.uid) {
                            await updateDoc(d.ref, { uid: authUser.uid, lastSeen: serverTimestamp() });
                            try { sessionStorage.setItem(`sh_playerId_${gameId}`, d.id); } catch (_) {}
                            try { await logSilent(gameId, 'Auto-claimed host seat', { type: 'host', actorId: d.id, meta: { seat: 1 } }); } catch (_) {}
                            return d.id;
                        }
                    }
                } catch (_) {}
                return null;
            }

            function getGameIdFromUrl() {
                const params = new URLSearchParams(window.location.search);
                return params.get('game') || localStorage.getItem('sh_currentGameId') || '';
            }

            function render(game, players) {
                if (!game) { handleGameRemoved(); return; }
                const joinUrl = window.location.origin + window.location.pathname.replace(/\/pages\/lobby\.html$/, '/pages/join.html') + '?game=' + encodeURIComponent(game.id);
                inviteInput.value = joinUrl;

                // Safely render lobby info without injecting user strings as HTML
                lobbyInfo.innerHTML = '';
                const contentRoot = document.querySelector('.card-content');
                const existingReveal = document.getElementById('reveal-container');
                if (existingReveal) existingReveal.remove();
                const headerDiv = document.createElement('div');
                headerDiv.className = 'lobby-header';

                const metaDiv = document.createElement('div');
                metaDiv.className = 'lobby-meta';
                const gameRow = document.createElement('div');
                const gameStrong = document.createElement('strong');
                gameStrong.textContent = 'Game:';
                gameRow.appendChild(gameStrong);
                gameRow.appendChild(document.createTextNode(' '));
                const gameNameSpan = document.createElement('span');
                gameNameSpan.textContent = game.name || 'Secret Hitler Game';
                gameRow.appendChild(gameNameSpan);

                const idRow = document.createElement('div');
                const idStrong = document.createElement('strong');
                idStrong.textContent = 'Game ID:';
                idRow.appendChild(idStrong);
                idRow.appendChild(document.createTextNode(' ' + (game.id || '')));

                const countRow = document.createElement('div');
                const countStrong = document.createElement('strong');
                countStrong.textContent = 'Players Expected:';
                countRow.appendChild(countStrong);
                const expected = (typeof game.playerCount === 'number' && game.playerCount > 0)
                    ? game.playerCount
                    : (players ? players.length : 0);
                countRow.appendChild(document.createTextNode(' ' + expected));

                metaDiv.appendChild(gameRow);
                metaDiv.appendChild(idRow);
                metaDiv.appendChild(countRow);

                const statusDiv = document.createElement('div');
                statusDiv.className = 'lobby-status';
                const statusDot = document.createElement('span');
                statusDot.className = 'status-dot';
                const statusText = document.createElement('span');
                statusText.textContent = 'Waiting for players...';
                statusDiv.appendChild(statusDot);
                statusDiv.appendChild(statusText);

                headerDiv.appendChild(metaDiv);
                headerDiv.appendChild(statusDiv);
                lobbyInfo.appendChild(headerDiv);

                // Identify current player via saved playerId or current auth uid (use raw players list)
                let savedPlayerId = null;
                try { savedPlayerId = sessionStorage.getItem(`sh_playerId_${game.id}`); } catch (_) { savedPlayerId = null; }
                const authUser = getAuth(app).currentUser;
                const currentUid = authUser ? authUser.uid : null;
                let youPlayerId = null;
                if (savedPlayerId && (players || []).some(pl => pl && pl.id === savedPlayerId)) {
                    youPlayerId = savedPlayerId;
                } else if (currentUid) {
                    const match = (players || []).find(pl => pl && pl.uid === currentUid);
                    if (match) youPlayerId = match.id;
                }
                function isYou(playerDoc) {
                    return Boolean(playerDoc && youPlayerId && playerDoc.id === youPlayerId);
                }

                // Deduplicate by name with smarter preference: you > present > has uid > newest lastSeen
                const now = Date.now();
                function getLastSeenMs(doc) {
                    try { return doc && doc.lastSeen && doc.lastSeen.toDate ? doc.lastSeen.toDate().getTime() : 0; } catch (_) { return 0; }
                }
                function isDocPresent(doc) {
                    const ms = getLastSeenMs(doc);
                    return Boolean(doc && doc.uid) && ms > 0 && (now - ms <= PRESENT_WINDOW_MS);
                }
                function pickPreferred(existing, candidate) {
                    if (!existing) return candidate;
                    if (!candidate) return existing;
                    if (isYou(candidate)) return candidate;
                    if (isYou(existing)) return existing;
                    const ePresent = isDocPresent(existing);
                    const cPresent = isDocPresent(candidate);
                    if (cPresent && !ePresent) return candidate;
                    if (!cPresent && ePresent) return existing;
                    if (candidate.uid && !existing.uid) return candidate;
                    if (!candidate.uid && existing.uid) return existing;
                    const eLast = getLastSeenMs(existing);
                    const cLast = getLastSeenMs(candidate);
                    if (cLast > eLast) return candidate;
                    return existing;
                }
                const nameToPlayer = new Map();
                (players || []).forEach((p) => {
                    const key = (p.name || '').toString().trim();
                    if (!key) return;
                    const existing = nameToPlayer.get(key);
                    nameToPlayer.set(key, pickPreferred(existing, p));
                });

                const present = [];
                const notPresent = [];
                for (const [name, p] of nameToPlayer.entries()) {
                    const lastSeen = p.lastSeen && p.lastSeen.toDate ? p.lastSeen.toDate().getTime() : 0;
                    const isPresent = Boolean(p.uid) && (lastSeen > 0) && (now - lastSeen <= PRESENT_WINDOW_MS);
                    const effectivePresent = (youPlayerId && p.id === youPlayerId) || isPresent;
                    (effectivePresent ? present : notPresent).push({ name, p });
                }

                // Sort alphabetically by name within groups
                present.sort((a, b) => a.name.localeCompare(b.name));
                notPresent.sort((a, b) => a.name.localeCompare(b.name));

                // Move your player to the top of the present list
                const youIndex = present.findIndex(item => isYou(item.p));
                if (youIndex > 0) {
                    const [youItem] = present.splice(youIndex, 1);
                    present.unshift(youItem);
                }

                function renderList(items, status) {
                    const ul = document.createElement('ul');
                    ul.className = 'player-list-ul';
                    items.forEach((item) => {
                        const li = document.createElement('li');
                        li.className = 'player-list-item';
                        let dotColor = status === 'present' ? '#22c55e' : '#9ca3af';
                        if (game && game.state === 'reveal' && status === 'present') {
                            const hasSeen = Boolean(item && item.p && item.p.roleSeen);
                            dotColor = hasSeen ? '#22c55e' : '#DA291C';
                        }
                        const dot = document.createElement('span');
                        dot.style.display = 'inline-block';
                        dot.style.width = '10px';
                        dot.style.height = '10px';
                        dot.style.borderRadius = '50%';
                        dot.style.background = dotColor;
                        dot.style.marginRight = '8px';
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'player-name';
                        nameSpan.textContent = isYou(item.p) ? `${item.name} - You` : item.name;
                        li.appendChild(dot);
                        li.appendChild(nameSpan);
                        ul.appendChild(li);
                    });
                    return ul;
                }

                const container = document.createElement('div');
                container.style.display = 'flex';
                container.style.gap = '16px';
                container.style.alignItems = 'flex-start';
                container.style.flexWrap = 'wrap';

                function column(title, count, ul) {
                    const col = document.createElement('div');
                    col.style.flex = '1 1 280px';
                    col.style.minWidth = '260px';
                    col.className = 'card subtle';
                    const header = document.createElement('div');
                    header.className = 'card-header';
                    const titleWrap = document.createElement('div');
                    const h3 = document.createElement('h3');
                    h3.className = 'card-title';
                    h3.textContent = `${title} `;
                    const badge = document.createElement('span');
                    badge.className = 'badge';
                    badge.textContent = String(count);
                    h3.appendChild(badge);
                    titleWrap.appendChild(h3);
                    header.appendChild(titleWrap);
                    const body = document.createElement('div');
                    body.className = 'card-content';
                    body.appendChild(ul);
                    col.appendChild(header);
                    col.appendChild(body);
                    return col;
                }

                const presentCol = column('Present', present.length, renderList(present, 'present'));
                const awayCol = column('Not Present', notPresent.length, renderList(notPresent, 'away'));

                // Determine if all expected players are present
                const expectedCount = (typeof game.playerCount === 'number' && game.playerCount > 0)
                    ? game.playerCount
                    : nameToPlayer.size;
                const allPresent = present.length >= expectedCount && notPresent.length === 0;

                playersList.innerHTML = '';
                if (allPresent) {
                    presentCol.style.flex = '1 1 100%';
                    presentCol.style.minWidth = '100%';
                    container.appendChild(presentCol);
                } else {
                    container.appendChild(presentCol);
                    container.appendChild(awayCol);
                }
                playersList.appendChild(container);

                // Enable start only if current user is host (seat 1) AND all players are present
                let youPlayer = null;
                if (youPlayerId) {
                    youPlayer = (players || []).find(pl => pl && pl.id === youPlayerId) || null;
                }
                const isHost = Boolean(youPlayer && youPlayer.seat === 1);
                startBtn.disabled = !(isHost && allPresent);
                const cancelBtnEl = document.getElementById('cancel-game-btn');
                if (cancelBtnEl) cancelBtnEl.style.display = isHost ? '' : 'none';

                // Hide the Continue (start) button during reveal phase
                if (game && game.state === 'reveal') {
                    startBtn.style.display = 'none';
                } else {
                    startBtn.style.display = '';
                }

                // If game is in reveal state, render role reveal UI
                if (game && game.state === 'reveal') {
                    const reveal = document.createElement('div');
                    reveal.id = 'reveal-container';
                    reveal.className = 'mt-3';
                    // Single centered button to open full-screen reveal overlay
                    const reopenWrap = document.createElement('div');
                    reopenWrap.style.display = 'flex';
                    reopenWrap.style.justifyContent = 'center';
                    reopenWrap.style.alignItems = 'center';
                    reopenWrap.style.gap = '12px';
                    reopenWrap.style.marginTop = '12px';
                    const reopenBtn = document.createElement('button');
                    reopenBtn.className = 'btn btn-secondary btn-lg';
                    reopenBtn.textContent = 'My Secret Role';
                    reopenWrap.appendChild(reopenBtn);

                    // Progress UI (label + bar) placed in Present list
                    const presentBody = presentCol.querySelector('.card-content');
                    const progressWrap = document.createElement('div');
                    progressWrap.id = 'reveal-progress';
                    progressWrap.style.display = 'flex';
                    progressWrap.style.flexDirection = 'column';
                    progressWrap.style.alignItems = 'center';
                    progressWrap.style.gap = '8px';
                    progressWrap.style.marginBottom = '12px';
                    const progressLabel = document.createElement('div');
                    progressLabel.style.fontWeight = '800';
                    progressLabel.style.letterSpacing = '0.02em';
                    const progressBarOuter = document.createElement('div');
                    progressBarOuter.style.width = '100%';
                    progressBarOuter.style.maxWidth = '520px';
                    progressBarOuter.style.height = '10px';
                    progressBarOuter.style.border = '3px solid var(--propaganda-black)';
                    progressBarOuter.style.background = 'rgba(0,0,0,0.08)';
                    progressBarOuter.style.borderRadius = '999px';
                    progressBarOuter.style.overflow = 'hidden';
                    const progressBarInner = document.createElement('div');
                    progressBarInner.style.height = '100%';
                    progressBarInner.style.width = '0%';
                    progressBarInner.style.background = 'var(--liberal-blue)';
                    progressBarInner.style.transition = 'width 200ms ease';
                    progressBarOuter.appendChild(progressBarInner);
                    progressWrap.appendChild(progressLabel);
                    progressWrap.appendChild(progressBarOuter);
                    if (presentBody) presentBody.insertBefore(progressWrap, presentBody.firstChild);

                    const hostControls = document.createElement('div');
                    hostControls.id = 'host-continue';
                    hostControls.className = 'mt-2';
                    hostControls.style.display = 'none';
                    hostControls.style.textAlign = 'center';
                    hostControls.style.marginTop = '0';
                    const hostBtn = document.createElement('button');
                    hostBtn.className = 'btn btn-primary btn-lg';
                    hostBtn.textContent = 'Start Game';
                    hostControls.appendChild(hostBtn);
                    // Place Start Game next to My Secret Role button
                    reopenWrap.appendChild(hostControls);

                    reveal.appendChild(reopenWrap);
                    if (contentRoot) contentRoot.appendChild(reveal);

                    function getYouPlayer() {
                        const authUser = getAuth(app).currentUser;
                        const uid = authUser ? authUser.uid : null;
                        let savedId = null;
                        try { savedId = sessionStorage.getItem(`sh_playerId_${game.id}`); } catch (_) {}
                        let yp = null;
                        if (savedId) yp = (players || []).find(pl => pl && pl.id === savedId) || null;
                        if (!yp && uid) yp = (players || []).find(pl => pl && pl.uid === uid) || null;
                        return yp;
                    }

                    function updateProgress() {
                        const seen = (players || []).filter(p => p && p.roleSeen).length;
                        const totalExpected = (typeof game.playerCount === 'number' && game.playerCount > 0)
                            ? game.playerCount
                            : ((players || []).length);
                        const pct = totalExpected > 0 ? Math.min(100, Math.max(0, Math.round((seen / totalExpected) * 100))) : 0;
                        progressLabel.textContent = `Seen: ${seen} / ${totalExpected}`;
                        progressBarInner.style.width = `${pct}%`;
                        if (isHost && seen === totalExpected && totalExpected > 0) {
                            hostControls.style.display = '';
                        } else {
                            hostControls.style.display = 'none';
                        }
                    }

                    // Full-screen role reveal overlay (centered, toggle, no timer)
                    function openRoleOverlay() {
                        // Remove any existing overlay
                        const existing = document.getElementById('role-overlay');
                        if (existing) existing.remove();

                        const yp = getYouPlayer();
                        const overlay = document.createElement('div');
                        overlay.id = 'role-overlay';
                        overlay.style.position = 'fixed';
                        overlay.style.inset = '0';
                        overlay.style.zIndex = '9999';
                        overlay.style.background = 'rgba(0,0,0,0.9)';
                        overlay.style.display = 'flex';
                        overlay.style.alignItems = 'center';
                        overlay.style.justifyContent = 'center';
                        overlay.style.padding = '20px';

                        const wrap = document.createElement('div');
                        wrap.style.display = 'flex';
                        wrap.style.flexDirection = 'column';
                        wrap.style.alignItems = 'center';
                        wrap.style.justifyContent = 'center';
                        wrap.style.gap = '16px';
                        wrap.style.width = '100%';
                        wrap.style.maxWidth = '720px';
                        wrap.style.textAlign = 'center';

                        const prompt = document.createElement('div');
                        prompt.style.color = '#fff';
                        prompt.style.fontWeight = '800';
                        prompt.style.fontSize = '1.125rem';
                        prompt.textContent = 'Reveal your secret role (tap to toggle)';

                        const roleBox = document.createElement('div');
                        roleBox.style.minHeight = '120px';
                        roleBox.style.display = 'flex';
                        roleBox.style.alignItems = 'center';
                        roleBox.style.justifyContent = 'center';
                        roleBox.style.width = '100%';
                        roleBox.style.border = '4px solid #fff';
                        roleBox.style.borderRadius = '12px';
                        roleBox.style.background = 'rgba(255,255,255,0.1)';
                        roleBox.style.padding = '16px';

                        const roleLabel = document.createElement('div');
                        roleLabel.style.fontWeight = '900';
                        roleLabel.style.letterSpacing = '0.03em';
                        roleLabel.style.fontSize = '2rem';
                        roleLabel.style.color = '#fff';
                        roleLabel.textContent = 'Hidden';
                        roleBox.appendChild(roleLabel);

                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'btn btn-primary btn-lg';
                        toggleBtn.textContent = 'ðŸ‘ï¸ Reveal my secret role';

                        const doneBtn = document.createElement('button');
                        doneBtn.className = 'btn';
                        doneBtn.textContent = 'âœ… Continue';

                        let shown = false;
                        function computeRoleText() {
                            const role = ((yp && yp.role) || '').toString().toUpperCase();
                            const party = ((yp && yp.party) || '').toString().toUpperCase();
                        const label = role ? `${role}${party && role !== party ? ' â€“ ' + party : ''}` : 'Not assigned yet';
                            return { role, party, label };
                        }
                        function setRoleLabelVisible(visible) {
                            shown = visible;
                            if (!visible) {
                                roleLabel.textContent = 'Hidden';
                                roleLabel.style.color = '#fff';
                                toggleBtn.textContent = 'ðŸ‘ï¸ Reveal my secret role';
                            } else {
                                const info = computeRoleText();
                                roleLabel.textContent = info.label;
                                if (info.role === 'HITLER') roleLabel.style.color = '#DA291C';
                                else if (info.party === 'FASCIST' || info.role === 'FASCIST') roleLabel.style.color = '#DA291C';
                                else roleLabel.style.color = '#00AEEF';
                                toggleBtn.textContent = 'ðŸ™ˆ Hide my secret role';
                            }
                        }

                        toggleBtn.addEventListener('click', function() {
                            setRoleLabelVisible(!shown);
                        });

                        doneBtn.addEventListener('click', async function() {
                            const you = getYouPlayer();
                            if (!you) { overlay.remove(); return; }
                            try {
                                await ensureAuth();
                                await updateDoc(doc(db, 'games', game.id, 'players', you.id), { roleSeen: true, lastSeen: serverTimestamp() });
                                try { await logPrivate(game.id, 'You acknowledged viewing your secret role', you.id, { type: 'ack', actorId: you.id }); } catch (_) {}
                            } catch (_) {}
                            overlay.remove();
                        });

                        wrap.appendChild(prompt);
                        wrap.appendChild(roleBox);
                        wrap.appendChild(toggleBtn);
                        wrap.appendChild(doneBtn);
                        overlay.appendChild(wrap);
                        document.body.appendChild(overlay);

                        // Start hidden; user toggles to reveal
                        setRoleLabelVisible(false);
                    }

                    reopenBtn.addEventListener('click', function() { openRoleOverlay(); });

                    hostBtn.addEventListener('click', async function(e) {
                        e.preventDefault();
                        e.stopPropagation();
                        if (!isHost) return;
                        const seen = (players || []).filter(p => p && p.roleSeen).length;
                        const totalExpected = (typeof game.playerCount === 'number' && game.playerCount > 0)
                            ? game.playerCount
                            : ((players || []).length);
                        if (seen !== totalExpected || totalExpected === 0) return;
                        // Prevent double clicks / rapid re-renders from causing multiple writes
                        hostBtn.disabled = true;
                        const originalText = hostBtn.textContent;
                        hostBtn.textContent = 'Startingâ€¦';
                        try {
                            await ensureAuth();
                            await updateDoc(doc(db, 'games', game.id), { state: 'playing', updatedAt: serverTimestamp() });
                            try { await logPublic(game.id, 'All players viewed roles â€” game is starting', { type: 'start' }); } catch (_) {}
                        } catch (_) {}
                        finally {
                            // If navigation hasn't occurred yet for some reason, re-enable button gracefully
                            hostBtn.disabled = false;
                            hostBtn.textContent = originalText;
                        }
                    });

                    updateProgress();

                    // Auto open the full-screen reveal for players who haven't seen their role yet
                    const you = getYouPlayer();
                    if (you && !you.roleSeen) {
                        openRoleOverlay();
                    }
                }
            }

            async function copyInvite() {
                const text = inviteInput.value || '';
                try {
                    if (navigator.clipboard && window.isSecureContext) {
                        await navigator.clipboard.writeText(text);
                    } else {
                        inviteInput.select();
                        document.execCommand('copy');
                    }
                    copyInviteBtn.textContent = 'Copied!';
                    setTimeout(() => { copyInviteBtn.textContent = 'Copy Invite'; }, 1500);
                } catch (e) {
                    console.warn('Copy failed, select manually');
                }
            }

            async function cancelGame(gameId) {
                if (!gameId) return;
                const confirmed = window.confirm('Cancel this game? Players will be returned to home.');
                if (!confirmed) return;
                try {
                    await ensureAuth();
                    const gameRef = doc(db, 'games', gameId);
                    await setDoc(gameRef, { state: 'cancelled', updatedAt: serverTimestamp(), expireAt: new Date() }, { merge: true });
                    try { await logPublic(gameId, 'Game cancelled by host', { type: 'admin' }); } catch (_) {}
                } catch (e) {
                    console.error('Failed to cancel game', e);
                }
                try { localStorage.removeItem('sh_currentGameId'); } catch (_) {}
                try { sessionStorage.removeItem(`sh_playerId_${gameId}`); } catch (_) {}
                window.location.href = '../index.html';
            }

            async function leaveLobby(gameId) {
                if (!gameId) return;
                const confirmed = window.confirm('Leave this lobby?');
                if (!confirmed) return;
                try {
                    // Stop heartbeat updates
                    if (heartbeatTimer) {
                        clearInterval(heartbeatTimer);
                        heartbeatTimer = null;
                    }

                    // Clear uid/lastSeen so this seat becomes available
                    const playerIdKey = `sh_playerId_${gameId}`;
                    let playerId = null;
                    try { playerId = sessionStorage.getItem(playerIdKey); } catch (_) { playerId = null; }
                    if (playerId) {
                        try { await ensureAuth(); } catch (_) {}
                        const playerRef = doc(db, 'games', gameId, 'players', playerId);
                        try {
                            await updateDoc(playerRef, { uid: null, lastSeen: null });
                        } catch (e) {
                            console.warn('Failed to clear player uid/lastSeen', e);
                        }
                        try { await logPublic(gameId, 'A player left the lobby', { type: 'presence', actorId: playerId }); } catch (_) {}
                    }
                } finally {
                    try { sessionStorage.removeItem(`sh_playerId_${gameId}`); } catch (_) {}
                    window.location.href = '../index.html';
                }
            }

            async function startHeartbeat(gameId) {
                try { await ensureAuth(); } catch (_) {}
                const playerIdKey = `sh_playerId_${gameId}`;
                let playerId = null;
                try { playerId = sessionStorage.getItem(playerIdKey); } catch (_) { playerId = null; }
                if (!playerId) {
                    // Try to auto-claim host (Player 1) if uid missing
                    playerId = await autoClaimHost(gameId);
                }
                if (!playerId) {
                    // Fallback: find existing claimed player by current uid
                    try {
                        const authUser = getAuth(app).currentUser;
                        const uid = authUser ? authUser.uid : null;
                        if (uid) {
                            const playersQ = query(collection(doc(db, 'games', gameId), 'players'), where('uid', '==', uid));
                            const snap = await getDocs(playersQ);
                            if (!snap.empty) {
                                const d = snap.docs[0];
                                playerId = d.id;
                                try { sessionStorage.setItem(playerIdKey, playerId); } catch (_) {}
                            }
                        }
                    } catch (_) {}
                }
                if (!playerId) return; // nothing to heartbeat yet

                const playerRef = doc(db, 'games', gameId, 'players', playerId);

                async function beat() {
                    try { await updateDoc(playerRef, { lastSeen: serverTimestamp() }); } catch (_) {}
                }

                // initial beat on load/visibility
                beat();

                if (heartbeatTimer) clearInterval(heartbeatTimer);
                heartbeatTimer = setInterval(beat, HEARTBEAT_INTERVAL_MS);

                document.addEventListener('visibilitychange', function() {
                    if (document.visibilityState === 'visible') beat();
                });
                window.addEventListener('beforeunload', function() {
                    // best-effort; may not complete
                    beat();
                });
            }

            document.addEventListener('DOMContentLoaded', async function() {
                const gameId = getGameIdFromUrl();
                if (!gameId) { window.location.href = '../index.html'; return; }
                const initial = await getGame(gameId);
                if (!initial) { handleGameRemoved(); return; }
                render(initial, []);
                onGameSnapshot(gameId, ({ game, players }) => {
                    if (!game || (game && game.state === 'cancelled')) { handleGameRemoved(); return; }
                    // If host has started the game, route everyone to play screen
                    if (game && game.state === 'playing') {
                        const playUrl = window.location.origin + window.location.pathname.replace(/\/pages\/lobby\.html$/, '/pages/play.html') + '?game=' + encodeURIComponent(game.id);
                        window.location.href = playUrl;
                        return;
                    }
                    render(game, players);
                });
                startHeartbeat(gameId);
                copyInviteBtn.addEventListener('click', copyInvite);
                startBtn.addEventListener('click', async function() {
                    try {
                        await ensureAuth();
                        // Assign roles then switch to reveal state
                        const gameRef = doc(db, 'games', gameId);
                        // Load current players
                        const playersSnap = await getDocs(query(collection(gameRef, 'players'), orderBy('seat', 'asc')));
                        const players = playersSnap.docs.map(d => ({ id: d.id, ...d.data() }));
                        const count = players.length;
                        if (count < 5) { alert('Need at least 5 players to start.'); return; }

                        function rolesForCount(n) {
                            // returns {liberals, fascists, hasHitler: true}
                            const map = { 5:[3,1], 6:[4,1], 7:[4,2], 8:[5,2], 9:[5,3], 10:[6,3] };
                            const ent = map[n] || null;
                            if (!ent) return null;
                            return { liberals: ent[0], fascists: ent[1], hasHitler: true };
                        }
                        const cfg = rolesForCount(count);
                        if (!cfg) { alert('Unsupported player count.'); return; }

                        // Shuffle players
                        const arr = players.slice();
                        for (let i = arr.length - 1; i > 0; i--) {
                            const j = Math.floor(Math.random() * (i + 1));
                            const t = arr[i]; arr[i] = arr[j]; arr[j] = t;
                        }

                        // Pick Hitler
                        const hitlerIndex = Math.floor(Math.random() * arr.length);
                        const assignedIds = new Set();
                        assignedIds.add(arr[hitlerIndex].id);

                        // Pick Fascists (excluding Hitler)
                        let fascistsToPick = cfg.fascists;
                        for (let i = 0; i < arr.length && fascistsToPick > 0; i++) {
                            if (i === hitlerIndex) continue;
                            assignedIds.add(arr[i].id);
                            fascistsToPick--;
                        }

                        // Write roles and randomized order
                        for (let i = 0; i < arr.length; i++) {
                            const p = arr[i];
                            let role = 'liberal';
                            let party = 'liberal';
                            if (i === hitlerIndex) { role = 'hitler'; party = 'fascist'; }
                            else if (assignedIds.has(p.id) && p.id !== arr[hitlerIndex].id) { role = 'fascist'; party = 'fascist'; }
                            await updateDoc(doc(db, 'games', gameId, 'players', p.id), {
                                role,
                                party,
                                roleSeen: false,
                                orderIndex: i
                            });
                        }

                        const initialPresidentId = arr[0] && arr[0].id ? arr[0].id : null;
                        await updateDoc(gameRef, {
                            state: 'reveal',
                            updatedAt: serverTimestamp(),
                            startedAt: serverTimestamp(),
                            presidentIndex: 0,
                            currentPresidentPlayerId: initialPresidentId,
                            currentChancellorPlayerId: null,
                            termLimitLastPresidentId: null,
                            termLimitLastChancellorId: null
                        });
                        // Log role assignment and knowledge
                        try {
                            // Public timeline basics
                            await logPublic(gameId, 'Game started', { type: 'start' });
                            await logPublic(gameId, 'Players randomized into order: ' + arr.map(p => p.name || 'Player').join(', '), { type: 'setup' });
                            await logPublic(gameId, 'Order created', { type: 'setup' });
                            await logPublic(gameId, 'Roles assigned', { type: 'setup' });
                            const initialPresident = arr.find(p => p.id === initialPresidentId);
                            await logPublic(gameId, `Game started: roles assigned. Initial President: ${initialPresident ? (initialPresident.name || 'Player') : 'Unknown'}`, { type: 'setup', actorId: initialPresidentId });
                            await logPublic(gameId, 'Hitler role assigned', { type: 'setup' });
                            await logPublic(gameId, 'Fascist team assigned', { type: 'setup' });
                            for (let i = 0; i < arr.length; i++) {
                                const p = arr[i];
                                const roleName = (i === hitlerIndex) ? 'Hitler' : (assignedIds.has(p.id) && p.id !== arr[hitlerIndex].id) ? 'Fascist' : 'Liberal';
                                const partyName = (roleName === 'Liberal') ? 'Liberal' : 'Fascist';
                                await logPrivate(gameId, `Your role: ${roleName}${partyName && roleName !== partyName ? ' â€“ ' + partyName : ''}`, p.id, { type: 'role', actorId: p.id, meta: { role: roleName.toLowerCase(), party: partyName.toLowerCase() } });
                            }
                            const fascists = arr.filter((p, i) => i !== hitlerIndex && assignedIds.has(p.id));
                            const fascistNames = fascists.map(p => p.name || 'Player');
                            if (count <= 6) {
                                const hitler = arr[hitlerIndex];
                                if (hitler && fascistNames.length > 0) {
                                    await logPrivate(gameId, `You know the Fascist: ${fascistNames.join(', ')}`, hitler.id, { type: 'knowledge', actorId: hitler.id });
                                }
                            } else {
                                if (fascistNames.length > 0) {
                                    await logPartied(gameId, `Fascists: ${fascistNames.join(', ')}`, 'fascist', { type: 'knowledge' });
                                }
                            }
                        } catch (_) {}
                    } catch (e) {
                        console.error('Failed to start game', e);
                    }
                });
                const cancelBtn = document.getElementById('cancel-game-btn');
                if (cancelBtn) cancelBtn.addEventListener('click', function() { cancelGame(gameId); });
                const leaveBtn = document.getElementById('leave-lobby-btn');
                if (leaveBtn) leaveBtn.addEventListener('click', function() { leaveLobby(gameId); });
            });
        })();
    </script>
</body>
</html>
